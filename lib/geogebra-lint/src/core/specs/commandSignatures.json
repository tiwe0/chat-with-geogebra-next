[
    {
        "signature": "SetLineOpacity( <Object>, <Number> )",
        "commandBase": "SetLineOpacity",
        "description": "Sets the line opacity for the given object to a number between 0 and 1.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Ends( <Quadric> )",
        "commandBase": "Ends",
        "description": "Creates the top and the bottom of the limited quadric.",
        "examples": [
            {
                "description": "Ends( cylinder ) yields two circles.",
                "command": "Ends( cylinder )"
            },
            {
                "description": "Ends( cone ) yields a circle and the cone end (point).",
                "command": "Ends( cone )"
            }
        ],
        "note": "See also Top Command, Bottom Command and Side Command."
    },
    {
        "signature": "DivisorsList( <Number> )",
        "commandBase": "DivisorsList",
        "description": "Gives the list of all the positive divisors, including the number itself.",
        "examples": [
            {
                "description": "DivisorsList(15) yields {1, 3, 5, 15}, the list of all positive divisors of 15, including 15.",
                "command": "DivisorsList(15)"
            }
        ],
        "note": "See also Divisors Command and DivisorsSum Command."
    },
    {
        "signature": "SetVisibleInView( <Object>, <View Number 1|2|-1>, <Boolean> )",
        "commandBase": "SetVisibleInView",
        "description": "Makes object visible or hidden in given Graphics View. Use -1 for the 3D View",
        "examples": [
            {
                "description": "You can also use these special object names: xAxis, yAxis, zAxis, xOyPlane",
                "command": ""
            }
        ],
        "note": ""
    },
    {
        "signature": "RunClickScript( <Object> )",
        "commandBase": "RunClickScript",
        "description": "Runs the click script associated with the Object (if it has one).",
        "examples": [
            {
                "description": "Let A and B be points. The OnClick script for B is SetValue(B,(1,1)). Setting the OnClick script of A as RunClickScript(B), moves point B to (1,1) when point A is clicked.",
                "command": "RunClickScript(B)"
            }
        ],
        "note": "See also RunUpdateScript command."
    },
    {
        "signature": "Rationalize( <Number> )",
        "commandBase": "Rationalize",
        "description": "Creates the fraction of the given Number, and rationalizes the denominator, if it contains square roots.",
        "examples": [
            {
                "description": "Rationalize a decimal number",
                "command": "Rationalize(3.5)"
            },
            {
                "description": "Rationalize a fraction with square root in denominator",
                "command": "Rationalize(1/sqrt(2))"
            }
        ],
        "note": "This command differs among variants of English: Rationalize (US), Rationalise (UK + Aus). See also MixedNumber Command."
    },
    {
        "signature": "RandomBinomial( <Number of Trials>, <Probability> )",
        "commandBase": "RandomBinomial",
        "description": "Generates a random number from a binomial distribution with n trials and probability p.",
        "examples": [
            {
                "description": "RandomBinomial(3, 0.1) gives j ∈ {0, 1, 2, 3}, where the probability of getting j is the probability of an event with probability 0.1 occuring j times in three tries.",
                "command": "RandomBinomial(3, 0.1)"
            }
        ],
        "note": "See also SetSeed command, RandomBetween command, RandomElement command, RandomNormal command, RandomPoisson command, RandomUniform command."
    },
    {
        "signature": "FitImplicit( <List of Points>, <Order> )",
        "commandBase": "FitImplicit",
        "description": "Attempts to find a best-fit implicit curve of order n ≥ 2 through the points. You need at least stem:[\\frac{n(n+3)}2] points.",
        "examples": [],
        "note": "See also the ImplicitCurve, FitExp, FitGrowth, FitLine, FitLineX, FitLog, FitLogistic, FitPoly, FitPow and FitSin commands."
    },
    {
        "signature": "SetValue( <Boolean>, <0|1> )",
        "commandBase": "SetValue",
        "description": "Sets the state of a boolean / check box : 1 = true, 0 = false",
        "examples": [
            {
                "description": "If b is a boolean, SetValue(b,1) sets the boolean b as true.",
                "command": "SetValue(b,1)"
            }
        ],
        "note": "Additional overloads: SetValue( <Object>, <Object> ) sets the first object's value to the current value of the second; SetValue( <List>, <Number>, <Object> ) sets the n-th element of a free list; SetValue( <Dependent Object>, ? ) sets a dependent object to undefined; SetValue( <drop-down list>, <Number n > ) sets the selected element index in a drop-down list."
    },
    {
        "signature": "ArePerpendicular( <Line>, <Line> )",
        "commandBase": "ArePerpendicular",
        "description": "Decides if the lines are perpendicular. Normally this command computes the result numerically. This behavior can be changed by using the Prove command.",
        "examples": [
            {
                "description": "ArePerpendicular(Line((-1, 0), (0, -1)), Line((0, 0),(2,2))) yields true since the given lines are perpendicular.",
                "command": "ArePerpendicular(Line((-1, 0), (0, -1)), Line((0, 0),(2,2)))"
            }
        ],
        "note": "See also AreCollinear, AreConcurrent, AreConcyclic, AreCongruent, AreEqual, AreParallel, IsTangent commands."
    },
    {
        "signature": "SetDecoration(<Object>, <Number>) or SetDecoration(<Segment>, <Number>, <Number>)",
        "commandBase": "SetDecoration",
        "description": "Sets the decoration of the given object (see also the Style tab in the Properties window of the object). The object must be an angle, a segment or a 'fillable object'. The second argument in the command is the numeric code of the decoration / fill-style, as described in the following table. For segments, it can also set the aspect of the line start and end with two numbers, where the first defines the style of the line segment start, and the second sets the style of the line segment end.",
        "examples": [],
        "note": "In order to view the decoration for segments, it's necessary to hide the two points that define the vertices of the segment. The segment decoration can also be set in the Style tab of the Properties window of the segment."
    },
    {
        "signature": "LinearEccentricity( <Conic> )",
        "commandBase": "LinearEccentricity",
        "description": "Calculates the linear eccentricity of the conic section. For ellipses or hyperbolas the command gives the distance between the conic's center and one of its foci, for circles it gives 0, and for parabolas gives the distance between its focus and the vertex.",
        "examples": [
            {
                "description": "Calculates the linear eccentricity of a conic section",
                "command": "LinearEccentricity(4x2 - y2 + 16x + 20 = 0)"
            }
        ],
        "note": "Returns 2.24 for the given example."
    },
    {
        "signature": "SumSquaredErrors( <List of Points>, <Function> )",
        "commandBase": "SumSquaredErrors",
        "description": "Calculates the sum of squared errors, SSE, between the y-values of the points in the list and the function values of the x-values in the list.",
        "examples": [
            {
                "description": "Calculate SSE for linear and quadratic polynomial fits to demonstrate which offers better fit",
                "command": "SumSquaredErrors(L, f) where L={(1, 2), (3, 5), (2, 2), (5, 2), (5, 5)}, f(x)=FitPoly(L,1) yields 9; SumSquaredErrors(L, g) where g(x)=FitPoly(L,2) yields 6.99"
            }
        ],
        "note": "The example shows that g(x) (quadratic fit) offers the best fit in the sense of the least sum of squared errors (Gauss method)."
    },
    {
        "signature": "Determinant( <Matrix> )",
        "commandBase": "Determinant",
        "description": "Gives the determinant of the matrix. If the matrix contains undefined variables, it yields a formula for the determinant.",
        "examples": [
            {
                "description": "Determinant of a numeric matrix",
                "command": "Determinant({{1, 2}, {3, 4}})"
            },
            {
                "description": "Determinant of a matrix with variables",
                "command": "Determinant({{1, a}, {b, 4}})"
            }
        ],
        "note": "CAS Syntax: Determinant( <Matrix> ) gives the determinant of the matrix. If the matrix contains undefined variables, it yields a formula for the determinant."
    },
    {
        "signature": "RandomBetween( <Minimum Integer> , <Maximum Integer> [, <Boolean Fixed> | <Number of Samples> ] )",
        "commandBase": "RandomBetween",
        "description": "Generates random integers between specified minimum and maximum values (inclusive).",
        "examples": [
            {
                "description": "Generates a random integer between minimum and maximum (inclusive)",
                "command": "RandomBetween(0, 10)"
            },
            {
                "description": "Generates a random integer between minimum and maximum (inclusive) that is updated just once (when file is loaded and also on undo/redo)",
                "command": "RandomBetween(0, 10, true)"
            },
            {
                "description": "Generates a list of random integers between minimum and maximum (inclusive) with specified number of samples",
                "command": "RandomBetween(0, 10, 5)"
            }
        ],
        "note": "Press [.kcode]F9 to see the difference between syntaxes. See also SetSeed, RandomElement, RandomBinomial, RandomNormal, RandomPoisson, RandomUniform commands."
    },
    {
        "signature": "TMean2Estimate( <List of Sample Data 1>, <List of Sample Data 2>, <Confidence Level>, <Boolean Pooled> ) or TMean2Estimate( <Sample Mean 1>, <Sample Standard Deviation 1>, <Sample Size 1>, <Sample Mean 2>, <Sample Standard Deviation 2>, <Sample Size 2>, <Confidence Level>, <Boolean Pooled> )",
        "commandBase": "TMean2Estimate",
        "description": "Calculates a t confidence interval estimate of the difference between two population means using either sample data sets or sample statistics and a confidence level. If Pooled = true, population variances are assumed equal and sample standard deviations are combined; if Pooled = false, they are not assumed equal and not combined. Results are returned as {lower confidence limit, upper confidence limit}.",
        "examples": [],
        "note": "This command supports two overloaded signatures: one using raw sample data lists and another using computed sample statistics (means, standard deviations, sizes). Ensure inputs are correctly formatted for the chosen signature."
    },
    {
        "signature": "Cauchy( <Median>, <Scale>, <Variable value> )",
        "commandBase": "Cauchy",
        "description": "Calculates the value of the cumulative density function (cdf) at the given variable value v of a Cauchy distribution, that is the probability P(X≤v) where X is a random variable of a Cauchy distribution of given parameters median and scale.",
        "examples": [
            {
                "description": "Cauchy(1, 2, 3) yields 0.75 in the Algebra View and stem:[\\frac{3}{4}] in the CAS View.",
                "command": "Cauchy(1, 2, 3)"
            }
        ],
        "note": "This syntax returns the probability for a given value, that is the area under the Cauchy distribution curve to the left of the given _x_-coordinate. If Cumulative is true, calculates the value of a cumulative distribution function of a Cauchy distribution at variable value, otherwise it calculates the value of the probability density function (pdf) at variable value of the given Cauchy distribution of parameters median and scale. If Cumulative is true, creates the cumulative distribution function of a Cauchy distribution, otherwise creates the probability density function of the given Cauchy distribution of parameters median and scale."
    },
    {
        "signature": "Fit( <List of Points>, <List of Functions> ) or Fit( <List of points>, <Function> )",
        "commandBase": "Fit",
        "description": "Returns a linear combination of the functions that best fit the points in the list, or returns a function that fits the points with minimum squared error for a specified model with sliders.",
        "examples": [
            {
                "description": "Fit points with functions x^2 and x",
                "command": "Fit({(-2, 3), (0, 1), (2, 1), (2, 3)}, {x^2, x})"
            },
            {
                "description": "Fit points with a model function a + x^2 using a slider",
                "command": "Fit({(-2, 3), (0, 1), (2, 1), (2, 3)}, a + x^2)"
            }
        ],
        "note": "See also FitExp, FitGrowth, FitLine, FitLineX, FitLog, FitLogistic, FitPoly, FitPow, and FitSin. For big/small numbers, consider normalizing them for more accurate results using the Normalize Command."
    },
    {
        "signature": "Line tool and FitLineX Command",
        "commandBase": "Line tool and FitLineX",
        "description": "If you work with big/small numbers, you should consider normalizing them for a more accurate result, see Normalize Command.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Turtle()",
        "commandBase": "Turtle",
        "description": "Creates a turtle at the coordinate origin.",
        "examples": [],
        "note": "See also TurtleForward, TurtleBack, TurtleLeft, TurtleRight, TurtleUp and TurtleDown commands."
    },
    {
        "signature": "IFactor( <Polynomial> )",
        "commandBase": "IFactor",
        "description": "Factors over the irrationals.",
        "examples": [
            {
                "description": "IFactor(x2 + x - 1) gives stem:[ \\left( x + \\frac{-\\sqrt{5} + 1}{2} \\right) \\left( x + \\frac{\\sqrt{5} 1}{2} \\right)]",
                "command": "IFactor(x2 + x - 1)"
            },
            {
                "description": "IFactor(a2 + a - 1, a) returns stem:[ \\left( a + \\frac{-\\sqrt{5} + 1}{2} \\right) \\left( a + \\frac{\\sqrt{5} 1}{2} \\right)]",
                "command": "IFactor(a2 + a - 1, a)"
            }
        ],
        "note": "See also CIFactor command."
    },
    {
        "signature": "ShowAxes( ), ShowAxes( <Boolean> ), ShowAxes( <View>, <Boolean> )",
        "commandBase": "ShowAxes",
        "description": "Shows the axes in the active View. Shows/hides the axes in the active View. Shows/hides the axes in the Graphics View specified by the number 1 or 2 (or 3 for 3D View).",
        "examples": [
            {
                "description": "ShowAxes(true) shows the axes in the active View.",
                "command": "ShowAxes(true)"
            },
            {
                "description": "ShowAxes(false) hides the axes in the active View.",
                "command": "ShowAxes(false)"
            },
            {
                "description": "ShowAxes(1, true) shows the axes in Graphics View.",
                "command": "ShowAxes(1, true)"
            },
            {
                "description": "ShowAxes(2, false) hides the axes in Graphics 2 View.",
                "command": "ShowAxes(2, false)"
            }
        ],
        "note": "See also ShowGrid command. To show / hide a single axis please use SetVisibleInView Command."
    },
    {
        "signature": "GroebnerLexDeg( <List of Polynomials> ) or GroebnerLexDeg( <List of Polynomials>, <List of Variables> )",
        "commandBase": "GroebnerLexDeg",
        "description": "Computes the Gröbner basis of a list of polynomials with respect to graded lexicographical ordering of the variables (also known as grlex, tdeg, lexdeg, total degree lexicographic ordering or elimination ordering).",
        "examples": [
            {
                "description": "Compute Gröbner basis for a list of polynomials",
                "command": "GroebnerLexDeg({x3 - y - 2, x2 + y + 1})"
            },
            {
                "description": "Compute Gröbner basis for a list of polynomials with specified variables",
                "command": "GroebnerLexDeg({x3 - y - 2, x2 + y + 1}, {y, x})"
            }
        ],
        "note": "See also GroebnerDegRevLex and GroebnerLex commands."
    },
    {
        "signature": "Rename( <Object>, <Name> )",
        "commandBase": "Rename",
        "description": "Sets the label of given object to the given name.",
        "examples": [
            {
                "description": "Let c: x2 + 2y2 = 2. Rename(c, \"ell\") sets the label to ell.",
                "command": "Rename(c, \"ell\")"
            }
        ],
        "note": ""
    },
    {
        "signature": "Mean( <List of Raw Data> ) or Mean( <List of Numbers>, <List of Frequencies> )",
        "commandBase": "Mean",
        "description": "Calculates the arithmetic mean of list elements or the weighted mean of the list elements.",
        "examples": [
            {
                "description": "Calculates the arithmetic mean of list elements",
                "command": "Mean({1, 2, 3, 2, 4, 1, 3, 2})"
            },
            {
                "description": "Calculates the arithmetic mean of list elements",
                "command": "Mean({1, 3, 5, 9, 13})"
            },
            {
                "description": "Calculates the weighted mean of the list elements",
                "command": "Mean({1, 2, 3, 4}, {6, 1, 3, 6})"
            },
            {
                "description": "Calculates the weighted mean of the list elements",
                "command": "Mean({1, 2, 3, 4}, {1, 1, 3, 6})"
            }
        ],
        "note": "See also MeanX, MeanY, and SD commands."
    },
    {
        "signature": "Join( <List>, <List>, ... ) or Join( <List of Lists> )",
        "commandBase": "Join",
        "description": "Joins two or more lists, or joins sub-lists from a list of lists into one longer list.",
        "examples": [
            {
                "description": "Join two lists",
                "command": "Join({5, 4, 3}, {1, 2, 3})"
            },
            {
                "description": "Join a single list of lists",
                "command": "Join({{1, 2}})"
            },
            {
                "description": "Join multiple sub-lists from a list of lists",
                "command": "Join({{1, 2, 3}, {3, 4}, {8, 7}})"
            }
        ],
        "note": "The new list contains all elements of the initial lists even if they are the same. The elements of the new list are not re-ordered."
    },
    {
        "signature": "RandomNormal( <Mean>, <Standard Deviation> )",
        "commandBase": "RandomNormal",
        "description": "Generates a random number from a normal distribution with given mean and standard deviation.",
        "examples": [
            {
                "description": "RandomNormal(3, 0.1) yields a random value from a normal distribution with a mean of 3 and standard deviation of 0.1.",
                "command": "RandomNormal(3, 0.1)"
            }
        ],
        "note": "See also SetSeed command, RandomBetween command, RandomElement command, RandomBinomial command, RandomPoisson command, RandomUniform command."
    },
    {
        "signature": "MinimumSpanningTree( <List of Points> )",
        "commandBase": "MinimumSpanningTree",
        "description": "Returns the minimum spanning tree of a complete graph on given vertices in which weight of edge (u,v) is the Euclidian distance between u and v. The resulting object is a locus.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Arc( <Circle>, <Point M>, <Point N> ), Arc( <Ellipse>, <Point M>, <Point N> ), Arc( <Circle>, <Parameter Value>, <Parameter Value> ), Arc( <Ellipse>, <Parameter Value>, <Parameter Value> )",
        "commandBase": "Arc",
        "description": "Returns the directed arc (counterclockwise) of the given circle or ellipse, with endpoints M and N, or returns the circle/ellipse arc whose endpoints are identified by specified parameter values.",
        "examples": [
            {
                "description": "Arc of a circle with endpoints M and N",
                "command": "Arc( <Circle>, <Point M>, <Point N> )"
            },
            {
                "description": "Arc of an ellipse with endpoints M and N",
                "command": "Arc( <Ellipse>, <Point M>, <Point N> )"
            },
            {
                "description": "Arc of a circle defined by parameter values",
                "command": "Arc( <Circle>, <Parameter Value>, <Parameter Value> )"
            },
            {
                "description": "Arc of an ellipse defined by parameter values",
                "command": "Arc( <Ellipse>, <Parameter Value>, <Parameter Value> )"
            }
        ],
        "note": "Internally, parametric forms are used: Circle: (r cos(t), r sin(t)) where r is the circle's radius; Ellipse: (a cos(t), b sin(t)) where a and b are the lengths of the semimajor and semiminor axes. See also CircumcircularArc command."
    },
    {
        "signature": "Sort( <List> ) or Sort( <Values>, <Keys> )",
        "commandBase": "Sort",
        "description": "Sorts a list of numbers, text objects, or points. Can also sort the first list Values according to the corresponding second list Keys.",
        "examples": [
            {
                "description": "Sort a list of numbers",
                "command": "Sort({3, 2, 1})"
            },
            {
                "description": "Sort a list of text objects alphabetically",
                "command": "Sort({\"pears\", \"apples\", \"figs\"})"
            },
            {
                "description": "Sort a list of points by x-coordinates",
                "command": "Sort({(3, 2), (2, 5), (4, 1)})"
            },
            {
                "description": "Sort polynomials by degree using a dependent list",
                "command": "Sort(list1, list2) where list1 = {x3, x2, x6} and list2 = Zip(Degree(a), a, list1)"
            },
            {
                "description": "Draw a polygon with vertices as complex roots sorted by arguments",
                "command": "Polygon(Sort(list1, arg(list1))) where list1 = {ComplexRoot(x10-1)}"
            }
        ],
        "note": "Lists of points are sorted by x-coordinates."
    },
    {
        "signature": "Octahedron( <Equilateral Triangle> ) | Octahedron( <Point>, <Point>, <Direction> ) | Octahedron( <Point>, <Point>, <Point> ) | Octahedron( <Point>, <Point> )",
        "commandBase": "Octahedron",
        "description": "Creates an octahedron based on different input configurations: with an equilateral triangle as base, using two points and a direction to define an edge and orientation, using three points to define the first face (must form an equilateral triangle), or using two points to automatically generate the third point for rotation around the first edge.",
        "examples": [
            {
                "description": "Creates an octahedron with two points, automatically generating the third point for rotation around the first edge.",
                "command": "Octahedron(A, B)"
            },
            {
                "description": "See also commands for creating other geometric solids.",
                "command": "See also Cube, Tetrahedron, Icosahedron, Dodecahedron commands."
            }
        ],
        "note": "Octahedron(A, B) is a shortcut for Octahedron(A, B, C) with C = Point(Circle(Midpoint(A, B), Distance(A, B) sqrt(3) / 2, Segment(A, B)))."
    },
    {
        "signature": "Dot( <Vector>, <Vector> )",
        "commandBase": "Dot",
        "description": "Returns the dot product (scalar product) of the two vectors.",
        "examples": [
            {
                "description": "Dot((1, 3, 2), (0, 3, -2)) yields 5, the scalar product of (1, 3, 2) and (0, 3, -2).",
                "command": "Dot((1, 3, 2), (0, 3, -2))"
            }
        ],
        "note": "See also Cross Command."
    },
    {
        "signature": "FitLine( <List of Points> )",
        "commandBase": "FitLine",
        "description": "Calculates the y on x regression line of the points.",
        "examples": [
            {
                "description": "Calculates the y on x regression line of the points.",
                "command": "FitLine({(-2, 1), (1, 2), (2, 4), (4, 3), (5, 4)}) yields 0.4x + 2."
            },
            {
                "description": "CAS Syntax",
                "command": "FitLine( <List of Points> ): Calculates the y on x regression line of the points. [EXAMPLE] FitLine({(-2, 1), (1, 2), (2, 4), (4, 3), (5, 4)}) yields 0.4x + 2."
            }
        ],
        "note": "See also Best Fit"
    },
    {
        "signature": "Bernoulli( <Probability p>, <Boolean Cumulative> )",
        "commandBase": "Bernoulli",
        "description": "For Cumulative = false returns the bar graph of Bernoulli distribution where probability of success is equal to p. For Cumulative = true returns the bar graph of cumulative Bernoulli distribution.",
        "examples": [],
        "note": "Bernoulli distribution: https://en.wikipedia.org/wiki/Bernoulli_distribution"
    },
    {
        "signature": "InverseBinomial( <Number of Trials>, <Probability of Success>, <Cumulative Probability> )",
        "commandBase": "InverseBinomial",
        "description": "Returns least integer n such that P(X ≤ n) ≥ p, where p is the probability and X is binomial random variable given by Number of Trials and Probability of Success.",
        "examples": [],
        "note": "See also BinomialDist Command."
    },
    {
        "signature": "UnicodeToText( <List of Integers> )",
        "commandBase": "UnicodeToText",
        "description": "Converts the integer Unicode numbers back into text.",
        "examples": [
            {
                "description": "UnicodeToText({104, 101, 108, 108, 111}) yields the text 'hello'.",
                "command": "UnicodeToText({104, 101, 108, 108, 111})"
            }
        ],
        "note": "See also TextToUnicode Command and UnicodeToLetter Command."
    },
    {
        "signature": "AreCollinear( <Point>, <Point>, <Point> )",
        "commandBase": "AreCollinear",
        "description": "Decides if the points are collinear. Normally this command computes the result numerically. This behavior can be changed by using the Prove command.",
        "examples": [
            {
                "description": "AreCollinear((1, 2), (3, 4), (5, 6)) yields true since all the three points lying on the same line.",
                "command": "AreCollinear((1, 2), (3, 4), (5, 6))"
            }
        ],
        "note": "See also AreConcurrent, AreConcyclic, AreCongruent, AreEqual, ArePerpendicular, AreParallel, IsTangent commands."
    },
    {
        "signature": "Integral( <Function> ) | Integral( <Function>, <Variable> ) | Integral( <Function>, <Start x-Value>, <End x-Value> ) | Integral( <Function>, <Start x-Value>, <End x-Value>, <Boolean Evaluate> ) | Integral( <Function>, <Variable>, <Start Value>, <End Value> )",
        "commandBase": "Integral",
        "description": "Gives the indefinite integral with respect to the main variable, partial integral with respect to a given variable, or definite integral over an interval, with options to shade areas and evaluate.",
        "examples": [
            {
                "description": "Gives the indefinite integral of x³",
                "command": "Integral(x³)"
            },
            {
                "description": "Gives the partial integral of x³+3x y with respect to x",
                "command": "Integral(x³+3x y, x)"
            },
            {
                "description": "Gives the definite integral of x³ from 1 to 2",
                "command": "Integral(x³, 1, 2)"
            },
            {
                "description": "Gives the integral of cos(a t) with respect to t in CAS View",
                "command": "Integral(cos(a t), t)"
            },
            {
                "description": "Gives the definite integral of cos(t) with respect to t from a to b",
                "command": "Integral(cos(t), t, a, b)"
            }
        ],
        "note": "This command also shades the area between the function graph and the x-axis for definite integrals. In the CAS View, undefined variables are allowed. The answer isn't guaranteed to be continuous, e.g., for Integral(floor(x)), and in some versions, numerical algorithms may fail for integrals up to asymptotes, so try using the Boolean Evaluate option."
    },
    {
        "signature": "InverseChiSquared( <Degrees of Freedom>, <Probability> )",
        "commandBase": "InverseChiSquared",
        "description": "Computes the inverse of the cumulative distribution function of a Chi squared distribution at probability p, where the Chi squared distribution is defined by the given degrees of freedom. In other words, it finds t such that P(X ≤ t) = p, where X is a Chi squared random variable. Probability p must be a value in the closed interval [0,1].",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Expand( <Expression> )",
        "commandBase": "Expand",
        "description": "Expands the expression.",
        "examples": [
            {
                "description": "Expand the expression (2 x - 1)2 + 2 x + 3",
                "command": "Expand((2 x - 1)2 + 2 x + 3)"
            }
        ],
        "note": "This command needs to load the Computer Algebra System, so can be slow on some computers. Try using the Polynomial Command instead."
    },
    {
        "signature": "KeepIf( <Condition>, <List> ) or KeepIf( <Condition>, <Variable>, <List> )",
        "commandBase": "KeepIf",
        "description": "Creates a new list that only contains those elements of the initial list that fulfil the condition.",
        "examples": [
            {
                "description": "Filter numbers based on a condition",
                "command": "KeepIf(x<3, {1, 2, 3, 4, 1, 5, 6})"
            },
            {
                "description": "Filter objects like points based on a condition with a variable",
                "command": "KeepIf(x(A) < 3, A, {P, Q, R})"
            }
        ],
        "note": "For list of numbers arbitrary condition may be used. For list of other objects one can use only conditions of the form x==constant or x!=constant."
    },
    {
        "signature": "TrigCombine( <Expression> ) or TrigCombine( <Expression>, <Target Function> )",
        "commandBase": "TrigCombine",
        "description": "Combines products of trigonometric terms into sums, or combines sums of trigonometric terms into an expression containing only a trigonometric function. With a target function, it combines terms into an equivalent expression containing only that function.",
        "examples": [
            {
                "description": "Combine product sin(x) cos(3x) into sums",
                "command": "TrigCombine(sin(x) cos(3x))"
            },
            {
                "description": "Combine sum sin(x) + cos(x) into an expression with only a trigonometric function",
                "command": "TrigCombine(sin(x) + cos(x))"
            },
            {
                "description": "Combine sin(x) + cos(x) into an expression containing only sin(x)",
                "command": "TrigCombine(sin(x) + cos(x), sin(x))"
            },
            {
                "description": "Combine product sin(p) cos(3p) into sums using undefined variable p",
                "command": "TrigCombine(sin(p) cos(3p))"
            }
        ],
        "note": "In the CAS View, undefined variables can be used as well. See also TrigExpand Command and TrigSimplify Command."
    },
    {
        "signature": "Pan( <x>, <y> ) or Pan( <x>, <y>, <z> )",
        "commandBase": "Pan",
        "description": "Shifts the active view by x pixels to the right and y pixels upwards for 2D views, or by (x, y, z) pixels for 3D views.",
        "examples": [
            {
                "description": "Shift the active view by x pixels to the right and y pixels upwards",
                "command": "Pan( <x>, <y> )"
            },
            {
                "description": "Shift the active view by (x, y, z) pixels if it is a 3D View, or by (x, y) pixels if it is 2D View",
                "command": "Pan( <x>, <y>, <z> )"
            }
        ],
        "note": "If multiple Graphics Views are visible, the command is applied to the active one. See also ZoomIn, ZoomOut, SetActiveView commands."
    },
    {
        "signature": "Pascal( <n>, <p> )\nPascal( <n>, <p>, <Boolean Cumulative> )\nPascal( <n>, <p>, <Variable Value>, <Boolean Cumulative> )",
        "commandBase": "Pascal",
        "description": "Returns a bar graph of a Pascal distribution (negative binomial distribution). The Pascal distribution models the number of failures before the nth success in repeated mutually independent Bernoulli trials, each with probability of success p.",
        "examples": [
            {
                "description": "If the number of independent Bernoulli trials that must be successful is n = 1, the probability of success in one trial is p = 1/6, then the probability of 2 failures before the success is given by Pascal(1, 1/6, 2, false) which yields 0.12 in the Algebra View and 25/216 in the CAS View.",
                "command": "Pascal(1, 1/6, 2, false)"
            }
        ],
        "note": "This command also works in the CAS View."
    },
    {
        "signature": "Cone( <Circle>, <Height> )\nCone( <Point>, <Point>, <Radius> )\nCone( <Point>, <Vector>, <Angle α> )",
        "commandBase": "Cone",
        "description": "Creates a cone with given base and height.\nCreates a cone with vertex (second point), circle center (first point) and given radius.\nCreates an infinite cone with given point as vertex, axis of symmetry parallel to the given vector and apex angle 2α.",
        "examples": [
            {
                "description": "This command yields undefined if angle ≥ stem:[\\frac{\\pi}{2}].",
                "command": "Cone( <Point>, <Vector>, <Angle α> )"
            },
            {
                "description": "See also InfiniteCone command, the Cone tool and the Extrude to Pyramid or Cone tool, that operates by dragging or selecting a circle and entering altitude to create a right circular cone.",
                "command": "Cone( <Circle>, <Height> )"
            }
        ],
        "note": "Multiple signatures available for different cone creation methods."
    },
    {
        "signature": "GroebnerDegRevLex( <List of Polynomials> ) and GroebnerDegRevLex( <List of Polynomials>, <List of Variables> )",
        "commandBase": "GroebnerDegRevLex",
        "description": "Computes the Gröbner basis of the list of the polynomials with respect to graded reverse lexicographical ordering of the variables (also known as total degree reverse lexicographic ordering, degrevlex or grevlex ordering).",
        "examples": [
            {
                "description": "Compute Gröbner basis for given polynomials",
                "command": "GroebnerDegRevLex({x^3 - y - 2, x^2 + y + 1}) yields {y^2 - x + 3y + 3, x y + x + y + 2, x^2 + y + 1}"
            },
            {
                "description": "Compute Gröbner basis with specified variable order",
                "command": "GroebnerDegRevLex({x^3 - y - 2, x^2 + y + 1}, {y, x}) yields {x^2 + y + 1, y x + y + x + 2, y^2 + 3y - x + 3}"
            }
        ],
        "note": "See also GroebnerLex and GroebnerLexDeg commands."
    },
    {
        "signature": "Incircle( <Point>, <Point>, <Point> )",
        "commandBase": "Incircle",
        "description": "Returns Incircle (https://en.wikipedia.org/wiki/Incircle_and_excircles_of_a_triangle) of the triangle formed by the three Points.",
        "examples": [
            {
                "description": "Let O=(0, 0), A=(3, 0) and B=(0, 5) be three points: Incircle(O, A, B) yields (x - 1.08)² + (y - 1.08)² = 1.18 in Algebra View and draws the corresponding circle in Graphics View.",
                "command": "Incircle(O, A, B)"
            }
        ],
        "note": ""
    },
    {
        "signature": "Perimeter( <Polygon> ), Perimeter( <Conic> ), Perimeter( <Locus> )",
        "commandBase": "Perimeter",
        "description": "Returns the perimeter of the polygon. If the given conic is a circle or ellipse, this command returns its perimeter. Otherwise the result is undefined. If the given locus is finite, this command returns its approximate perimeter. Otherwise the result is undefined.",
        "examples": [
            {
                "description": "Perimeter of a polygon",
                "command": "Perimeter(Polygon((1, 2), (3, 2), (4, 3))) yields 6.58."
            },
            {
                "description": "Perimeter of a conic (circle or ellipse)",
                "command": "Perimeter(x2 + 2y2 = 1) yields 5.4."
            }
        ],
        "note": "See also Circumference command."
    },
    {
        "signature": "Derivative( <Function> ) | Derivative( <Function>, <Number> ) | Derivative( <Function>, <Variable> ) | Derivative( <Function>, <Variable>, <Number> ) | Derivative( <Curve> ) | Derivative( <Curve>, <Number> ) | f'(x) | f''(x) | Derivative( <Expression> ) | Derivative( <Expression>, <Variable> ) | Derivative( <Expression>, <Variable>, <Number> )",
        "commandBase": "Derivative",
        "description": "Returns derivatives of functions, expressions, or parametric curves with respect to variables, including partial derivatives and higher-order derivatives.",
        "examples": [
            {
                "description": "Returns the derivative of the function with respect to the main variable",
                "command": "Derivative(x3 + x2 + x)"
            },
            {
                "description": "Returns the nth derivative of the function with respect to the main variable",
                "command": "Derivative(x3 + x2 + x, 2)"
            },
            {
                "description": "Returns the partial derivative of the function with respect to the given variable",
                "command": "Derivative(x3 y2 + y2 + xy, y)"
            },
            {
                "description": "Returns the nth partial derivative of the function with respect to the given variable",
                "command": "Derivative(x3 + 3x y, x, 2)"
            },
            {
                "description": "Returns the derivative of the curve",
                "command": "Derivative(Curve(cos(t), t sin(t), t, 0, π))"
            },
            {
                "description": "Returns the nth derivative of the curve",
                "command": "Derivative(Curve(cos(t), t sin(t), t, 0, π), 2)"
            },
            {
                "description": "Returns derivative of an expression with respect to the main variable",
                "command": "Derivative(x2)"
            },
            {
                "description": "Returns derivative of an expression with respect to the given variable",
                "command": "Derivative(a x3, a)"
            },
            {
                "description": "Returns the nth derivative of an expression with respect to the given variable",
                "command": "Derivative(y x3, x, 2)"
            }
        ],
        "note": "This only works for parametric curves when applied to curves. You can use f'(x) instead of Derivative(f), or f''(x) instead of Derivative(f, 2), and so on. The command supports both function and CAS syntax."
    },
    {
        "signature": "ApplyMatrix( <Matrix>, <Object> )",
        "commandBase": "ApplyMatrix",
        "description": "Transforms the object O so that point P of O is mapped to: • point M*P, if P is a 2D point and M is a 2 x 2 matrix • point project(M*(x(P), y(P), 1)), if P is a 2D point and M a 3 x 3 matrix: project is a projection, mapping point (x, y, z) to (x/z, y/z). • point M*P, if P is a 3D point and M a 3 x 3 matrix • point N*P, if P is a 3D point and M a 2 x 2 matrix: the matrix N is the completion or order 3 of M: given M = stem:[\\begin{pmatrix}a&b\\\\ c&d \\end{pmatrix}] then N = stem:[\\begin{pmatrix}a&b&0\\\\ c&d&0\\\\0&0&1 \\end{pmatrix}]",
        "examples": [
            {
                "description": "Let M={{cos(π/2),-sin(π/2)}, {sin(π/2), cos(π/2)}} be the transformation matrix and u = (2,1) a given vector (object). ApplyMatrix(M,u) yields the vector u'=(-1,2), i.e. the result of a mathematically positive rotation by 90° of vector u.",
                "command": "ApplyMatrix(M,u)"
            },
            {
                "description": "Let M={{1,1,0},{0,1,1},{1,0,1}} be a matrix and u=(2,1) a given vector. ApplyMatrix(M,u) yields vector u'=(1,0.67). In effect stem:[\\begin{pmatrix}1&1&0\\\\ 0&1&1\\\\1&0&1 \\end{pmatrix}] stem:[\\begin{pmatrix}2\\\\ 1\\\\1 \\end{pmatrix}] = stem:[\\begin{pmatrix}3\\\\ 2\\\\3 \\end{pmatrix}], and (3/3 = 1, 2/3 ≈ 0.67) (rounding to 2 decimal places)",
                "command": "ApplyMatrix(M,u)"
            }
        ],
        "note": "This command also works with quadrics and images."
    },
    {
        "signature": "ToPoint( <Complex Number> )",
        "commandBase": "ToPoint",
        "description": "Creates a point from the complex number.",
        "examples": [
            {
                "description": "ToPoint(3 + 2ί) creates a point with coordinates (3, 2).",
                "command": "ToPoint(3 + 2ί)"
            }
        ],
        "note": "The complex ί is obtained by pressing ALT + i. See also the following commands: ToComplex, ToExponential and ToPolar."
    },
    {
        "signature": "Classes( <List of Data>, <Start>, <Width of Classes> ) or Classes( <List of Data>, <Number of Classes> )",
        "commandBase": "Classes",
        "description": "Gives a list of class boundaries. The first boundary (min) is equal to Start, the last boundary (max) will be at least the maximum of the List and the boundaries will be equally spaced between min and max. Alternatively, with two arguments, the first boundary (min) is equal to the minimum of the List, the last boundary (max) will be the maximum of the List and the boundaries will be equally spaced between min and max.",
        "examples": [
            {
                "description": "Classes with Start and Width",
                "command": "Classes({0.1, 0.2, 0.4, 1.1}, 0, 1)"
            },
            {
                "description": "Classes with Number of Classes",
                "command": "Classes({1, 3, 5, 7, 8, 9, 10}, 3)"
            }
        ],
        "note": "By convention this uses the a ≤ x < b rule for each class except for the last class which is a ≤ x ≤ b."
    },
    {
        "signature": "If( <Condition>, <Then> ) | If( <Condition>, <Then>, <Else> ) | If( <Condition 1>, <Then 1>, <Condition 2>, <Then 2>, ... , <Else (optional)> )",
        "commandBase": "If",
        "description": "Yields a copy of an object based on conditional evaluation. With two arguments, returns Then if Condition is true, undefined if false. With three arguments, returns Then if Condition is true, Else if false. With multiple condition-then pairs and optional Else, returns the Then corresponding to the first satisfied condition, or Else if provided and no conditions are met, otherwise undefined.",
        "examples": [
            {
                "description": "Basic conditional with two arguments",
                "command": "If(n==3, x + y = 4)"
            },
            {
                "description": "Conditional with three arguments",
                "command": "If(n==3, x + y = 4, x - y = 4)"
            },
            {
                "description": "Multiple conditions with Else",
                "command": "If(a ≟ 1, \"Matthew\", a ≟ 2, \"Larry\", a ≟ 3, \"Vivian\", \"Alex\")"
            },
            {
                "description": "Creating a piecewise function",
                "command": "f(x) = If(x < 3, sin(x), x²)"
            },
            {
                "description": "Multivariate conditional function",
                "command": "f(x,y,a,b,c) = If(sliderVal==1, x + 0y +a + 0b + c, sliderVal==2, 0x+ y² + 0a +2b +0c, x + y + 0a + b +0c)"
            },
            {
                "description": "Using If in scripting",
                "command": "If(Mod(n, 7) == 0, SetCoords(A, n, 0), SetCoords(A, n, 1))"
            }
        ],
        "note": "Arguments must be Objects or Scripting Commands, not assignments. A shorter syntax for conditional functions is available, e.g., f(x) = sin(x), 0 <= x <= 3. The derivative of If(condition, f(x), g(x)) yields If(condition, f'(x), g'(x)) without evaluating limits at critical points. See Boolean values for symbols used in conditions."
    },
    {
        "signature": "Text( <Object> [, <Point>] [, <Boolean for Substitution of Variables>] [, <Boolean for LaTeX formula>] [, <Horizontal alignment [-1|0|1]>] [, <Vertical alignment [-1|0|1]>] )",
        "commandBase": "Text",
        "description": "Creates a text containing the formula of the given object, with optional parameters for position, variable substitution, LaTeX rendering, and alignment.",
        "examples": [
            {
                "description": "Creates a text containing the formula of the given object, with default substitution of values.",
                "command": "Text(c)"
            },
            {
                "description": "Creates a text with a Boolean to control variable substitution.",
                "command": "Text(c, true)"
            },
            {
                "description": "Creates a text at a specified point.",
                "command": "Text(\"hello\", (2, 3))"
            },
            {
                "description": "Creates a text at a point with variable substitution control.",
                "command": "Text(c, (2, 1), true)"
            },
            {
                "description": "Creates a text at a point with variable substitution and LaTeX rendering.",
                "command": "Text(c, (2, 1), true, true)"
            },
            {
                "description": "Creates a text at a point with variable substitution, LaTeX rendering, and alignment controls.",
                "command": "Text(c, (2, 1), true, true, -1, 0)"
            }
        ],
        "note": "By default, values are substituted to the corresponding variables. See also Text tool."
    },
    {
        "signature": "ClosestPoint( <Path>, <Point> )",
        "commandBase": "ClosestPoint",
        "description": "Returns a new point on a path which is the closest to a selected point.",
        "examples": [
            {
                "description": "Returns a new point on a path which is the closest to a selected point.",
                "command": "ClosestPoint( <Path>, <Point> )"
            },
            {
                "description": "Returns a new point on the first line which is the closest to the second line.",
                "command": "ClosestPoint( <Line>, <Line> )"
            }
        ],
        "note": "For Functions, this command now uses closest point (rather than vertical point). This works best for polynomials; for other functions the numerical algorithm is less stable."
    },
    {
        "signature": "GCD( <Number>, <Number> ) or GCD( <List of Numbers> ) or GCD( <Polynomial>, <Polynomial> ) or GCD( <List of Polynomials> )",
        "commandBase": "GCD",
        "description": "Calculates the greatest common divisor of numbers or polynomials. In the CAS View, it supports polynomials.",
        "examples": [
            {
                "description": "Calculate GCD of two numbers",
                "command": "GCD(12, 15)"
            },
            {
                "description": "Calculate GCD of a list of numbers",
                "command": "GCD({12, 30, 18})"
            },
            {
                "description": "Calculate GCD of two polynomials in CAS View",
                "command": "GCD(x2 + 4 x + 4, x2 - x - 6)"
            },
            {
                "description": "Calculate GCD of a list of polynomials in CAS View",
                "command": "GCD({x2 + 4 x + 4, x2 - x - 6, x3 - 4 x2 - 3 x + 18})"
            }
        ],
        "note": "This command differs among variants of English: GCD (US), HCF (UK + Aus). In the CAS View, it supports polynomials. See also LCM Command and ExtendedGCD Command."
    },
    {
        "signature": "Max( <List> ), Max( <Interval> ), Max( <Number>, <Number> ), Max( <Function>, <Start x-Value>, <End x-Value> ), Max(<List of Data>, <List of Frequencies> )",
        "commandBase": "Max",
        "description": "Returns the maximum value based on different input types: list of numbers, interval bounds, two numbers, function maximum in interval, or data with frequencies.",
        "examples": [
            {
                "description": "Find maximum of numbers in a list",
                "command": "Max({-2, 12, -23, 17, 15})"
            },
            {
                "description": "Get upper bound of an interval",
                "command": "Max(2 < x < 3)"
            },
            {
                "description": "Find maximum of two numbers",
                "command": "Max(12, 15)"
            },
            {
                "description": "Calculate local maximum point of a function in interval",
                "command": "Max(exp(x)x2,-3,-1)"
            },
            {
                "description": "Find maximum from data with frequencies",
                "command": "Max({1, 2, 3, 4, 5}, {5, 3, 4, 2, 0})"
            },
            {
                "description": "CAS syntax: maximum over interval including endpoints",
                "command": "Max(x2,-1,2)"
            }
        ],
        "note": "For non-numeric objects, uses associated numbers (e.g., segment lengths). Open/closed intervals treated same. For polynomials use Extremum Command. For maximum of two functions f(x) and g(x), use (f(x) + g(x) + abs(f(x) - g(x)))/2. See also Extremum Command, Min Command, and Function Inspector Tool."
    },
    {
        "signature": "IsDefined( <Object> )",
        "commandBase": "IsDefined",
        "description": "Returns true or false depending on whether the object is defined or not.",
        "examples": [
            {
                "description": "Check if a circle object is defined",
                "command": "IsDefined(Circle((1,1), -2))"
            }
        ],
        "note": ""
    },
    {
        "signature": "Factor( <Polynomial> )",
        "commandBase": "Factor",
        "description": "Factors the polynomial.",
        "examples": [
            {
                "description": "Factor a polynomial",
                "command": "Factor(x2 + x - 6)"
            },
            {
                "description": "Factor a number into prime factors",
                "command": "Factor(360)"
            },
            {
                "description": "Factor an expression with respect to variable x",
                "command": "Factor(x2 - y2, x)"
            },
            {
                "description": "Factor an expression with respect to variable y",
                "command": "Factor(x2 - y2, y)"
            }
        ],
        "note": "This command differs among variants of English: Factor (US), Factorise (UK + Aus). It needs to load the Computer Algebra System, so can be slow on some computers. This command factors expressions over the Rational Numbers. To factor over irrational real numbers, see the IFactor Command. To factor over complex numbers, see the CFactor Command and CIFactor Command."
    },
    {
        "signature": "Roots( <Function>, <Start x-Value>, <End x-Value> )",
        "commandBase": "Roots",
        "description": "Calculates the roots for function in the given interval. The function must be continuous on that interval. Because this algorithm is numeric, it may not find all the roots in some cases.",
        "examples": [
            {
                "description": "Roots(f, -2, 1) with the function f(x) = 3x³ + 3x² - x yields A = (-1.264, 0), B = (0, 0), C = (0.264, 0)",
                "command": "Roots(f, -2, 1)"
            }
        ],
        "note": "See also Root command"
    },
    {
        "signature": "PieChart(< List of Frequencies >) or PieChart(< List of Frequencies >, < Center >, < Radius >)",
        "commandBase": "PieChart",
        "description": "Creates a pie chart using a list of frequencies. The whole pie gives 100%, the provided data is shown as pie slices.",
        "examples": [
            {
                "description": "Creates a pie chart using a list of frequencies with default center (0,0) and radius 3",
                "command": "PieChart({20, 15, 40, 5, 10, 20})"
            },
            {
                "description": "Creates a pie chart with a given center and radius using a list of frequencies",
                "command": "PieChart({20, 15, 40, 5, 10, 20},(3,3),5)"
            }
        ],
        "note": "Select the Color tab of the Properties dialog window of the pie chart to choose among a wide selection of colors to customize each slice, and the Style tab to set the filling of each slice."
    },
    {
        "signature": "Vector( <Point> ) or Vector( <Start Point>, <End Point> )",
        "commandBase": "Vector",
        "description": "Returns the position vector of the given point or creates a vector from Start Point to End Point.",
        "examples": [
            {
                "description": "Vector from a single point yields its position vector",
                "command": "Vector((3, 2)) yields u = stem:[\\begin{pmatrix}3\\\\2\\end{pmatrix}]"
            },
            {
                "description": "Vector from two points yields the vector from Start Point to End Point",
                "command": "Vector((1, 1), (3, 4)) yields u = stem:[\\begin{pmatrix}2\\\\3\\end{pmatrix}]"
            }
        ],
        "note": "See also [Image: Mode vector.svg,width=24,height=24] Vector tool."
    },
    {
        "signature": "ChiSquared( <Degrees of Freedom>, <Variable Value> ) or ChiSquared( <Degrees of Freedom>, <Variable Value>, <Boolean Cumulative> )",
        "commandBase": "ChiSquared",
        "description": "Calculates the value of the cumulative distribution function of a Chi squared distribution at variable value v, i.e. the probability P(X ≤ v) where X is a random variable with a Chi squared distribution with the given degrees of freedom.",
        "examples": [
            {
                "description": "Calculates the cumulative distribution function value for 4 degrees of freedom at variable value 3",
                "command": "ChiSquared(4, 3)"
            },
            {
                "description": "Calculates either the cumulative distribution function or probability density function based on the Boolean Cumulative parameter",
                "command": "ChiSquared( <Degrees of Freedom>, <Variable Value>, <Boolean Cumulative> )"
            }
        ],
        "note": "This syntax returns the probability at a given x-coordinate's value, that is the area under the Chi squared distribution curve to the left of the given x-coordinate. If Cumulative = true, calculates the value of the cumulative distribution function of a Chi squared distribution with given degrees of freedom at the given variable value, otherwise it calculates the probability density function of the distribution at variable value."
    },
    {
        "signature": "Root( <Polynomial> ), Root( <Function>, <Initial x-Value> ), Root( <Function>, <Start x-Value>, <End x-Value> )",
        "commandBase": "Root",
        "description": "Yields all roots of the polynomial as intersection points of the function graph and the x-axis, or yields one root of the function using numerical iterative methods with optional initial or interval values.",
        "examples": [
            {
                "description": "Yields all roots of the polynomial as intersection points",
                "command": "Root(0.1*x2 - 1.5*x + 5)"
            },
            {
                "description": "Yields one root of the function using an initial x-value",
                "command": "Root(0.1*x2 - 1.5*x + 5, 6)"
            },
            {
                "description": "Yields one root of the function in a specified interval",
                "command": "Root(0.1x² - 1.5x + 5, 8, 13)"
            },
            {
                "description": "Yields all roots of the polynomial as a list in CAS syntax",
                "command": "Root(x3 - 3 * x2 - 4 * x + 12)"
            }
        ],
        "note": "In the CAS View, this command is only a special variant of Solve Command."
    },
    {
        "signature": "Corner( <Number of Corner> ), Corner( <Graphics View>, <Number of Corner> ), Corner( <Image>, <Number of Corner> ), Corner( <Text>, <Number of Corner> )",
        "commandBase": "Corner",
        "description": "Creates a point at the corner of the Graphics View, Image, or Text based on the specified number. For Graphics View, number n=1,2,3,4 creates a point at the corner, n=5 returns point (w, h) where w and h are width and height in pixels. Always uses the first Graphics View. For 3D Graphics View with -1, numbers 1-8 for corners, 9-13 for special returns like dimensions, view direction, or scales.",
        "examples": [
            {
                "description": "Corner( <Number of Corner> ) won't work inside other commands. Instead create eg C_1 = Corner(1) and use that.",
                "command": "C_1 = Corner(1)"
            },
            {
                "description": "Corner( <Graphics View>, <Number of Corner> ) won't work inside other commands. Instead create eg C_1 = Corner(1, 1) and use that.",
                "command": "C_1 = Corner(1, 1)"
            },
            {
                "description": "Use -1 for the 3D Graphics View's corners (available values for Number: from 1 to 8). Moreover: Corner(-1,9) returns point (w, h, 0), where w and h are width and height of the 3D Graphics View in pixels; Corner(-1,10) returns point (w, h, 0), where w and h are width and height of the main window in pixels; Corner(-1,11) returns view direction or eye position; Corner(-1,12) returns screen left-to-right direction; Corner(-1,13) returns scales for x, y and z axes.",
                "command": "Corner(-1, 9)"
            },
            {
                "description": "Corner( <Text>, <Number of Corner> ) won't work inside the Sequence or Zip commands. Also the Absolute Position on Screen property must be unchecked.",
                "command": "Corner( <Text>, 1 )"
            }
        ],
        "note": "The numbering of the corners is counter‐clockwise and starts at the lower left corner. For Graphics View, always uses the first Graphics View, even if second is active. For 3D Graphics View with -1, special numbers 9-13 provide additional functionality like dimensions and directions."
    },
    {
        "signature": "Dodecahedron( <Regular pentagon> )\nDodecahedron( <Point>, <Point>, <Direction> )\nDodecahedron( <Point>, <Point>, <Point>)\nDodecahedron( <Point>, <Point>)",
        "commandBase": "Dodecahedron",
        "description": "Creates a dodecahedron with different parameter combinations: using a regular pentagon as base; using two points and a direction to determine vertices; using three adjacent points of the first face; or using two adjacent points with automatic third point creation for rotation around the first edge.",
        "examples": [
            {
                "description": "Dodecahedron(A, B) is a shortcut for Dodecahedron(A, B, C) with C = Point(Circle(((1 - sqrt(5)) A + (3 + sqrt(5)) B) / 4, Distance(A, B) sqrt(10 + 2sqrt(5)) / 4, Segment(A, B)))",
                "command": "Dodecahedron(A, B)"
            },
            {
                "description": "See also Cube, Tetrahedron, Icosahedron, Octahedron commands",
                "command": "Cube, Tetrahedron, Icosahedron, Octahedron"
            }
        ],
        "note": "For Dodecahedron( <Point>, <Point>, <Direction> ), the direction must be orthogonal to the segment (if vector/segment/line/ray) or parallel to the segment (if polygon/plane). For Dodecahedron( <Point>, <Point>, <Point>), the points must start a regular pentagon. For Dodecahedron( <Point>, <Point>), the third point is automatically created on a circle for rotation around the first edge."
    },
    {
        "signature": "CIFactor( <Expression> ) or CIFactor( <Expression>, <Variable> )",
        "commandBase": "CIFactor",
        "description": "Factors over the complex irrationals, optionally with respect to a given variable.",
        "examples": [
            {
                "description": "Factor an expression over the complex irrationals",
                "command": "CIFactor(x^2 + x + 1)"
            },
            {
                "description": "Factor an expression over the complex irrationals with respect to a variable",
                "command": "CIFactor(a^2 + a + 1, a)"
            }
        ],
        "note": "See also IFactor command."
    },
    {
        "signature": "TurtleRight( <Turtle>, <Angle> )",
        "commandBase": "TurtleRight",
        "description": "The turtle turns to the right by a given angle.",
        "examples": [
            {
                "description": "TurtleRight(turtle, 1) turns the turtle to the right by 1 rad, if Pause button is displayed. Otherwise you must press the Play button so that the rotation is effected.",
                "command": "TurtleRight(turtle, 1)"
            },
            {
                "description": "If you enter TurtleRight(turtle, 1°) the turtle turns to the right by 1 degree.",
                "command": "TurtleRight(turtle, 1°)"
            },
            {
                "description": "See also Turtle, TurtleBack, TurtleForward and TurtleLeft commands.",
                "command": "TurtleRight"
            }
        ],
        "note": ""
    },
    {
        "signature": "Distance( <Point>, <Object> ): Yields the shortest distance between a point and an object. Distance( <Line>, <Line> ): Yields the distance between two lines. Distance( <Plane>, <Plane> ): Yields the distance between the two planes.",
        "commandBase": "Distance",
        "description": "Yields the shortest distance between a point and an object, between two lines, or between two planes.",
        "examples": [
            {
                "description": "Distance between a point and an object",
                "command": "Distance((2, 1), x^2 + (y - 1)^2 = 1)"
            },
            {
                "description": "Distance between two points in 3D",
                "command": "Distance((2, 1, 2), (1, 3, 0))"
            },
            {
                "description": "Distance between a point and a function",
                "command": "Distance(A, f)"
            },
            {
                "description": "Distance between two lines",
                "command": "Distance(y = x + 3, y = x + 1)"
            },
            {
                "description": "Distance between two lines in 3D",
                "command": "Distance(a: X = (-4, 0, 0) + λ*(4, 3, 0), b: X = (0, 0, 0) + λ*(0.8, 0.6, 0))"
            },
            {
                "description": "Distance between two planes",
                "command": "Distance(eq1: x + y + 2z = 1, eq2: 2x + 2y + 4z = -2)"
            }
        ],
        "note": "The command works for points, segments, lines, conics, functions, and implicit curves. For functions, it uses a numerical algorithm which works better for polynomials. The distance between intersecting lines or planes is 0, so this command is only interesting for parallel lines or planes. See also Distance or Length tool."
    },
    {
        "signature": "HyperGeometric( <Population Size>, <Number of Successes>, <Sample Size> ) | HyperGeometric( <Population Size>, <Number of Successes>, <Sample Size>, <Boolean Cumulative> ) | HyperGeometric( <Population Size>, <Number of Successes>, <Sample Size>, <Variable Value>, <Boolean Cumulative> )",
        "commandBase": "HyperGeometric",
        "description": "Returns a Hypergeometric distribution bar graph or probability values based on parameters, with variations for cumulative distribution and specific variable values.",
        "examples": [
            {
                "description": "Generate a bar graph showing the probability distribution of the number of white balls in a sample drawn without replacement from an urn.",
                "command": "HyperGeometric(100, 50, 5)"
            },
            {
                "description": "Calculate probabilities for selecting white balls in a specific scenario without cumulative distribution.",
                "command": "HyperGeometric(10, 2, 2, 0, false)"
            },
            {
                "description": "Calculate cumulative probabilities for selecting white balls in a specific scenario.",
                "command": "HyperGeometric(10, 2, 2, 0, true)"
            }
        ],
        "note": "In the CAS View, only the syntax HyperGeometric( <Population Size>, <Number of Successes>, <Sample Size>, <Variable Value>, <Boolean Cumulative> ) is supported, returning P(X = v) for false cumulative or P(X ≤ v) for true cumulative."
    },
    {
        "signature": "TurtleBack( <Turtle>, <Distance> )",
        "commandBase": "TurtleBack",
        "description": "The turtle moves back with given distance.",
        "examples": [
            {
                "description": "If the turtle is at the origin of the coordinates and the Pause button is displayed the command TurtleBack(turtle, 2) moves the turtle to the point (-2, 0). Otherwise you must press the Play button so that the displacement is effected.",
                "command": "TurtleBack(turtle, 2)"
            }
        ],
        "note": "See also Turtle, TurtleForward, TurtleLeft and TurtleRight commands."
    },
    {
        "signature": "Weibull( <Shape>, <Scale>, <Variable Value> )",
        "commandBase": "Weibull",
        "description": "Evaluates the cumulative distribution function of a Weibull distribution at variable value v, i.e. calculates the probability P(X ≤ v) where X is a random variable with a Weibull distribution defined by the given parameters shape and scale.",
        "examples": [
            {
                "description": "Weibull(0.5, 1, 0) yields 0.",
                "command": "Weibull(0.5, 1, 0)"
            },
            {
                "description": "Weibull(0.5, 1, 1) yields stem:[1 - \\frac{1} { e } ].",
                "command": "Weibull(0.5, 1, 1)"
            }
        ],
        "note": "This syntax returns the probability at a given value, that is the area under the Weibull distribution curve to the left of the given _x_-coordinate. Weibull( <Shape>, <Scale>, <Variable Value>, <Boolean Cumulative> ): If Cumulative = true, evaluates the cumulative distribution function of a Weibull distribution with given shape and scale at the given variable value, otherwise it evaluates the probability density function of the distribution at variable value. Weibull( <Shape>, <Scale>, x, <Boolean Cumulative> ): If Cumulative = true, creates the cumulative density function (cdf) of a Weibull distribution with given shape and scale, otherwise it creates the probability density function (pdf) of the distribution."
    },
    {
        "signature": "Percentile( <List of Numbers>, <Percent> )",
        "commandBase": "Percentile",
        "description": "Returns the value that cuts off the first P percent of the list of numbers, when the list is sorted in ascending order. Percent must be a number in the interval 0 < P ≤ 1.",
        "examples": [
            {
                "description": "Calculate the 25th percentile of a list",
                "command": "Percentile({1, 2, 3, 4}, 0.25)"
            }
        ],
        "note": "The commands Quartile and Percentile use different rules and do not always return matching results. For example, Q1({1, 2, 3, 4}) yields 1.5 whereas Percentile({1, 2, 3, 4}, 0.25) yields 1.25."
    },
    {
        "signature": "SampleSD( <List of Raw Data> ) or SampleSD( <List of Numbers>, <List of Frequencies> )",
        "commandBase": "SampleSD",
        "description": "Returns the sample standard deviation of the given list of numbers, optionally with frequencies. Equivalent syntax: stdev.",
        "examples": [
            {
                "description": "Calculate sample standard deviation of a simple list",
                "command": "SampleSD({1, 2, 3})"
            },
            {
                "description": "Calculate sample standard deviation with frequencies",
                "command": "SampleSD({1, 2, 3, 4},{1, 1, 1, 2})"
            },
            {
                "description": "Calculate sample standard deviation with undefined variables in CAS View",
                "command": "SampleSD({1, 2, a})"
            }
        ],
        "note": "This command has equivalent syntax stdev( <List of Raw Data> ) and stdev( <List of Numbers>, <List of Frequencies> ). If the list contains undefined variables in the CAS View, the command yields a formula for the sample standard deviation."
    },
    {
        "signature": "NDerivative( <Function> ) or NDerivative( <Function>, <Order n> )",
        "commandBase": "NDerivative",
        "description": "Plots the 1st derivative of the given function, calculated numerically.",
        "examples": [
            {
                "description": "Plots the 1st derivative of the given function, calculated numerically.",
                "command": "NDerivative(x4+2x3-2x+1)"
            },
            {
                "description": "Plots the nth derivative of the given function, calculated numerically.",
                "command": "NDerivative( <Function>, <Order n> )"
            }
        ],
        "note": "For example, NDerivative(x4+2x3-2x+1) plots in Graphics View the graph of the function f(x) = 4x³ + 6x² - 2, which is the first derivative of the given function. However, the equation of the plotted function is not shown in Algebra View."
    },
    {
        "signature": "ImplicitDerivative( <f(x, y)> ) or ImplicitDerivative( <Expression>, <Dependent Variable>, <Independent Variable> )",
        "commandBase": "ImplicitDerivative",
        "description": "Gives the implicit derivative of the given expression.",
        "examples": [
            {
                "description": "Implicit derivative of x + 2y",
                "command": "ImplicitDerivative(x + 2 y)"
            },
            {
                "description": "Implicit derivative of x + 2y with LaTeX output",
                "command": "ImplicitDerivative(x + 2 y)"
            },
            {
                "description": "Implicit derivative of x^2 + y^2 with respect to y and x",
                "command": "ImplicitDerivative(x^2 + y^2, y, x)"
            }
        ],
        "note": "See also Derivative Command."
    },
    {
        "signature": "SetTrace( <Object>, <true | false> )",
        "commandBase": "SetTrace",
        "description": "Turns Tracing on/off for the specified object.",
        "examples": [
            {
                "description": "Create a point A, then type in SetTrace(A,true). Select the Move Tool and drag the point, to show its trace.",
                "command": "SetTrace(A,true)"
            }
        ],
        "note": "Use ZoomIn(1) to clear all traces."
    },
    {
        "signature": "LUDecomposition( <Matrix> )",
        "commandBase": "LUDecomposition",
        "description": "Calculates the LU decomposition of the given matrix.",
        "examples": [
            {
                "description": "LUDecomposition of a 2x2 matrix",
                "command": "LUDecomposition({{2,0},{1,1}})"
            }
        ],
        "note": "See also QRDecomposition command."
    },
    {
        "signature": "SetPerspective( <Text> )",
        "commandBase": "SetPerspective",
        "description": "Changes the layout and visibility of Views. The text parameter is either the full description of the layout, description of a single view you want to change or ID of one of the standard perspectives.",
        "examples": [
            {
                "description": "Make only the Graphics View visible",
                "command": "SetPerspective(\"G\")"
            },
            {
                "description": "Make Algebra, Graphics and Spreadsheet View visible, aligned horizontally",
                "command": "SetPerspective(\"AGS\")"
            },
            {
                "description": "Make Spreadsheet and Graphics View visible with Spreadsheet on top and Graphics View below",
                "command": "SetPerspective(\"S/G\")"
            },
            {
                "description": "Similar as above, the bottom part of the screen consists of Graphics View on the left and Algebra View on the right",
                "command": "SetPerspective(\"S/(GA)\")"
            },
            {
                "description": "Add Graphics View 2 to the currently displayed ones, on the right",
                "command": "SetPerspective(\"+D\")"
            },
            {
                "description": "Remove Graphics View 2 from the currently displayed ones",
                "command": "SetPerspective(\"-D\")"
            },
            {
                "description": "Open the sidebar in Graphing Calculator and switch it to tools tab",
                "command": "SetPerspective(\"+Tools\")"
            },
            {
                "description": "Open the sidebar in Graphing Calculator and switch it to table of values",
                "command": "SetPerspective(\"+Table\")"
            },
            {
                "description": "Close the sidebar in Graphing Calculator, no matter which tab is selected",
                "command": "SetPerspective(\"-Tools\")"
            }
        ],
        "note": "See also SetActiveView command."
    },
    {
        "signature": "PlotSolve( <Equation in x> )",
        "commandBase": "PlotSolve",
        "description": "Solves a given equation for the main variable and returns a list of all solutions and the graphical output in the Graphics View.",
        "examples": [
            {
                "description": "PlotSolve(x2 = 4x) yields {(0, 0), (4, 0)} and displays the points (0, 0) and (4, 0) in the Graphics View.",
                "command": "PlotSolve(x2 = 4x)"
            }
        ],
        "note": ""
    },
    {
        "signature": "IntegralBetween( <Function>, <Function>, <Number>, <Number> ) and IntegralBetween( <Function>, <Function>, <Number>, <Number>, <Boolean Evaluate> ) and IntegralBetween( <Function>, <Function>, <Variable>, <Number>, <Number> )",
        "commandBase": "IntegralBetween",
        "description": "Gives the definite integral of the difference f(x) - g(x) of two functions f and g over the interval [a, b], where a is the first number and b the second, with respect to the main variable or a specified variable, and optionally shades the area between the function graphs.",
        "examples": [
            {
                "description": "Integral of sin(x) - cos(x) from 0 to pi",
                "command": "IntegralBetween(sin(x), cos(x), 0, pi)"
            },
            {
                "description": "Integral of sin(x) - cos(x) from pi/4 to 5pi/4",
                "command": "IntegralBetween(sin(x), cos(x), pi / 4, pi * 5 / 4)"
            },
            {
                "description": "Integral of a*sin(t) - a*cos(t) with respect to t from pi/4 to 5pi/4",
                "command": "IntegralBetween(a * sin(t), a * cos(t), t, pi / 4, pi * 5 / 4)"
            }
        ],
        "note": "This command also shades the area between the function graphs of f and g, and in the version with a Boolean Evaluate parameter, it controls whether the integral value is calculated (true) or only the area is shaded (false)."
    },
    {
        "signature": "RunUpdateScript( <Object> ):",
        "commandBase": "RunUpdateScript",
        "description": "Runs the update script associated with the Object (if it has one).",
        "examples": [],
        "note": "See also RunClickScript command."
    },
    {
        "signature": "Center( <Conic> ) or Center( <Quadric> )",
        "commandBase": "Center",
        "description": "Returns the center of a circle, ellipse, or hyperbola; or creates the center of a quadric (e.g. sphere, cone, etc.). Note: This command differs among variants of English: Center (US), Centre (UK + Aus).",
        "examples": [
            {
                "description": "Center of a conic equation",
                "command": "Center(x2 + 4 y2 + 2x - 8y + 1 = 0) returns point A = (-1, 1)"
            },
            {
                "description": "Center of a quadric equation",
                "command": "Center(x2 + (y-1)2 + (z-2)2 = 1) yields (0, 1, 2)"
            }
        ],
        "note": "See also Midpoint or Center (UK/Aus: Midpoint or Centre) tool."
    },
    {
        "signature": "Midpoint( <Segment> | <Conic> | <Interval> | <Point>, <Point> | <Quadric> )",
        "commandBase": "Midpoint",
        "description": "Returns the midpoint or center of various geometric objects.",
        "examples": [
            {
                "description": "Returns the midpoint of the segment.",
                "command": "Midpoint(Segment((1, 1), (1, 5)))"
            },
            {
                "description": "Returns the center of the conic.",
                "command": "Midpoint(x^2 + y^2 = 4)"
            },
            {
                "description": "Returns the midpoint of the interval (as number).",
                "command": "Midpoint(2 < x < 4)"
            },
            {
                "description": "Returns the midpoint of two points.",
                "command": "Midpoint((1, 1), (5, 1))"
            },
            {
                "description": "Returns the midpoint of the given quadric (e.g. sphere, cone, etc.)",
                "command": "Midpoint(x^2 + y^2 + z^2 = 1)"
            }
        ],
        "note": "See also Midpoint or Center tool."
    },
    {
        "signature": "SetLayer( <Object>, <Layer> )",
        "commandBase": "SetLayer",
        "description": "Sets the layer for given object, where number of the layer must be an integer between 0 and 9 included.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "StartAnimation( ), StartAnimation( <Boolean> ), StartAnimation( <Point or Slider>, <Point or Slider>, .... ), StartAnimation( <Point or Slider>, <Point or Slider>, ...., <Boolean> )",
        "commandBase": "StartAnimation",
        "description": "Resumes all animations if they are paused. When the boolean is false, pauses all animations, otherwise resumes them. Starts animating given points and sliders, the points must be on paths. Starts (for boolean = true) or permanently stops (for boolean = false) animating given points and sliders, the points must be on paths.",
        "examples": [
            {
                "description": "Resumes all animations if they are paused",
                "command": "StartAnimation( )"
            },
            {
                "description": "When the boolean is false, pauses all animations, otherwise resumes them",
                "command": "StartAnimation( <Boolean> )"
            },
            {
                "description": "Starts animating given points and sliders, the points must be on paths",
                "command": "StartAnimation( <Point or Slider>, <Point or Slider>, .... )"
            },
            {
                "description": "Starts (for boolean = true) or permanently stops (for boolean = false) animating given points and sliders, the points must be on paths",
                "command": "StartAnimation( <Point or Slider>, <Point or Slider>, ...., <Boolean> )"
            }
        ],
        "note": "See also Animation."
    },
    {
        "signature": "Syy( <List of Points> )",
        "commandBase": "Syy",
        "description": "Calculates the statistic stem:[ \\sum y2 -\\frac{ (\\sum y)2}{n}] using the _y_-coordinates of the given points.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Checkbox( ), Checkbox( <Caption> ), Checkbox( <List> ), Checkbox( <Caption>, <List> )",
        "commandBase": "Checkbox",
        "description": "Creates a checkbox. Variants include creating a checkbox with a caption, a checkbox that hides listed objects when unchecked, or both.",
        "examples": [
            {
                "description": "Let A and B be points. c = Checkbox({A,B}) creates checkbox c. When c is checked, A and B are visible, otherwise they are hidden.",
                "command": "c = Checkbox({A,B})"
            }
        ],
        "note": "The command supports multiple signatures for different use cases, such as adding captions or controlling visibility of objects."
    },
    {
        "signature": "Last( <List> ) | Last( <List>, <Number of elements> ) | Last( <Text> ) | Last( <Text>, <Number of elements> )",
        "commandBase": "Last",
        "description": "Gives a new list that contains the last element(s) of the initial list or text.",
        "examples": [
            {
                "description": "Get last element of a list",
                "command": "Last({1, 4, 3})"
            },
            {
                "description": "Get last n elements of a list",
                "command": "Last({1, 4, 3}, 2)"
            },
            {
                "description": "Get last character of text",
                "command": "Last(\"Hello\")"
            },
            {
                "description": "Get last n characters of text",
                "command": "Last(\"Hello\", 2)"
            },
            {
                "description": "Alternative way to get last element",
                "command": "Element({1, 4, 3}, 3)"
            }
        ],
        "note": "See also First Command."
    },
    {
        "signature": "Type( <Object> )",
        "commandBase": "Type",
        "description": "For conics and quadrics this command returns a number representing the conic/quadric type according to the table below. In this context, an empty conic (or quadric) is one whose coefficients are defined, but that does not contain any real point, e.g. _x_2 + _y_2 = -1. For conics, GeoGebra distinguishes double line (special case of parallel lines with distance 0) and single line (special case of circle with infinite diameter, may result from circle inversion). For quadrics there is no such distinction.",
        "examples": [
            {
                "description": "Type(x²+y²=1) yields 4 which stands for circle.",
                "command": "Type(x²+y²=1)"
            }
        ],
        "note": "The command returns numeric values corresponding to specific conic/quadric types: 1 (Single point), 2 (Intersecting lines), 3 (Ellipse/Ellipsoid), 4 (Circle/Sphere), 5 (Hyperbola), 6 (Empty), 7 (Double line), 8 (Parallel lines), 9 (Parabola/Paraboloid), 10 (Line), 30 (Cone), 31 (Cylinder), 33 (Plane), 34 (Parallel planes), 35 (Intersecting planes), 36 (Hyperboloid of one sheet), 37 (Hyperboloid of two sheets), 38 (Parabolic cylinder), 39 (Hyperbolic cylinder), 40 (Hyperbolic paraboloid)."
    },
    {
        "signature": "PlaySound( <URL> ) | PlaySound( <Boolean Play> ) | PlaySound( <Function>, <Min Value>, <Max Value> ) | PlaySound( <Function>, <Min Value>, <Max Value>, <Sample Rate>, <Sample Depth> ) | PlaySound( <Note>, <Duration>, <Instrument> )",
        "commandBase": "PlaySound",
        "description": "Plays an MP3 file from a URL, controls playback (play/pause), generates sound from a function, or plays MIDI notes (GeoGebra Classic 5 only).",
        "examples": [
            {
                "description": "Play an MP3 file from a URL",
                "command": "PlaySound(\"https://github.com/murkle/utils/raw/refs/heads/master/welcome-to-geogebra-markus.mp3\")"
            },
            {
                "description": "Play or pause sound (not for MP3 files)",
                "command": "PlaySound(true)"
            },
            {
                "description": "Generate sound from a function (e.g., sine wave at 440 Hz for 1 second)",
                "command": "PlaySound(sin(440 2Pi x), 0, 1)"
            },
            {
                "description": "Play a MIDI note (GeoGebra Classic 5 only)",
                "command": "PlaySound(60, 2, 1)"
            }
        ],
        "note": "For iOS or immediate playback, encode MP3 as a base64 data URL starting with 'data:audio/mp3;base64,'. Use provided utility for conversion. MIDI note values range from 0 to 127, with 60 as Middle C. Sample rates allowed: 8000, 11025, 16000, 22050, or 44100. Sample depths allowed: 8 or 16 bits."
    },
    {
        "signature": "Take( <List>, <Start Position> ) | Take( <Text>, <Start Position> ) | Take( <List>, <Start Position>, <End Position> ) | Take( <Text>, <Start Position>, <End Position> )",
        "commandBase": "Take",
        "description": "Returns a list or text containing elements from Start Position to the end or between Start and End Positions of the initial list or text.",
        "examples": [
            {
                "description": "Take elements from position 3 to end of list",
                "command": "Take({2, 4, 3, 7, 4}, 3)"
            },
            {
                "description": "Take characters from position 3 to end of text",
                "command": "Take(\"GeoGebra\", 3)"
            },
            {
                "description": "Take elements from position 3 to 4 of list",
                "command": "Take({2, 4, 3, 7, 4}, 3, 4)"
            },
            {
                "description": "Take characters from position 3 to 6 of text",
                "command": "Take(\"GeoGebra\", 3, 6)"
            }
        ],
        "note": "The command handles both lists and text inputs, with optional End Position parameter. Position indexing typically starts at 1."
    },
    {
        "signature": "SolveODE( <f'(x, y)> ), SolveODE( <f'(x, y)>, <Point on f> ), SolveODE( <f'(x, y)>, <Start x>, <Start y>, <End x>, <Step> ), SolveODE( <y'>, <x'>, <Start x>, <Start y>, <End t>, <Step> ), SolveODE( <b(x)>, <c(x)>, <f(x)>, <Start x>, <Start y>, <Start y'>, <End x>, <Step> ), SolveODE( <Equation> ), SolveODE( <Equation>, <Point(s) on f> ), SolveODE( <Equation>, <Point(s) on f>, <Point(s) on f'> ), SolveODE( <Equation>, <Dependent Variable>, <Independent Variable>, <Point(s) on f> ), SolveODE( <Equation>, <Dependent Variable>, <Independent Variable>, <Point(s) on f>, <Point(s) on f'> )",
        "commandBase": "SolveODE",
        "description": "Solves ordinary differential equations (ODEs) either exactly or numerically, supporting first and second order ODEs with various parameter combinations for initial conditions, numerical solving, and CAS syntax.",
        "examples": [
            {
                "description": "Find exact solution of first order ODE",
                "command": "SolveODE(2x / y)"
            },
            {
                "description": "Solve first order ODE with initial point (Cauchy problem)",
                "command": "SolveODE(y / x, (1, 2))"
            },
            {
                "description": "Solve first order ODE numerically with start point, end x, and step",
                "command": "SolveODE(-x*y, x(A), y(A), 5, 0.1)"
            },
            {
                "description": "Solve ODE in parametric form to handle vertical points",
                "command": "SolveODE(-x, y, x(A), y(A), 5, 0.1)"
            },
            {
                "description": "Solve second order ODE numerically",
                "command": "SolveODE(x2, 2x, 2x2 + x, x(A), y(A), 0, 5, 0.1)"
            },
            {
                "description": "CAS syntax: Solve first order ODE exactly",
                "command": "SolveODE(y' = y / x)"
            },
            {
                "description": "CAS syntax: Solve ODE with initial point",
                "command": "SolveODE(y' = y / x, (1, 2))"
            },
            {
                "description": "CAS syntax: Solve second order ODE with initial conditions for y and y'",
                "command": "SolveODE(y'' - 3y' + 2 = x, (2, 3), (1, 2))"
            },
            {
                "description": "CAS syntax: Solve ODE with specified dependent and independent variables",
                "command": "SolveODE(v' = v / w, v, w, (1, 2))"
            },
            {
                "description": "CAS syntax: Solve ODE with specified variables and initial conditions for function and derivative",
                "command": "SolveODE(v' = v / w, v, w, (1, 2), (0, 2))"
            }
        ],
        "note": "• For first order ODEs, the command supports exact solutions, numerical solutions with Runge-Kutta methods, and parametric form for curves with vertical points.\n• For second order ODEs, it supports numerical solutions.\n• Constants like c₁ are created as auxiliary objects with sliders.\n• Results are returned as loci; use Length( <Locus> ) to count points and First( <Locus>, <Number> ) to extract points.\n• For reverse solutions, use negative values for End x or End t.\n• In CAS syntax, y' and y'' denote derivatives; if the first parameter is an expression without derivatives, it's treated as the right-hand side with y' on the left.\n• See also SlopeField command."
    },
    {
        "signature": "ToPolar( <Vector> ):\n  Transforms a vector into its polar coordinates.\nToPolar( <Complex Number> ):\n  Transforms a complex number into its polar coordinates.",
        "commandBase": "ToPolar",
        "description": "Transforms a vector or complex number into its polar coordinates.",
        "examples": [
            {
                "description": "Transform a vector into polar coordinates",
                "command": "ToPolar({1, sqrt(3)})"
            },
            {
                "description": "Transform a complex number into polar coordinates",
                "command": "ToPolar(1 + sqrt(3) * ί)"
            }
        ],
        "note": "The complex ί is obtained by pressing ALT + i. See also ToComplex Command, ToExponential Command and ToPoint Command."
    },
    {
        "signature": "InputBox( <Linked Object> )",
        "commandBase": "InputBox",
        "description": "Create a new Input Box and associate a Linked Object with it.",
        "examples": [
            {
                "description": "InputBox( <Linked Object> ): Create a new Input Box and associate a Linked Object with it.",
                "command": "InputBox( <Linked Object> )"
            }
        ],
        "note": "See also [Image: Mode textfieldaction.svg,width=23,height=23] Input Box Tool."
    },
    {
        "signature": "Shear( <Object>, <Line>, <Ratio> )",
        "commandBase": "Shear",
        "description": "Shears the object so that points on the line stay fixed, points at distance d from the line are shifted by d * ratio in direction of the line (direction of the shift is different for halfplanes with respect to the line). A sheared plane figure maintains its original area.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "LimitAbove( <Function>, <Value> )",
        "commandBase": "LimitAbove",
        "description": "Computes the right one-sided limit of the function for the given value of the main function variable.",
        "examples": [
            {
                "description": "Compute the right one-sided limit of 1/x as x approaches 0",
                "command": "LimitAbove(1 / x, 0)"
            }
        ],
        "note": "Not all limits can be calculated by GeoGebra, so undefined will be returned in those cases (as well as when the correct result is undefined). See also Limit Command and LimitBelow Command."
    },
    {
        "signature": "DelaunayTriangulation( <List of Points> )",
        "commandBase": "DelaunayTriangulation",
        "description": "Creates a Delaunay Triangulation (https://en.wikipedia.org/wiki/Delaunay_Triangulation) of the list of points. Returned object is a locus, so it is auxiliary.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Spline( <List of Points> ) | Spline( <List of Points>, <Order ≥ 3> ) | Spline( <List of Points>, <Order ≥ 3>, <Weight Function> )",
        "commandBase": "Spline",
        "description": "Creates a cubic spline through all points, with options to specify order and weight function for custom behavior.",
        "examples": [],
        "note": "The default weight function ensures that transformations like rotation are consistent, e.g., Rotate(Spline(list), a) equals Spline(Rotate(list, a))."
    },
    {
        "signature": "ChiSquaredTest( <Matrix> ), ChiSquaredTest( <Observed List>, <Expected List> ), ChiSquaredTest( <Observed Matrix>, <Expected Matrix> ), ChiSquaredTest( <List>, <List>, <Degrees of Freedom> )",
        "commandBase": "ChiSquaredTest",
        "description": "Performs chi-squared tests for independence or goodness of fit, returning results as {Probability value, chi-squared test statistic}.",
        "examples": [
            {
                "description": "Performs a chi-squared test that compares the given matrix of observed counts against the matrix of expected counts determined by the hypothesis of independence.",
                "command": "ChiSquaredTest({{1, 2, 1}, {3, 2, 3}})"
            },
            {
                "description": "Performs a Goodness of Fit test that compares the given list of observed counts against the given list of expected counts.",
                "command": "ChiSquaredTest({1, 2, 3, 4}, {3, 2, 4, 2})"
            },
            {
                "description": "Performs a chi-squared test that compares the given matrix of observed counts against the given matrix of expected counts.",
                "command": "ChiSquaredTest({{1, 2, 1}, {3, 2, 3}}, {{2, 3, 2}, {4, 2, 3}})"
            },
            {
                "description": "Performs a Goodness of Fit test that compares the given list of observed counts against the given list of expected counts, using a specific number of degrees of freedom.",
                "command": "ChiSquaredTest({1, 2, 3, 4}, {3, 2, 4, 2}, 2)"
            }
        ],
        "note": "For lists or matrices of different sizes, the result is undefined. Degrees of freedom are calculated internally for some overloads or specified in others."
    },
    {
        "signature": "Quartile1( <List of Raw Data> ) or Quartile1( <List of Numbers>, <List of Frequencies> )",
        "commandBase": "Quartile1",
        "description": "Determines the lower quartile of the list elements. Optionally, it can consider frequencies for the calculation.",
        "examples": [
            {
                "description": "Calculate the lower quartile of a simple list of numbers",
                "command": "Quartile1({1, 2, 3, 4})"
            },
            {
                "description": "Calculate the lower quartile of a list with frequencies",
                "command": "Quartile1({1, 2, 3, 4}, {3, 2, 4, 2})"
            }
        ],
        "note": "GeoGebra uses the Moore & McCabe (2002) method to calculate quartiles, see https://mathworld.wolfram.com/Quartile.html"
    },
    {
        "signature": "Poisson( <Mean> ) | Poisson( <Mean>, <Boolean Cumulative> ) | Poisson( <Mean>, <Variable Value v>, <Boolean Cumulative> )",
        "commandBase": "Poisson",
        "description": "Returns a bar graph of a Poisson distribution with given mean λ, or calculates probabilities for a Poisson random variable.",
        "examples": [
            {
                "description": "Calculate cumulative probability P(X ≤ 1) for Poisson distribution with mean 3",
                "command": "Poisson(3, 1, true)"
            },
            {
                "description": "Calculate probability P(X = 1) for Poisson distribution with mean 3",
                "command": "Poisson(3, 1, false)"
            },
            {
                "description": "Calculate probability P(1 ≤ X ≤ 5) for Poisson distribution with mean 1 using simplified syntax",
                "command": "Poisson(1, 1..5)"
            }
        ],
        "note": "A simplified syntax is available to calculate P(u ≤ X ≤ v): e.g. Poisson(1, 1..5) yields 0.63153, which is the same as Poisson(1, {1, 2, 3, 4, 5})."
    },
    {
        "signature": "SetLabelMode( <Object>, <Number> )",
        "commandBase": "SetLabelMode",
        "description": "Changes the label mode of the given object, according to the table below.",
        "examples": [
            {
                "description": "SetLabelMode( <Object>, <Number> ): Changes the label mode of the given object, according to the table below.",
                "command": "SetLabelMode( <Object>, <Number> )"
            }
        ],
        "note": "* Integers distinct from the ones listed in table are treated as 0.\n* The default option for the object's label is Name.\n* For options 3 and 9, if the object's Caption box is empty, the Name of the object is used as caption.\n\n[cols=\",\",options=\"header\",]\n|===\n|Number |Mode\n|0 |Name\n|1 |Name + Value\n|2 |Value\n|3 |Caption\n|9 |Caption + Value\n|==="
    },
    {
        "signature": "Min( <List> ) | Min( <Interval> ) | Min( <Number>, <Number> ) | Min( <Function>, <Start x-Value>, <End x-Value> ) | Min( <List of Data>, <List of Frequencies> )",
        "commandBase": "Min",
        "description": "Returns the minimum value from various inputs including lists, intervals, numbers, functions over intervals, or data with frequencies.",
        "examples": [
            {
                "description": "Returns the minimum of the numbers within the list",
                "command": "Min({-2, 12, -23, 17, 15})"
            },
            {
                "description": "Returns the lower bound of the interval",
                "command": "Min(2 < x < 3)"
            },
            {
                "description": "Returns the minimum of the two given numbers",
                "command": "Min(12, 15)"
            },
            {
                "description": "Calculates (numerically) the local minimum point for function in the given interval",
                "command": "Min(exp(x) x3,-4,-2)"
            },
            {
                "description": "Returns the minimum of the list of data with corresponding frequencies",
                "command": "Min({1, 2, 3, 4, 5}, {0, 3, 4, 2, 3})"
            },
            {
                "description": "CAS syntax: gives the minimum over the interval, including endpoints",
                "command": "Min(x2,-1,2)"
            }
        ],
        "note": "If the input consists of non-numeric objects, then this command considers the numbers associated with those objects. Open and closed intervals are not distinguished. For polynomials you should use the Extremum Command. If you want the minimum of two functions f(x) and g(x) then you can define (f(x) + g(x) - abs(f(x) - g(x)))/2. See also Max Command, Extremum Command and Function Inspector Tool."
    },
    {
        "signature": "SetPointStyle( <Point>, <Number> )",
        "commandBase": "SetPointStyle",
        "description": "Changes the point style of given point according to following table (numbers out of range [0,10] will be treated as 0).",
        "examples": [],
        "note": "The command uses a table mapping numbers 0-10 to specific point styles: 0=Full dot, 1=Cross, 2=Empty dot, 3=Plus sign, 4=Full diamond, 5=Empty diamond, 6=Triangle north, 7=Triangle south, 8=Triangle east, 9=Triangle west, 10=Full dot (but with no outline). Numbers outside [0,10] are treated as 0."
    },
    {
        "signature": "InverseLaplace( <Function> ) or InverseLaplace( <Function>, <Variable> )",
        "commandBase": "InverseLaplace",
        "description": "Returns the inverse Laplace transform of the given function.",
        "examples": [
            {
                "description": "Returns the inverse Laplace transform of the given function.",
                "command": "InverseLaplace(1/(1+t2))"
            },
            {
                "description": "Returns the inverse Laplace transform of the function, with respect to the given variable.",
                "command": "InverseLaplace( exp(- a*b),a)"
            },
            {
                "description": "Returns the inverse Laplace transform of the function, with respect to the given variable.",
                "command": "InverseLaplace( exp(- a*b),b)"
            }
        ],
        "note": "See also Laplace command."
    },
    {
        "signature": "LowerSum( <Function>, <Start x-Value>, <End x-Value>, <Number of Rectangles> )",
        "commandBase": "LowerSum",
        "description": "Calculates the lower sum of the given function on the interval [Start x-Value, End x-Value], using n rectangles.",
        "examples": [
            {
                "description": "LowerSum(x2, -2, 4, 6) yields 15.",
                "command": "LowerSum(x2, -2, 4, 6)"
            }
        ],
        "note": "This command draws the rectangles for the lower sum as well. This command is designed as a visual aid so won't give accurate answers if the number of rectangles is too large. See also the commands: UpperSum, LeftSum, RectangleSum, and TrapezoidalSum."
    },
    {
        "signature": "Insert( <Object>, <List>, <Position> )",
        "commandBase": "Insert",
        "description": "Inserts the object in the list at the given position.",
        "examples": [
            {
                "description": "Insert x2 at the third position",
                "command": "Insert(x2, {1, 2, 3, 4, 5}, 3)"
            },
            {
                "description": "Insert x2 at the end of the list using negative position",
                "command": "Insert(x2, {1, 2, 3, 4, 5}, -1)"
            },
            {
                "description": "Insert all elements of the first list at the third position",
                "command": "Insert({11, 12}, {1, 2, 3, 4, 5}, 3)"
            },
            {
                "description": "Insert elements of the first list before the last element using negative position",
                "command": "Insert({11, 12}, {1, 2, 3, 4, 5}, -2)"
            }
        ],
        "note": "If the position is a negative number, then the position is counted from the right."
    },
    {
        "signature": "AreConcyclic( <Point>, <Point>, <Point>, <Point> )",
        "commandBase": "AreConcyclic",
        "description": "Decides if the points are concyclic.",
        "examples": [
            {
                "description": "AreConcyclic((1, 2), (3, 4), (1, 4), (3, 2)) yields true since the points are lying on the same circle.",
                "command": "AreConcyclic((1, 2), (3, 4), (1, 4), (3, 2))"
            }
        ],
        "note": "Normally this command computes the result numerically. This behavior can be changed by using the Prove command. See also AreCollinear, AreConcurrent, AreCongruent, AreEqual, ArePerpendicular, AreParallel, IsTangent commands."
    },
    {
        "signature": "Asymptote( <Conic> ) | Asymptote( <Function> ) | Asymptote( <Implicit Curve> )",
        "commandBase": "Asymptote",
        "description": "Yields asymptotes of conics, functions, or implicit curves. For functions, GeoGebra attempts to find asymptotes and returns them in a list, but may not find all (e.g., vertical asymptotes of non-rational functions like ln(x)). This syntax is not available in the Graphing and Geometry Apps.",
        "examples": [
            {
                "description": "Yields both asymptotes of the conic.",
                "command": "Asymptote(x^2 - y^2/4 = 1)"
            },
            {
                "description": "Returns asymptotes of a rational function in a list.",
                "command": "Asymptote((x^3 - 2x^2 - x + 4) / (2x^2 - 2))"
            },
            {
                "description": "Yields a list containing all the asymptotes of the Implicit Curve.",
                "command": "Asymptote(x^3 + y^3 + y^2 - 3x = 0)"
            }
        ],
        "note": "For functions, GeoGebra may not find all asymptotes (e.g., vertical asymptotes of non-rational functions like ln(x)). This syntax is not available in the Graphing and Geometry Apps."
    },
    {
        "signature": "SetLevelOfDetail( <Surface>, <Level of Detail> )",
        "commandBase": "SetLevelOfDetail",
        "description": "Sets whether a surface is drawn quickly with less details (Level of Detail = 0) or slowly but more accurately (Level of Detail = 1).",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Zipf( <Number of Elements>, <Exponent> [, <Variable Value v>, <Boolean Cumulative>] )",
        "commandBase": "Zipf",
        "description": "Returns a bar graph of a Zipf distribution or calculates probabilities for a Zipf random variable, depending on the parameters provided.",
        "examples": [
            {
                "description": "Returns a bar graph of a Zipf distribution with 10 elements and exponent 1.",
                "command": "Zipf(10, 1)"
            },
            {
                "description": "Returns a bar graph of a Zipf distribution with 10 elements and exponent 1, cumulative set to false.",
                "command": "Zipf(10, 1, false)"
            },
            {
                "description": "Calculates P(X = 5) for a Zipf random variable with 10 elements and exponent 1, cumulative set to false, yielding 0.07 in Algebra View and a fraction in CAS View.",
                "command": "Zipf(10, 1, 5, false)"
            }
        ],
        "note": "The command supports up to four parameters: Number of Elements, Exponent, optional Variable Value v, and optional Boolean Cumulative. The output varies based on the view (Algebra or CAS) and cumulative setting."
    },
    {
        "signature": "OrdinalRank( <List> )",
        "commandBase": "OrdinalRank",
        "description": "Returns a list, whose i-th element is the rank of i-th element of list L (rank of element is its position in Sort(L)). If there are more equal elements in L which occupy positions from k to l in Sort[L], ranks from k to l are associated with these elements.",
        "examples": [
            {
                "description": "OrdinalRank({4, 1, 2, 3, 4, 2}) returns {5, 1, 2, 4, 6, 3}",
                "command": "OrdinalRank({4, 1, 2, 3, 4, 2})"
            },
            {
                "description": "OrdinalRank({3, 2, 2, 1}) returns {4, 2, 3, 1}",
                "command": "OrdinalRank({3, 2, 2, 1})"
            }
        ],
        "note": "Also see command: TiedRank"
    },
    {
        "signature": "SetColor( <Object>, <Red>, <Green>, <Blue> ) | SetColor( <Object>, <\"Color\"> )",
        "commandBase": "SetColor",
        "description": "Changes the color of given object. The red, green and blue represent amount of corresponding color component, 0 being minimum and 1 maximum. Number t exceeding this interval is mapped to it using function stem:[2\\left|\\frac{t}2-\\mathrm round\\left(\\frac{t}2\\right)\\right|]. The color can also be entered as text, that may be: an English color name, an hexadecimal string of the type AARRGGBB or RRGGBB, where AA defines transparency (01 full transparency to FF full opacity), RR defines the red component, GG the green one and BB the blue one.",
        "examples": [
            {
                "description": "Set color using hexadecimal string with transparency",
                "command": "SetColor(text1, \"80FF0000\")"
            }
        ],
        "note": "This command differs among variants of English: SetColor (US), SetColour (UK + Aus). If you use this command in a GeoGebraScript, you must use the English color names. Available color names include: Black, Dark Gray, Gray, Dark Blue, Blue, Dark Green, Green, Maroon, Crimson, Red, Magenta, Indigo, Purple, Brown, Orange, Gold, Lime, Cyan, Turquoise, Light Blue, Aqua, Silver, Light Gray, Pink, Violet, Yellow, Light Yellow, Light Orange, Light Violet, Light Purple, Light Green, White."
    },
    {
        "signature": "HideLayer( <Number> )",
        "commandBase": "HideLayer",
        "description": "Makes all objects in given layer invisible. Does not override Conditional Visibility.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "ZMean2Test( <List of Sample Data 1>, <σ1>, <List of Sample Data 2>, <σ2>, <Tail> ) or ZMean2Test( <Sample Mean 1 >, <σ1>, <Sample Size 1>, <Sample Mean 2 >, <σ2>, <Sample Size 2>, <Tail> )",
        "commandBase": "ZMean2Test",
        "description": "Performs a Z test of the difference between two population means using either lists of sample data and population standard deviations or sample statistics and population standard deviations. Tail determines the alternative hypothesis: '<' for difference < 0, '>' for difference > 0, '≠' for difference ≠ 0. Results are returned as {Probability value, Z test statistic}.",
        "examples": [],
        "note": "Tail values are '<', '>', or '≠', corresponding to specific alternative hypotheses about the difference in population means."
    },
    {
        "signature": "Envelope( <Path>, <Point> )",
        "commandBase": "Envelope",
        "description": "Creates the envelope equation of a set of output paths while the moving point is bound to another object. An envelope is a curve that is tangent to each member of the family of the output paths at some point.",
        "examples": [
            {
                "description": "A ladder is leaning against the wall and sliding down. The contour of its trace will be the envelope of the ladder. Strictly speaking, GeoGebra computes the envelope of the entire line containing the ladder as a segment. Only such envelopes can be computed where the appropriate construction leads to an algebraic equation system.",
                "command": "Envelope( <Path>, <Point> )"
            }
        ],
        "note": "See also Locus, LocusEquation commands and GeoGebra Automated Reasoning Tools: A Tutorial (https://github.com/kovzol/gg-art-doc/tree/master/pdf/english.pdf)."
    },
    {
        "signature": "First( <List> ) | First( <List>, <Number n of elements> ) | First( <Text> ) | First( <Text>, <Number n of elements> ) | First( <Locus>, <Number n of elements> )",
        "commandBase": "First",
        "description": "Gives a new list that contains the first element(s) of the given list, text, or locus, optionally specifying the number of elements to extract.",
        "examples": [
            {
                "description": "Get the first element of a list",
                "command": "First({1, 4, 3})"
            },
            {
                "description": "Get the first n elements of a list",
                "command": "First({1, 4, 3}, 2)"
            },
            {
                "description": "Get the first character of text",
                "command": "First(\"Hello\")"
            },
            {
                "description": "Get the first n characters of text",
                "command": "First(\"Hello\", 2)"
            }
        ],
        "note": "For loci generated by commands like NSolveODE, ShortestDistance, TravelingSalesman, Voronoi, MinimumSpanningTree, and ConvexHull, First returns vertices or points from the first n steps. See also Last Command."
    },
    {
        "signature": "Mode( <List of Numbers> )",
        "commandBase": "Mode",
        "description": "Determines the mode(s) of the list elements.",
        "examples": [
            {
                "description": "Mode({1, 2, 3, 4}) returns an empty list {}.",
                "command": "Mode({1, 2, 3, 4})"
            },
            {
                "description": "Mode({1, 1, 1, 2, 3, 4}) returns the list {1} .",
                "command": "Mode({1, 1, 1, 2, 3, 4})"
            },
            {
                "description": "Mode({1, 1, 2, 2, 3, 3, 4}) returns the list {1, 2, 3}.",
                "command": "Mode({1, 1, 2, 2, 3, 3, 4})"
            }
        ],
        "note": ""
    },
    {
        "signature": "Button( <Caption> )",
        "commandBase": "Button",
        "description": "Creates a new button with given caption.",
        "examples": [
            {
                "description": "Button(\"Ok\") creates a button in the left upper corner of the Graphics View with the caption Ok.",
                "command": "Button(\"Ok\")"
            }
        ],
        "note": "Button( ) creates a new button without a caption."
    },
    {
        "signature": "Spearman( <List of Points> ) or Spearman( <List of Numbers>, <List of Numbers> )",
        "commandBase": "Spearman",
        "description": "Returns Spearman's rank correlation coefficient of x-coordinates and y-coordinates of points of a list, or of two lists of numbers.",
        "examples": [
            {
                "description": "Calculate Spearman's rank correlation for a list of points",
                "command": "Spearman({(-3, 4), (-1, 4), (-2, 3), (1, 3), (2, 2), (1, 5)})"
            },
            {
                "description": "Calculate Spearman's rank correlation for two lists of numbers",
                "command": "Spearman({3, 2, 4, 5, 1, 6, 8, 9}, {5, 6, 8, 2, 1, 3, 4, 7})"
            }
        ],
        "note": "The command has two signatures: one for a list of points (where x and y coordinates are extracted) and one for two separate lists of numbers. Returns a correlation coefficient value."
    },
    {
        "signature": "AttachCopyToView( <Object>, <View 0|1|2> ) or AttachCopyToView( <Object>, <View 0|1|2>, <Point 1>, <Point 2>, <Screen Point 1>, <Screen Point 2> )",
        "commandBase": "AttachCopyToView",
        "description": "Creates a copy of an object attached to a specific view, with optional affine transformation mapping points to screen coordinates.",
        "examples": [
            {
                "description": "Create a dependent copy with constant size in Graphics View 1",
                "command": "AttachCopyToView(poly, 1)"
            },
            {
                "description": "Create a 100px x 100px square in top left corner using affine transformation",
                "command": "AttachCopyToView(poly, 1, (0, 0), (1, 1), (0, 0), (100, 100))"
            }
        ],
        "note": "For View = 0, creates a simple copy; for View = 1 or 2, creates a dependent copy with size constant in that Graphics View. Once created, four additional arguments can be added for affine transformation mapping. All object points are copied, even outside the view."
    },
    {
        "signature": "BarChart( <List of Data>, <List of Frequencies> ) | BarChart( <List of Raw Data>, <Width of Bars>, <Vertical Scale Factor (optional)> ) | BarChart( <List of Data>, <List of Frequencies>, <Width of Bars> ) | BarChart( <Start Value>, <End Value>, <List of Heights> ) | BarChart( <Start Value>, <End Value>, <Expression>, <Variable>, <From Number>, <To Number> ) | BarChart( <Start Value>, <End Value>, <Expression>, <Variable>, <From Number>, <To Number>, <Step Width> )",
        "commandBase": "BarChart",
        "description": "Creates a bar chart using various parameter combinations to specify data, frequencies, intervals, and bar properties.",
        "examples": [
            {
                "description": "Creates a bar chart using the list of data with corresponding frequencies",
                "command": "BarChart({10, 11, 12, 13, 14}, {5, 8, 12, 0, 1})"
            },
            {
                "description": "Creates a bar chart using the list of data with corresponding frequencies",
                "command": "BarChart({5, 6, 7, 8, 9}, {1, 0, 12, 43, 3})"
            },
            {
                "description": "Creates a bar chart using the list of data with corresponding frequencies",
                "command": "BarChart({0.3, 0.4, 0.5, 0.6}, {12, 33, 13, 4})"
            },
            {
                "description": "Creates a bar chart using the given raw data; the bars have the given width and the height of the bars depends on the vertical scale factor",
                "command": "BarChart({1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 5, 5, 5, 5}, 1)"
            },
            {
                "description": "Creates a bar chart using the given raw data; the bars have the given width and the height of the bars depends on the vertical scale factor",
                "command": "BarChart({1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 5, 5, 5, 5}, 1, 2)"
            },
            {
                "description": "Creates a bar chart using the list of data and corresponding frequencies. Bars' width is given",
                "command": "BarChart({10, 11, 12, 13, 14}, {5, 8, 12, 0, 1}, 0.5)"
            },
            {
                "description": "Creates a bar chart using the list of data and corresponding frequencies. Bars' width is given",
                "command": "BarChart({10, 11, 12, 13, 14}, {5, 8, 12, 0, 1}, 0)"
            },
            {
                "description": "Creates a bar chart over the given interval: the number of bars is determined by the length of the list, whose elements are the heights of the bars",
                "command": "BarChart(10, 20, {1, 2, 3, 4, 5})"
            },
            {
                "description": "Creates a bar chart over the interval [Start Value, End Value], that calculates the bars’ heights using the expression of the given Variable in the interval [From number, To number]",
                "command": "BarChart(-0.5, n + 0.5, BinomialCoefficient(n,k) * p^k * q^(n-k), k, 0, n)"
            },
            {
                "description": "Creates a bar chart over the interval [Start Value, End Value], that calculates the bars’ heights using the expression of the given Variable in the interval [From number, To number] with given Step width",
                "command": "BarChart( <Start Value>, <End Value>, <Expression>, <Variable>, <From Number>, <To Number>, <Step Width> )"
            }
        ],
        "note": "The numbers in the list of raw data need to be arranged in increasing order. It is possible to specify a different color/filling for each bar in the Object Properties."
    },
    {
        "signature": "ReducedRowEchelonForm( <Matrix> )",
        "commandBase": "ReducedRowEchelonForm",
        "description": "Returns the reduced echelon form (https://en.wikipedia.org/wiki/Row_echelon_form) of the matrix.",
        "examples": [
            {
                "description": "ReducedRowEchelonForm({{1, 6, 4}, {2, 8, 9}, {4, 5, 6}}) yields the matrix stem:[ \\begin{pmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \\end{pmatrix}].",
                "command": "ReducedRowEchelonForm({{1, 6, 4}, {2, 8, 9}, {4, 5, 6}})"
            },
            {
                "description": "ReducedRowEchelonForm({{2, 10, 11, 4}, {2, (-5), (-6), 12}, {2, 5, 3, 2}}) yields the matrix stem:[ \\begin{pmatrix} 1 & 0 & 0 & 5\\\\ 0 & 1 & 0 & -2.8\\\\ 0 & 0 & 1 & 2\\end{pmatrix}].",
                "command": "ReducedRowEchelonForm({{2, 10, 11, 4}, {2, (-5), (-6), 12}, {2, 5, 3, 2}})"
            },
            {
                "description": "ReducedRowEchelonForm({{2, 10, 11, 4}, {2, (-5), (-6), 12}, {2, 5, 3, 2}}) yields the matrix stem:[ \\begin{pmatrix} 1 & 0 & 0 & 5\\\\ 0 & 1 & 0 & \\frac{-14}{5} \\\\ 0 & 0 & 1 & 2\\end{pmatrix}].",
                "command": "ReducedRowEchelonForm({{2, 10, 11, 4}, {2, (-5), (-6), 12}, {2, 5, 3, 2}})"
            }
        ],
        "note": "CAS Syntax: ReducedRowEchelonForm( <Matrix> )"
    },
    {
        "signature": "TrigSimplify( <Expression> )",
        "commandBase": "TrigSimplify",
        "description": "Simplifies the given trigonometric expression.",
        "examples": [
            {
                "description": "Simplify 1 - sin(x)²",
                "command": "TrigSimplify(1 - sin(x)2)"
            },
            {
                "description": "Simplify sin(x)² - cos(x)² + 1",
                "command": "TrigSimplify(sin(x)2 - cos(x)2 + 1)"
            }
        ],
        "note": "This command works only for variables \"x\", \"y\" and \"z\" in the Algebra View, but works for all variables in the CAS View. See also TrigExpand Command and TrigCombine Command."
    },
    {
        "signature": "Divisors( <Number> )",
        "commandBase": "Divisors",
        "description": "Calculates the number of all the positive divisors, including the number itself.",
        "examples": [
            {
                "description": "Divisors(15) yields 4, the number of all positive divisors of 15, including 15.",
                "command": "Divisors(15)"
            }
        ],
        "note": "See also DivisorsList Command and DivisorsSum Command."
    },
    {
        "signature": "SetBackgroundColor( <Object>, <Red>, <Green>, <Blue> ) | SetBackgroundColor( <Object>, <\"Color\"> ) | SetBackgroundColor( <Red>, <Green>, <Blue> ) | SetBackgroundColor( <\"Color\"> )",
        "commandBase": "SetBackgroundColor",
        "description": "Changes the background color of given object or active Graphics View. Used for Texts and objects in Spreadsheet. Color can be specified via RGB values (0-1) or color names/hex codes.",
        "examples": [
            {
                "description": "Set background color using RGB values for an object",
                "command": "SetBackgroundColor(text1, 1, 0, 0)"
            },
            {
                "description": "Set background color using hex code with transparency",
                "command": "SetBackgroundColor(text1, \"80FF0000\")"
            },
            {
                "description": "Set background color of active Graphics View using RGB",
                "command": "SetBackgroundColor(0.5, 0.5, 0.5)"
            },
            {
                "description": "Set background color using color name",
                "command": "SetBackgroundColor(\"Blue\")"
            }
        ],
        "note": "Command spelling varies: SetBackgroundColor (US), SetBackgroundColour (UK/Aus). In GeoGebraScript, must use English color names. RGB values outside 0-1 are mapped via formula: 2*|t/2 - round(t/2)|. Color names include: Black, Blue, Red, Green, Yellow, White, etc."
    },
    {
        "signature": "ParseToFunction( <Text> ) | ParseToFunction( <Function>, <Text> ) | ParseToFunction( <Text>, <List of variables> )",
        "commandBase": "ParseToFunction",
        "description": "Parses the text containing the function definition and creates the corresponding function.",
        "examples": [
            {
                "description": "ParseToFunction(\"x2\") creates the function _f_(_x_) = x2_._",
                "command": "ParseToFunction(\"x2\")"
            },
            {
                "description": "ParseToFunction(\"t+2/t\") creates the function _f_(_t_) = t + 2/_t_.",
                "command": "ParseToFunction(\"t+2/t\")"
            },
            {
                "description": "Define f(x) = 3x² + 2 and text1 = \"f(x) = 3x + 1\". ParseToFunction(f, text1) returns f(x) = 3x +1.",
                "command": "ParseToFunction(f, text1)"
            },
            {
                "description": "ParseToFunction(\"2u+3v\",{\"u\", \"v\"}) creates the function a(u,v) = 2u + 3v.",
                "command": "ParseToFunction(\"2u+3v\",{\"u\", \"v\"})"
            }
        ],
        "note": "See also ParseToNumber command."
    },
    {
        "signature": "Eccentricity( <Conic> )",
        "commandBase": "Eccentricity",
        "description": "Calculates the eccentricity of the conic section.",
        "examples": [
            {
                "description": "Eccentricity(x2/9 + y2/4 = 1) returns a = 0.75",
                "command": "Eccentricity(x2/9 + y2/4 = 1)"
            }
        ],
        "note": ""
    },
    {
        "signature": "Difference( <Polygon>, <Polygon> )",
        "commandBase": "Difference",
        "description": "Finds the difference of the two polygons.",
        "examples": [
            {
                "description": "Finds the difference of the two polygons.",
                "command": "Difference( <Polygon>, <Polygon> )"
            }
        ],
        "note": "Works only for where the polygons are not self-intersecting, and where the resulting pieces don't have holes."
    },
    {
        "signature": "ANOVA( <List>, <List>, ...):",
        "commandBase": "ANOVA",
        "description": "Performs a one-way ANOVA test on the given lists of numbers. Results are returned in list form as {P value, F test statistic}.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "MixedNumber( <Number> )",
        "commandBase": "MixedNumber",
        "description": "Converts the given number to a mixed number.",
        "examples": [
            {
                "description": "MixedNumber(3.5) yields stem:[3 + \\frac{1}{2}].",
                "command": "MixedNumber(3.5)"
            },
            {
                "description": "MixedNumber(12 / 3) yields 4.",
                "command": "MixedNumber(12 / 3)"
            },
            {
                "description": "MixedNumber(12 / 14) yields stem:[\\frac{6}{7}].",
                "command": "MixedNumber(12 / 14)"
            }
        ],
        "note": "See also Rationalize Command."
    },
    {
        "signature": "LineGraph (<List of x-coordinates>, <List of y-coordinates>)",
        "commandBase": "LineGraph",
        "description": "Creates a chart, connecting with line segments the points whose coordinates are defined in the lists, to visualize given data. <List of x-coordinates> is a list containing the x values, defined as numbers in increasing order, <List of y-coordinates> is a list containing the y values, defined as numbers.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Mod( <Dividend Number>, <Divisor Number> ) or Mod( <Dividend Polynomial>, <Divisor Polynomial> )",
        "commandBase": "Mod",
        "description": "Yields the remainder when dividend number is divided by divisor number, or yields the remainder when the dividend polynomial is divided by the divisor polynomial.",
        "examples": [
            {
                "description": "Mod with numbers yields remainder",
                "command": "Mod(9, 4)"
            },
            {
                "description": "Mod with polynomials yields polynomial remainder",
                "command": "Mod(x3 + x2 + x + 6, x2 - 3)"
            }
        ],
        "note": "If you want a function to do this, you can define it yourself, e.g. mod(x, y) = y (x / y - floor(x / y))."
    },
    {
        "signature": "ToolImage( <Number> ), ToolImage( <Number>, <Point> ), ToolImage( <Number>, <Point>, <Point> )",
        "commandBase": "ToolImage",
        "description": "Creates in the Graphics View a 32x32 pixel image of the tool icon with given number, optionally anchored to a point or defined by two points for an oriented square.",
        "examples": [
            {
                "description": "Creates in the Graphics View a 32x32 pixel image of the tool icon with given number.",
                "command": "ToolImage( <Number> )"
            },
            {
                "description": "Creates in the Graphics view a 32x32 pixel image of the tool icon, anchored to the given point.",
                "command": "ToolImage( <Number>, <Point> )"
            },
            {
                "description": "Creates in the Graphics view an image of the tool icon. The two given points define two adjacent vertices of the side of the oriented square containing the image.",
                "command": "ToolImage( <Number>, <Point>, <Point> )"
            }
        ],
        "note": "See Toolbar reference page for the icons numbering, or ToolsEN."
    },
    {
        "signature": "MajorAxis( <Conic> )",
        "commandBase": "MajorAxis",
        "description": "Returns the equation of the major axis of the conic section.",
        "examples": [
            {
                "description": "MajorAxis(x2 / 9 + y2 / 4 = 1) returns y = 0.",
                "command": "MajorAxis(x2 / 9 + y2 / 4 = 1)"
            }
        ],
        "note": "See also MinorAxis command."
    },
    {
        "signature": "CASLoaded()",
        "commandBase": "CASLoaded",
        "description": "Returns a boolean value: true if CAS commands were already loaded, false otherwise. The value is dynamic (changes to true when CAS commands are loaded).",
        "examples": [
            {
                "description": "This commands is useful in the web version of GeoGebra where CAS commands are loaded with a delay after the app is started. You can use this command together with Conditional Visibility to hide some construction elements while CAS is loading.",
                "command": "CASLoaded()"
            }
        ],
        "note": "The value is dynamic (changes to true when CAS commands are loaded)."
    },
    {
        "signature": "Bottom( <Quadric> )",
        "commandBase": "Bottom",
        "description": "Creates the bottom of the limited quadric.",
        "examples": [
            {
                "description": "Bottom(cylinder) yields a circle.",
                "command": "Bottom(cylinder)"
            }
        ],
        "note": "See also Top Command, Ends Command and Side Command."
    },
    {
        "signature": "ToBase( <Number>, <Base> )",
        "commandBase": "ToBase",
        "description": "Converts given number into different base (https://en.wikipedia.org/wiki/Radix). The base must be between 2 and 36. The number must be an integer.",
        "examples": [
            {
                "description": "ToBase(255,16) returns \"FF\".",
                "command": "ToBase(255,16)"
            },
            {
                "description": "ToBase(256, 2) returns \"100000000\".",
                "command": "ToBase(256, 2)"
            }
        ],
        "note": "See also FromBase command."
    },
    {
        "signature": "FillRow( <Row>, <List> )",
        "commandBase": "FillRow",
        "description": "Copies values from the list to the first cells of the row given by number. Resulting cells are free objects, i.e. independent of the list.",
        "examples": [],
        "note": "See also the FillColumn and FillCells commands."
    },
    {
        "signature": "AreParallel( <Line>, <Line> )",
        "commandBase": "AreParallel",
        "description": "Decides if the lines are parallel. Normally this command computes the result numerically. This behavior can be changed by using the Prove command.",
        "examples": [
            {
                "description": "AreParallel(Line[(1, 2), (3, 4)), Line((5, 6),(7,8))) yields true since the given lines are parallel.",
                "command": "AreParallel(Line[(1, 2), (3, 4)), Line((5, 6),(7,8)))"
            }
        ],
        "note": "See also AreCollinear, AreConcurrent, AreCongruent, AreConcyclic, AreEqual, ArePerpendicular, IsTangent commands."
    },
    {
        "signature": "Sxx( <List of Numbers> )",
        "commandBase": "Sxx",
        "description": "Calculates the statistic ∑x² - (∑x)²/n.",
        "examples": [],
        "note": "Also supports Sxx( <List of Points> ) to calculate the statistic using the x-coordinates of the given points."
    },
    {
        "signature": "ParseToNumber( <Number>, <Text> ): Parses the text and stores the result to a number a, which must be defined and free before the command is used. ParseToNumber( <Text> ): Parses the text and stores the result to a number.",
        "commandBase": "ParseToNumber",
        "description": "Parses the text and stores the result to a number.",
        "examples": [
            {
                "description": "Define a = 3 and text1 = \"6\". ParseToNumber(a, text1) returns a = 6.",
                "command": "ParseToNumber(a, text1)"
            },
            {
                "description": "ParseToNumber(\"1+2+5-pi\") creates the number a = 4.86.",
                "command": "ParseToNumber(\"1+2+5-pi\")"
            }
        ],
        "note": "This is a scripting command which only sets the value of a number once. To convert a text text1 into a number which is updated dynamically, use FromBase(text1,10). See also ParseToFunction command."
    },
    {
        "signature": "Locus( <Point Creating Locus Line Q>, <Point P>): Returns the locus curve of the point Q, which depends on the point P.",
        "commandBase": "Locus",
        "description": "Returns the locus curve of the point Q, which depends on the point P.",
        "examples": [
            {
                "description": "Point P needs to be a point on an object (e.g., line, segment, circle).",
                "command": "Locus( <Point Creating Locus Line Q>, <Point P>)"
            },
            {
                "description": "Returns the locus curve of the point Q, which depends on the values assumed by the slider t.",
                "command": "Locus( <Point Creating Locus Line Q>, <Slider t>)"
            },
            {
                "description": "Returns the locus curve which equates to the slopefield at the given point.",
                "command": "Locus( <Slopefield>, <Point> )"
            },
            {
                "description": "Returns the locus curve which equates to the solution of the differential equation dy/dx = f(x,y) in the given point, calculated numerically.",
                "command": "Locus( <f(x, y)>, <Point> )"
            }
        ],
        "note": "Loci are specific object types, appearing as auxiliary objects. Besides the Locus command, they result from some Discrete Math Commands and SolveODE Command. Loci are paths and can be used within path-related commands such as Point. Their properties depend on how they were obtained, see e.g., Perimeter Command and First Command. See also Locus tool. Warning: A locus is undefined when the dependent point is the result of a Point Command with two parameters, or a PathParameter Command."
    },
    {
        "signature": "ClosestPointRegion( <Region>, <Point> )",
        "commandBase": "ClosestPointRegion",
        "description": "Returns a new point on the region which is the closest to a selected point.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Triangular( <Lower Bound>, <Upper Bound>, <Mode>, <Variable Value> )",
        "commandBase": "Triangular",
        "description": "Evaluates the cumulative distribution function of a triangular distribution at variable value v, i.e. calculates the probability P(X ≤ v) where X is a random variable with a triangular distribution in [_lower bound_, _upper bound_] with the given mode.",
        "examples": [
            {
                "description": "Triangular distribution evaluation example",
                "command": "Triangular(0, 5, 2, 2)"
            }
        ],
        "note": "This syntax returns the probability at a given value, that is the area under the triangular distribution curve to the left of the given _x_-coordinate. Additional syntax variations exist: Triangular( <Lower Bound>, <Upper Bound>, <Mode>, <Variable Value>, <Boolean Cumulative> ) evaluates either the cumulative distribution function (if Cumulative = true) or probability density function (if Cumulative = false) of a triangular distribution at the given variable value. Triangular( <Lower Bound>, <Upper Bound>, <Mode>, x, <Boolean Cumulative> ) creates either the cumulative distribution function or probability density function of a triangular distribution with given mode in [_lower bound_, _upper bound_]."
    },
    {
        "signature": "Focus( <Conic> )",
        "commandBase": "Focus",
        "description": "Yields (all) foci of the conic section.",
        "examples": [
            {
                "description": "Focus(4x2 - y2 + 16x + 20 = 0) returns the two foci of the given hyperbola: A=(-2, -2.24) and B=(-2, 2.24).",
                "command": "Focus(4x2 - y2 + 16x + 20 = 0)"
            }
        ],
        "note": "See also the Directrix command."
    },
    {
        "signature": "VerticalText( <Text> )",
        "commandBase": "VerticalText",
        "description": "Creates a LaTeX text, containing the given text rotated 90° counter-clockwise.",
        "examples": [
            {
                "description": "The text needs to be enclosed in double quotes \". The text is rotated such that the top left corner (also known as Corner 4) of the box containing it is placed at the origin of the coordinate system.",
                "command": "VerticalText(\"a = 5\")"
            }
        ],
        "note": "VerticalText(\"a = 5\") creates the LaTeX text \"_a_ = 5\" displayed vertically, with its top left corner at (0,0)"
    },
    {
        "signature": "SetLineThickness( <Object>, <Number> )",
        "commandBase": "SetLineThickness",
        "description": "Sets the line thickness for the given object to stem:[\\frac{N}2] pixels, where N is the given number.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Minimize( <Dependent number>, <Free number> )\nMinimize( <Dependent Number>, <Point on Path> )",
        "commandBase": "Minimize",
        "description": "Calculates the free number which gives the minimal value of the dependent number. The free number must be a slider and the slider interval will be used as the search interval. The relationship should be continuous and have only one local minimum in the interval. If the construction is complicated, this command might return ? to avoid using too much processor time. Alternatively, calculates the position of the point which gives the minimal value of the dependent number. The point must be a point on a path and the path will be used as the search interval. The relationship should be continuous and have only one local minimum point in the interval.",
        "examples": [
            {
                "description": "Let a be a slider in [0,10] and t1 the right triangle with vertices C = (_a_, 0), A = (0, 0) and B = (0,10 - _a_). Minimize(t1, a) gives 0, the value of a that minimizes the area of t1 (when the triangle degenerates into a segment).",
                "command": "Minimize(t1, a)"
            },
            {
                "description": "Let c be a circle, C a point on it and D a point outside the circle. If f = Segment(C,D) then Minimize(f,C) creates the point on c having minimum distance from D.",
                "command": "Minimize(f, C)"
            }
        ],
        "note": "This command differs among variants of English: Minimize (US), Minimise (UK + Aus). See also Maximize command."
    },
    {
        "signature": "TriangleCurve( <Point P>, <Point Q>, <Point R>, <Equation in A, B, C> )",
        "commandBase": "TriangleCurve",
        "description": "Creates implicit polynomial, whose equation in barycentric coordinates (https://en.wikipedia.org/wiki/Barycentric_coordinate_system_(mathematics)) with respect to points P, Q, R is given by the fourth parameter; the barycentric coordinates are referred to as A, B, C.",
        "examples": [
            {
                "description": "If P, Q, R are points, TriangleCurve(P, Q, R, (A - B)*(B - C)*(C - A) = 0) gives a cubic curve consisting of the medians of the triangle PQR.",
                "command": "TriangleCurve(P, Q, R, (A - B)*(B - C)*(C - A) = 0)"
            },
            {
                "description": "TriangleCurve(A, B, C, A*C = 1/8) creates a hyperbola such that tangent, through A or C, to this hyperbola splits triangle ABC in two parts of equal area.",
                "command": "TriangleCurve(A, B, C, A*C = 1/8)"
            },
            {
                "description": "TriangleCurve(A, B, C, A² + B² + C² - 2B C - 2C A - 2A B = 0) creates the Steiner inellipse (https://en.wikipedia.org/wiki/Steiner_inellipse) of the triangle ABC, and TriangleCurve(A, B, C, B C + C A + A B = 0) creates the Steiner circumellipse (https://en.wikipedia.org/wiki/Steiner_ellipse) of the triangle ABC.",
                "command": "TriangleCurve(A, B, C, A² + B² + C² - 2B C - 2C A - 2A B = 0) and TriangleCurve(A, B, C, B C + C A + A B = 0)"
            }
        ],
        "note": "The input points can be called A, B or C, but in this case you cannot use e.g. x(A) in the equation, because A is interpreted as the barycentric coordinate."
    },
    {
        "signature": "IsFactored( <Polynomial> )",
        "commandBase": "IsFactored",
        "description": "Returns 'true' if the polynomial is factored in ℚ and 'false' otherwise. In general, in order to consider a polynomial decomposition as factored, the coefficient of the leading term of each factor needs to be positive.",
        "examples": [
            {
                "description": "IsFactored(x) yields true",
                "command": "IsFactored(x)"
            },
            {
                "description": "IsFactored(0.5) yields true",
                "command": "IsFactored(0.5)"
            },
            {
                "description": "IsFactored(5) yields true",
                "command": "IsFactored(5)"
            },
            {
                "description": "IsFactored(x²-1) yields false",
                "command": "IsFactored(x²-1)"
            },
            {
                "description": "IsFactored(x²-2) yields true",
                "command": "IsFactored(x²-2)"
            },
            {
                "description": "IsFactored(x(x+1)) yields true",
                "command": "IsFactored(x(x+1))"
            },
            {
                "description": "IsFactored(x(2x+2)) yields false",
                "command": "IsFactored(x(2x+2))"
            },
            {
                "description": "IsFactored(x³-1) yields false",
                "command": "IsFactored(x³-1)"
            },
            {
                "description": "IsFactored(x(x/2+1/2)) yields false",
                "command": "IsFactored(x(x/2+1/2))"
            },
            {
                "description": "IsFactored((x+1)(x²-1)) yields false",
                "command": "IsFactored((x+1)(x²-1))"
            },
            {
                "description": "IsFactored(-2x-2) yields false",
                "command": "IsFactored(-2x-2)"
            },
            {
                "description": "IsFactored(2x+2) yields false",
                "command": "IsFactored(2x+2)"
            }
        ],
        "note": "This command differs among variants of English: IsFactored (US), IsFactorised (UK + Aus)."
    },
    {
        "signature": "MAD( <List of Numbers> ) or MAD( <List of Numbers>, <List of Frequencies> )",
        "commandBase": "MAD",
        "description": "Calculates the Mean Absolute Deviation (https://en.wikipedia.org/wiki/Average_absolute_deviation) of the numbers in the list. For two arguments, calculates the weighted mean absolute deviation.",
        "examples": [
            {
                "description": "Calculates the Mean Absolute Deviation of the numbers in the list",
                "command": "MAD({1, 2, 3, 4, 5})"
            },
            {
                "description": "Calculates the weighted mean absolute deviation of the given numbers",
                "command": "MAD({20, 40, 41, 42, 40, 54}, {20, 6, 4, 5, 2})"
            }
        ],
        "note": "See also SD Command."
    },
    {
        "signature": "DotPlot( <List of Raw Data>, <Stack Adjacent Dots (optional)>, <Scale Factor (optional)> )",
        "commandBase": "DotPlot",
        "description": "Returns a dot plot for the given list of data, as well as the list of the dot plot points. If a data n appears in the list of raw data k times, the returned list contains points (n, 1), (n, 2),..., (n, k). If you choose a Scale Factor s, the returned list contains points (n, 1s), (n, 2s), ..., (n, ks). Stack Adjacent Dots means a Boolean Value (true or false): If you choose true, points (which are close to each other) are stacked. If you choose false, the result will be the same as without <Stack Adjacent Dots (optional)>. The command DotPlot will also work with a list of text.",
        "examples": [
            {
                "description": "DotPlot with a list of numbers",
                "command": "DotPlot({2, 5, 3, 4, 3, 5, 3})"
            },
            {
                "description": "DotPlot with a list of text",
                "command": "DotPlot({\"Red\", \"Red\", \"Red\", \"Blue\", \"Blue\"})"
            }
        ],
        "note": "If you use a list of text the DotPlot command will put the result in alphabetical order. (e.g. Blue appears two times, Red three times and B comes before R in the alphabet, so you get (1, 1), (1, 2) for Blue and (2, 1), (2, 2), (2, 3) for Red.)"
    },
    {
        "signature": "InverseLogistic( <Mean>, <Scale>, <Probability> )",
        "commandBase": "InverseLogistic",
        "description": "Computes the inverse of the cumulative distribution function of a Logistic distribution (https://en.wikipedia.org/wiki/Logistic_distribution) at probability p, where the Logistic distribution is defined by the given parameters mean and scale. In other words, it finds t such that P(X ≤ t) = p, where X is a Logistic random variable. Probability p must be a value in the closed interval [0,1].",
        "examples": [
            {
                "description": "InverseLogistic(100, 2, 1) yields stem:[ \\infty ].",
                "command": "InverseLogistic(100, 2, 1)"
            }
        ],
        "note": ""
    },
    {
        "signature": "JordanDiagonalization Command",
        "commandBase": "JordanDiagonalization",
        "description": "",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Object( <Name of Object as Text> )",
        "commandBase": "Object",
        "description": "Returns the object for a given name. The result is always a dependent object.",
        "examples": [
            {
                "description": "If points A1, A2, ... , A20 exist and also a slider n = 2, then Object(\"A\" + n) creates a copy of point A2.",
                "command": "Object(\"A\" + n)"
            }
        ],
        "note": "This command is deprecated - use in new files is unsupported. The Object command is the opposite of the Name command. Object command cannot be used in Custom Tools. Make sure that the objects you refer to are earlier in the Construction Protocol than this command."
    },
    {
        "signature": "ProveDetails( <Boolean Expression> )",
        "commandBase": "ProveDetails",
        "description": "Returns some details of the result of the automated proof. Normally, GeoGebra decides whether a boolean expression is true or not by using numerical computations. However, the ProveDetails command uses symbolic methods to determine whether a statement is true or false in general. This command works like the Prove command, but also returns some details of the result as a list: • An empty list {} if GeoGebra cannot determine the answer. • A list with one element: {false}, if the statement is not true in general. • A list with one element: {true}, if the statement is always true (in all cases when the diagram can be constructed). • A list with more elements, containing the boolean value true and another list for some so-called non-degeneracy conditions, if the statement is true under certain conditions, e.g. {true, {\"AreCollinear(A,B,C),AreEqual(C,D)\"}}. This means that if none of the conditions are true (and the diagram can be constructed), then the statement will be true. • A list {true,{\"...\"}}, if the statement is true under certain conditions, but these conditions cannot be translated to human readable form for some reasons.",
        "examples": [
            {
                "description": "Let us define a triangle with vertices A, B and C, and define D=MidPoint(B,C), E=MidPoint(A,C), p=Line(A,B), q=Line(D,E). Now ProveDetails(p∥q) returns {true}, which means that if the diagram can be constructed, then the midline DE of the triangle is parallel to the side AB.",
                "command": "ProveDetails(p∥q)"
            },
            {
                "description": "Let AB be the segment a, and define C=MidPoint(A,B), b=PerpendicularBisector(A,B), D=Intersect(a,b). Now ProveDetails(C==D) returns {true,{\"AreEqual(A,B)\"}}: it means that if the points A and B differ, then the points C and D will coincide.",
                "command": "ProveDetails(C==D)"
            },
            {
                "description": "Let AB be the segment a, and define l=Line(A,B). Let C be an arbitrary point on line l, moreover let b=Segment(B,C), c=Segment(A,C). Now ProveDetails(a==b+c) returns {true,{\"a+b==c\", \"b==a+c\"}}: it means that if neither a+b=c, nor b=a+c, then a=b+c. It is possible that the list of the non-degeneracy conditions is not the simplest possible set. For the above example, the simplest set would be the empty set.",
                "command": "ProveDetails(a==b+c)"
            }
        ],
        "note": "See also Prove command, Boolean values, GeoGebra Automated Reasoning Tools: A Tutorial (https://github.com/kovzol/gg-art-doc/tree/master/pdf/english.pdf) and technical details of the algorithms (http://dev.geogebra.org/trac/wiki/TheoremProving)."
    },
    {
        "signature": "PartialFractions( <Function> ) or PartialFractions( <Function>, <Variable> )",
        "commandBase": "PartialFractions",
        "description": "Yields, if possible, the partial fraction of the given function for the main function variable or a specified variable, with the graph plotted in the Graphics View.",
        "examples": [
            {
                "description": "Compute partial fractions for a function with the main variable",
                "command": "PartialFractions(x^2 / (x^2 - 2x + 1))"
            },
            {
                "description": "Compute partial fractions for a function with a specified variable",
                "command": "PartialFractions(a^2 / (a^2 - 2a + 1), a)"
            }
        ],
        "note": "In the CAS View, you can use the syntax with an optional variable parameter for more control."
    },
    {
        "signature": "FrequencyPolygon( <List of Class Boundaries>, <List of Heights> ) | FrequencyPolygon( <List of Class Boundaries>, <List of Raw Data>, <Boolean Use Density>, <Density Scale Factor (optional)> ) | FrequencyPolygon( <Boolean Cumulative>, <List of Class Boundaries>, <List of Raw Data>, <Boolean Use Density>, <Density Scale Factor (optional)> )",
        "commandBase": "FrequencyPolygon",
        "description": "Creates a frequency polygon, a line graph drawn by joining midpoints of histogram bars or based on class boundaries and heights/raw data, with options for density and cumulative calculations.",
        "examples": [
            {
                "description": "Creates a frequency polygon with vertices in given heights using class boundaries.",
                "command": "FrequencyPolygon({0, 1, 2, 3, 4, 5}, {2, 6, 8, 3, 1})"
            },
            {
                "description": "Creates a frequency polygon using raw data, with default density settings (Use Density = true, Density Scale Factor = 1).",
                "command": "FrequencyPolygon( <List of Class Boundaries>, <List of Raw Data>, <Boolean Use Density>, <Density Scale Factor (optional)> )"
            },
            {
                "description": "Creates a cumulative frequency polygon if Cumulative is true, based on raw data and optional density settings.",
                "command": "FrequencyPolygon( <Boolean Cumulative>, <List of Class Boundaries>, <List of Raw Data>, <Boolean Use Density>, <Density Scale Factor (optional)> )"
            }
        ],
        "note": "Frequency polygon usage is similar to Histogram Command; for further examples, refer to Histogram Command."
    },
    {
        "signature": "StartRecord( [<Boolean>] )",
        "commandBase": "StartRecord",
        "description": "Resumes all recording to spreadsheet if paused (and stores a value for each object). When the boolean is false, pauses all recording to the spreadsheet, otherwise resumes it (and stores a value for each object).",
        "examples": [
            {
                "description": "Resumes all recording to spreadsheet if paused (and stores a value for each object)",
                "command": "StartRecord( )"
            },
            {
                "description": "When the boolean is false, pauses all recording to the spreadsheet, otherwise resumes it (and stores a value for each object)",
                "command": "StartRecord( <Boolean> )"
            }
        ],
        "note": "This command controls recording to a spreadsheet, with optional boolean parameter to pause or resume."
    },
    {
        "signature": "TDistribution( <Degrees of Freedom>, <Variable Value> )",
        "commandBase": "TDistribution",
        "description": "Evaluates the cumulative distribution function of a t-distribution at variable value v, i.e. calculates the probability P(X ≤ v) where X is a random variable with a t-distribution with the given degrees of freedom.",
        "examples": [
            {
                "description": "TDistribution(10, 0) yields 0.5",
                "command": "TDistribution(10, 0)"
            }
        ],
        "note": "This syntax returns the probability at a given value, that is the area under the t-distribution curve to the left of the given x-coordinate."
    },
    {
        "signature": "Plane( <Polygon> ), Plane( <Conic> ), Plane( <Point>, <Plane> ), Plane( <Point>, <Line> ), Plane( <Line>, <Line> ), Plane( <Point>, <Point>, <Point> ), Plane( <Point>, <Vector>, <Vector> )",
        "commandBase": "Plane",
        "description": "Creates a plane based on various geometric inputs, such as polygons, conics, points, lines, or vectors.",
        "examples": [
            {
                "description": "Create a plane through three points",
                "command": "Plane( <Point>, <Point>, <Point> )"
            },
            {
                "description": "Create a plane through a point and parallel to another plane",
                "command": "Plane( <Point>, <Plane> )"
            }
        ],
        "note": "See also Plane through 3 Points and Plane tools. Ensure inputs meet specified conditions, such as points not being collinear or lines intersecting/parallel."
    },
    {
        "signature": "StepGraph( <List of Points> ) | StepGraph( <List of Points>, <Boolean Join> ) | StepGraph( <List of x-coordinates>, <List of y-coordinates> ) | StepGraph( <List of x-coordinates>, <List of y-coordinates>, <Boolean Join> ) | StepGraph( <List of x-coordinates>, <List of y-coordinates>, <Boolean Join>, <Point Style> ) | StepGraph( <List of Points>, <Boolean Join>, <Point Style> )",
        "commandBase": "StepGraph",
        "description": "Draws a step graph of the given list of points. Each point is connected to the next point in the list by a horizontal line segment. Optional parameters control whether vertical segments are drawn and how points are styled.",
        "examples": [
            {
                "description": "Draw a step graph with a list of points",
                "command": "StepGraph({(1, 1), (3, 2), (4, 5), (5, 7)})"
            },
            {
                "description": "Draw a step graph with points and join parameter set to true",
                "command": "StepGraph({(1, 1), (3, 2), (4, 5), (5, 7)}, true)"
            },
            {
                "description": "Draw a step graph with separate x and y coordinate lists",
                "command": "StepGraph({1, 3, 4, 5}, {1, 2, 5, 7})"
            },
            {
                "description": "Draw a step graph with coordinate lists and join parameter set to true",
                "command": "StepGraph({1, 3, 4, 5}, {1, 2, 5, 7}, true)"
            },
            {
                "description": "Draw a step graph with coordinate lists, join set to false, and point style 1",
                "command": "StepGraph({1, 3, 4, 5}, {1, 2, 5, 7}, false, 1)"
            },
            {
                "description": "Draw a step graph with points, join set to false, and point style 1",
                "command": "StepGraph({(1, 1), (3, 2), (4, 5), (5, 7)}, false, 1)"
            }
        ],
        "note": "Point style values determine how points are drawn: 0 = no points, 1 = solid points on the right, 2 = solid points on the right with open points on the left, -1 = solid points on the left, -2 = solid points on the left with open points on the right."
    },
    {
        "signature": "Length( <Object> ), Length( <Function>, <Start x-Value>, <End x-Value> ), Length( <Function>, <Start Point>, <End Point> ), Length( <Curve>, <Start t-Value>, <End t-Value> ), Length( <Curve>, <Start Point>, <End Point> ), Length( <Function>, <Variable>, <Start x-Value>, <End x-Value> )",
        "commandBase": "Length",
        "description": "Yields the length of the object, such as vectors, points, lists, text, loci, arcs, function graphs, or curves.",
        "examples": [
            {
                "description": "Length of a vector",
                "command": "Length( <Vector> )"
            },
            {
                "description": "Length of a point's position vector",
                "command": "Length( <Point> )"
            },
            {
                "description": "Length of a list (number of elements)",
                "command": "Length( <List> )"
            },
            {
                "description": "Length of text (number of characters)",
                "command": "Length( <Text> )"
            },
            {
                "description": "Length of a locus (number of points)",
                "command": "Length( <Locus> )"
            },
            {
                "description": "Length of an arc or sector",
                "command": "Length( <Arc> )"
            },
            {
                "description": "Length of a function graph in an interval",
                "command": "Length(2x, 0, 1)"
            },
            {
                "description": "Length of a function graph between two points",
                "command": "Length( <Function>, <Start Point>, <End Point> )"
            },
            {
                "description": "Length of a curve between two parameter values",
                "command": "Length( <Curve>, <Start t-Value>, <End t-Value> )"
            },
            {
                "description": "Length of a curve between two points on the curve",
                "command": "Length( <Curve>, <Start Point>, <End Point> )"
            },
            {
                "description": "Length of a function graph with a specified variable",
                "command": "Length(2 a, a, 0, 1)"
            }
        ],
        "note": "If points do not lie on the function graph, their x-coordinates are used to determine the interval. For loci, use Perimeter(Locus) to get the length of the locus itself. See also Distance or Length tool."
    },
    {
        "signature": "SelectedElement( <List> )",
        "commandBase": "SelectedElement",
        "description": "Returns the selected element in a drop-down list.",
        "examples": [
            {
                "description": "SelectedElement( <List> )",
                "command": "SelectedElement( <List> )"
            }
        ],
        "note": "See also SelectedIndex command"
    },
    {
        "signature": "Sequence( <End Value> ) | Sequence( <Start value k>, <End value n> ) | Sequence( <Start value k>, <End value n>, <Increment> ) | Sequence( <Expression>, <Variable k>, <Start Value a>, <End Value b> ) | Sequence( <Expression>, <Variable k>, <Start Value a>, <End Value b>, <Increment> )",
        "commandBase": "Sequence",
        "description": "Creates a list of integers or objects based on specified parameters, with multiple overloads for different use cases.",
        "examples": [
            {
                "description": "Creates a list of integers from 1 to 4",
                "command": "Sequence(4)"
            },
            {
                "description": "Creates a list of integers from 7 to 13",
                "command": "Sequence(7,13)"
            },
            {
                "description": "Creates a list of integers from 18 to 14 (decreasing)",
                "command": "Sequence(18,14)"
            },
            {
                "description": "Creates a list of integers from -5 to 5",
                "command": "Sequence(-5,5)"
            },
            {
                "description": "Creates a list of integers from 7 to 13 with increment 2",
                "command": "Sequence(7,13,2)"
            },
            {
                "description": "Creates a list of integers from 7 to 13 with increment 4",
                "command": "Sequence(7,13,4)"
            },
            {
                "description": "Creates a list of points with y-coordinates from 1 to 5",
                "command": "Sequence((2,k),k,1,5)"
            },
            {
                "description": "Creates a list of powers of x from x to x¹⁰",
                "command": "Sequence(x^k,k,1,10)"
            },
            {
                "description": "Creates a list of points with y-coordinates from 1 to 3 with increment 0.5",
                "command": "Sequence((2,k),k,1,3,0.5)"
            },
            {
                "description": "Creates a list of powers of x with odd exponents from 1 to 10",
                "command": "Sequence(x^k,k,1,10,2)"
            }
        ],
        "note": "The syntax can be simplified: e.g., Sequence(7,13) is equivalent to typing 7..13. Parameters a and b can be dynamic (e.g., slider variables). See Lists for more information on list operations."
    },
    {
        "signature": "RandomPoisson( <Mean> )",
        "commandBase": "RandomPoisson",
        "description": "Generates a random number from a Poisson distribution with given mean.",
        "examples": [
            {
                "description": "RandomPoisson(3) yields a random value from a Poisson distribution with a mean of 3.",
                "command": "RandomPoisson(3)"
            }
        ],
        "note": "See also SetSeed command, RandomBetween command, RandomElement command, RandomBinomial command, RandomNormal command, RandomUniform command."
    },
    {
        "signature": "Side( <Quadric> )",
        "commandBase": "Side",
        "description": "Creates the side of the limited quadric.",
        "examples": [
            {
                "description": "Side( cylinder ) creates the curved surface area of the cylinder.",
                "command": "Side( cylinder )"
            }
        ],
        "note": "See also Top Command, Bottom Command and Ends Command."
    },
    {
        "signature": "Eigenvalues( <Matrix> )",
        "commandBase": "Eigenvalues",
        "description": "Finds the eigenvalues of the given matrix.",
        "examples": [
            {
                "description": "CAS Syntax example for finding eigenvalues of a matrix",
                "command": "Eigenvalues({{1, 2}, {3, 4}}) yields stem:[ \\left\\{ \\frac{\\sqrt{33} + 5}{2}, \\frac{-\\sqrt{33} + 5}{2} \\right\\} ]"
            }
        ],
        "note": "See also Eigenvectors Command, SVD Command, Invert Command, Transpose Command"
    },
    {
        "signature": "Prove( <Boolean Expression> )",
        "commandBase": "Prove",
        "description": "Returns whether the given boolean expression is true or false in general. Normally, GeoGebra decides whether a boolean expression is true or not by using numerical computations. However, the Prove command uses symbolic methods (https://en.wikipedia.org/wiki/Symbolic_computation) to determine whether a statement is true or false in general. If GeoGebra cannot determine the answer, the result is undefined.",
        "examples": [
            {
                "description": "We define three free points, A=(1,2), B=(3,4), C=(5,6). The command AreCollinear(A,B,C) yields true, since a numerical check is used on the current coordinates of the points. Using Prove(AreCollinear(A,B,C)) you will get false as an answer, since the three points are not collinear in general, i.e. when we change the points.",
                "command": "Prove(AreCollinear(A,B,C))"
            },
            {
                "description": "Let us define a triangle with vertices A, B and C, and define D=MidPoint(B,C), E=MidPoint(A,C), p=Line(A,B), q=Line(D,E). Now both p∥q and Prove(p∥q) yield true, since a midline of a triangle will always be parallel to the appropriate side. See also interactive version of this example (https://www.geogebra.org/m/vhZETdtd).",
                "command": "Prove(p∥q)"
            }
        ],
        "note": "See also ProveDetails command, Boolean values, and GeoGebra Automated Reasoning Tools: A Tutorial (https://github.com/kovzol/gg-art-doc/tree/master/pdf/english.pdf)."
    },
    {
        "signature": "CircumcircularArc( <Point>, <Point>, <Point> )",
        "commandBase": "CircumcircularArc",
        "description": "Creates a circular arc through three points, where the first point is the starting point and the third point is the endpoint of the circumcircular arc.",
        "examples": [],
        "note": "See also [Image: Mode circumcirclearc3.svg,width=24,height=24] Circumcircular Arc tool."
    },
    {
        "signature": "SetFixed( <Object>, <true | false> )\nSetFixed( <Object>, <true | false>, <true | false> )",
        "commandBase": "SetFixed",
        "description": "Makes the object fixed (for true) or not fixed (for false).",
        "examples": [
            {
                "description": "Set an object as fixed",
                "command": "SetFixed( <Object>, true )"
            },
            {
                "description": "Set an object as not fixed",
                "command": "SetFixed( <Object>, false )"
            },
            {
                "description": "Set an object as fixed with selection allowed",
                "command": "SetFixed( <Object>, true, true )"
            },
            {
                "description": "Set an object as not fixed with selection not allowed",
                "command": "SetFixed( <Object>, false, false )"
            }
        ],
        "note": "The second parameter in the three-argument version determines 'Selection Allowed'."
    },
    {
        "signature": "Laplace( <Function> ) or Laplace( <Function>, <Variable> )",
        "commandBase": "Laplace",
        "description": "Returns the Laplace transform of the given function, optionally with respect to a specified variable.",
        "examples": [
            {
                "description": "Laplace transform of sin(t)",
                "command": "Laplace(sin(t))"
            },
            {
                "description": "Laplace transform of sin(a*t) with respect to t",
                "command": "Laplace(sin(a*t),t)"
            },
            {
                "description": "Laplace transform of sin(a*t) with respect to a",
                "command": "Laplace(sin(a*t),a)"
            }
        ],
        "note": "See also InverseLaplace command."
    },
    {
        "signature": "FillCells( <CellRange>, <Object> ) | FillCells( <Cell>, <List> ) | FillCells( <Cell>, <Matrix> )",
        "commandBase": "FillCells",
        "description": "Copies the value/equation etc. of the object to the given cellrange. Resulting cells are free objects, i.e. independent of object.",
        "examples": [
            {
                "description": "Copies the value/equation etc. of the object to the given cellrange. Resulting cells are free objects, i.e. independent of object.",
                "command": "FillCells( <CellRange>, <Object> )"
            },
            {
                "description": "Copies values from the list to the first cells on the right of the given cell. Resulting cells are free objects, i.e. independent of the list.",
                "command": "FillCells( <Cell>, <List> )"
            },
            {
                "description": "Copies values from the matrix into the spreadsheet. The upper left corner of the matrix is matched to the given cell. Resulting cells are free objects, i.e. independent of the matrix.",
                "command": "FillCells( <Cell>, <Matrix> )"
            }
        ],
        "note": "• CellRange has to be entered like this: e.g.: B2:D5.\n• Object can be anything, e.g.: 3, RandomBetween(0, 10), Circle(A, B).\n• Cells are labelled by column and row, e.g.: B2.\n• See also FillRow and FillColumn commands.\n• You can use FillCell(cell, Transpose({list})) to fill vertically. The extra braces convert the list into a matrix thus {list}"
    },
    {
        "signature": "Repeat( <Number>, <Scripting Command>, <Scripting Command>, ... )",
        "commandBase": "Repeat",
        "description": "Repeats the execution of scripting commands n times, where n is the given Number.",
        "examples": [
            {
                "description": "Turtle() and click the Play button to execute. The turtle moves and draws a regular octagon.",
                "command": "Repeat(8, TurtleForward(turtle1, 1), TurtleRight(turtle1, 45°))"
            }
        ],
        "note": "Click the [Image: Animate Play.png,width=16,height=16] \"Play\" button displayed at bottom left to execute the command."
    },
    {
        "signature": "InverseFDistribution( <Numerator Degrees of Freedom>, <Denominator Degrees of Freedom>, <Probability> )",
        "commandBase": "InverseFDistribution",
        "description": "Computes the inverse of the cumulative distribution function of an F-distribution at probability p, where the F-distribution is defined by the given degrees of freedom. In other words, it finds t such that P(X ≤ t) = p, where X is a random variable with an F-distribution. Probability p must be a value in the closed interval [0,1].",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Curvature( <Point>, <Object> )",
        "commandBase": "Curvature",
        "description": "Yields the curvature of the object (function, curve, conic) at the given point.",
        "examples": [
            {
                "description": "Curvature at point (0,0) for function x^2",
                "command": "Curvature((0, 0), x^2)"
            },
            {
                "description": "Curvature at point (0,0) for parametric curve",
                "command": "Curvature((0, 0), Curve(cos(t), sin(2t), t, 0, π))"
            },
            {
                "description": "Curvature at point (-1,0) for conic",
                "command": "Curvature((-1, 0), Conic({1, 1, 1, 2, 2, 3}))"
            }
        ],
        "note": ""
    },
    {
        "signature": "CFactor( <Expression> ) or CFactor( <Expression>, <Variable> )",
        "commandBase": "CFactor",
        "description": "Factorizes a given expression, allowing for complex factors. Can factorize with respect to a specified variable.",
        "examples": [
            {
                "description": "Factorize x² + 4 over complex numbers",
                "command": "CFactor(x² + 4)"
            },
            {
                "description": "Factorize a² + x² with respect to variable a",
                "command": "CFactor(a² + x², a)"
            },
            {
                "description": "Factorize a² + x² with respect to variable x",
                "command": "CFactor(a² + x², x)"
            }
        ],
        "note": "This command factors expressions over the Complex Rational Numbers (Gaussian rationals). To factor over rational numbers, use the Factor Command. Command name varies by English variant: CFactor (US) or CFactorise (UK + Aus)."
    },
    {
        "signature": "Variance( <List of Raw Data> )",
        "commandBase": "Variance",
        "description": "Calculates the variance of list elements.",
        "examples": [
            {
                "description": "Variance({1, 2, 3}) yields 0.67.",
                "command": "Variance({1, 2, 3})"
            },
            {
                "description": "Variance({1, 2, 3} , {1, 2, 1}) yields 0.5.",
                "command": "Variance({1, 2, 3}, {1, 2, 1})"
            },
            {
                "description": "Variance({1, 2, a}) yields stem:[\\frac{2}{9} a{2} - \\frac{2}{3} a + \\frac{2}{3}].",
                "command": "Variance({1, 2, a})"
            }
        ],
        "note": "The command has multiple signatures: Variance(<List of Raw Data>) calculates variance of list elements; Variance(<List of Numbers>, <List of Frequencies>) calculates variance considering frequencies; CAS Syntax Variance(<List of Numbers>) calculates variance and yields a formula if the list contains undefined variables."
    },
    {
        "signature": "RemoveUndefined( <List> )",
        "commandBase": "RemoveUndefined",
        "description": "Removes undefined objects from a list.",
        "examples": [
            {
                "description": "RemoveUndefined(Sequence((-1)^k, k, -3, -1, 0.5)) removes the second and fourth element of the sequence since expressions (-1)^{1.5} and (-1)^{2.5} are undefined and yields list {-1, 1, -1}.",
                "command": "RemoveUndefined(Sequence((-1)^k, k, -3, -1, 0.5))"
            }
        ],
        "note": "See also Remove Command."
    },
    {
        "signature": "Parabola( <Point>, <Line> )",
        "commandBase": "Parabola",
        "description": "Returns a parabola with focal point and the line as directrix.",
        "examples": [
            {
                "description": "Let a = Line((0,1), (2,1)). Parabola((3, 3), a) yields x² - 6x - 4y = -17.",
                "command": "Parabola((3, 3), a)"
            }
        ],
        "note": "See also Parabola tool."
    },
    {
        "signature": "SemiMajorAxisLength( <Conic> )",
        "commandBase": "SemiMajorAxisLength",
        "description": "Returns the length of the semimajor axis (half of the major axis) of the conic section.",
        "examples": [
            {
                "description": "SemiMajorAxisLength((x - 1)2 + (y - 2)2 = 4) yields 2.",
                "command": "SemiMajorAxisLength((x - 1)2 + (y - 2)2 = 4)"
            }
        ],
        "note": "See also SemiMinorAxisLength command."
    },
    {
        "signature": "ShortestDistance( <List of Segments>, <Start Point>, <End Point>, <Boolean Weighted> )",
        "commandBase": "ShortestDistance",
        "description": "Finds shortest path between start point and endpoint in a graph given by list of segments. If weighted is false, weight of each edge is supposed to be 1 (i.e. we are looking for the path with least number of edges), otherwise it is the length of given segment (we are looking for the geometrically shortest path).",
        "examples": [],
        "note": ""
    },
    {
        "signature": "MinorAxis( <Conic> )",
        "commandBase": "MinorAxis",
        "description": "Returns the equation of the minor axis of the conic section.",
        "examples": [
            {
                "description": "MinorAxis(x2 / 9 + y2 / 4 = 1) returns x = 0.",
                "command": "MinorAxis(x2 / 9 + y2 / 4 = 1)"
            }
        ],
        "note": "See also MajorAxis command."
    },
    {
        "signature": "InversePoisson( <Mean>, <Probability> )",
        "commandBase": "InversePoisson",
        "description": "Returns the least integer n such that P(X≤n) ≥ p, where p is the given probability and X is a Poisson random variable with given mean.",
        "examples": [
            {
                "description": "InversePoisson( <Mean>, <Probability> ): Returns the least integer n such that P(X≤n) ≥ p, where p is the given probability and X is a Poisson random variable with given mean.",
                "command": "InversePoisson( <Mean>, <Probability> )"
            }
        ],
        "note": "See also Poisson Command."
    },
    {
        "signature": "CommonDenominator( <Expression>, <Expression> )",
        "commandBase": "CommonDenominator",
        "description": "Returns the lowest common denominator of the two expressions.",
        "examples": [
            {
                "description": "CommonDenominator(3 / (2 x + 1), 3 / (4 x2 + 4 x + 1)) yields 4 x2 + 4 x + 1",
                "command": "CommonDenominator(3 / (2 x + 1), 3 / (4 x2 + 4 x + 1))"
            }
        ],
        "note": "The command returns the function having as equation the lowest common denominator of the two expressions."
    },
    {
        "signature": "FitExp( <List of Points> )",
        "commandBase": "FitExp",
        "description": "Calculates the exponential regression curve in the form aℯbx.",
        "examples": [
            {
                "description": "Fit exponential regression to a list of points",
                "command": "FitExp({(0, 1), (2, 3), (4, 3), (6, 4)})"
            }
        ],
        "note": "If you want the answer in the form stem:[ a b  x ] then use the FitGrowth Command. You can do a direct least-squares fitting with Fit(list, a*exp(b*x)). Euler's number ℯ can be obtained by pressing [.kcode]ALT + [.kcode]e. See also Fit, FitGrowth, FitLine, FitLineX, FitLog, FitLogistic, FitPoly, FitPow and FitSin."
    },
    {
        "signature": "Centroid( <Polygon> )",
        "commandBase": "Centroid",
        "description": "Returns the centroid of the polygon.",
        "examples": [
            {
                "description": "Let A = (1, 4), B = (1, 1), C = (5, 1) and D = (5, 4) be the vertices of a polygon. Polygon(A, B, C, D) yields poly1 = 12.",
                "command": "Centroid(poly1) yields the centroid E = (3, 2.5)."
            }
        ],
        "note": ""
    },
    {
        "signature": "InverseBeta( <Number α>, <Number β>, <Probability> )",
        "commandBase": "InverseBeta",
        "description": "Computes the inverse of the Beta cumulative distribution with parameters α and β for a given probability p. In other words, the command finds t such that P(X ≤ t) = p, where X is a random variable with a Beta distribution. Probability p is any value in the interval [0,1].",
        "examples": [],
        "note": "See also BetaDist command."
    },
    {
        "signature": "ZProportionTest( <Sample Proportion>, <Sample Size>, <Hypothesized Proportion>, <Tail> )",
        "commandBase": "ZProportionTest",
        "description": "Performs a one sample Z test of a proportion using the given sample statistics. Hypothesized Proportion is the population proportion assumed in the null hypothesis. Tail has possible values \"<\", \">\", \"≠\". These specify the alternative hypothesis as follows: \"<\" = population proportion < Hypothesized Proportion, \">\" = population proportion > Hypothesized Proportion, \"≠\" = population proportion ≠ Hypothesized Proportion. Results are returned in list form as {Probability value, Z test statistic}.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "PrimeFactors( <Number> )",
        "commandBase": "PrimeFactors",
        "description": "Returns the list of primes whose product is equal to the given number.",
        "examples": [
            {
                "description": "Prime factorization of 1024",
                "command": "PrimeFactors(1024) yields {2, 2, 2, 2, 2, 2, 2, 2, 2, 2}"
            },
            {
                "description": "Prime factorization of 42",
                "command": "PrimeFactors(42) yields {2, 3, 7}"
            }
        ],
        "note": "See also Factor command."
    },
    {
        "signature": "FitPow( <List of Points> )",
        "commandBase": "FitPow",
        "description": "Calculates the regression curve in the form a x^b.",
        "examples": [
            {
                "description": "FitPow({(1, 1), (3, 2), (7, 4)}) creates the regression curve f(x) = 0.97 x^0.71.",
                "command": "FitPow({(1, 1), (3, 2), (7, 4)})"
            },
            {
                "description": "FitPow({(1, 1), (3, 2), (7, 4)}) yields 0.97 x^0.71.",
                "command": "FitPow({(1, 1), (3, 2), (7, 4)})"
            }
        ],
        "note": "All points used need to be in the first quadrant of the coordinate system. See also FitExp Command, FitLog Command, FitPoly Command, and FitSin Command. If you work with big/small numbers, you should consider normalizing them for a more accurate result, see Normalize Command."
    },
    {
        "signature": "SetCoords( <Object>, <x>, <y> ) or SetCoords( <Object>, <x>, <y>, <z> )",
        "commandBase": "SetCoords",
        "description": "Sets the cartesian coordinates of free objects in a 2D View or 3D View as the given coordinates. This command uses the coordinates values, not their definitions, therefore the object stays free.",
        "examples": [
            {
                "description": "Sets the cartesian coordinates of free objects in a 2D View as the given coordinates. This command uses the coordinates values, not their definitions, therefore the object stays free.",
                "command": "SetCoords( <Object>, <x>, <y> )"
            },
            {
                "description": "Sets the cartesian coordinates of free objects in the 3D View as the given coordinates. This command uses the coordinates values, not their definitions, therefore the object stays free.",
                "command": "SetCoords( <Object>, <x>, <y>, <z> )"
            }
        ],
        "note": "• This also works for points on paths and in regions. The point will be moved to the closest possible position.\n• This command works also for sliders, buttons, checkboxes, input Boxes and Images.\n• If the option \"Absolute Screen Position\" is selected, then x, y and z are in screen pixels."
    },
    {
        "signature": "ScientificText( <Number> ) | ScientificText( <Number>, <Precision> )",
        "commandBase": "ScientificText",
        "description": "Creates a text displaying the given number in scientific notation, with optional precision parameter for rounding to specified significant digits.",
        "examples": [
            {
                "description": "Display number in scientific notation",
                "command": "ScientificText(0.002)"
            },
            {
                "description": "Display number in scientific notation with 5 significant digits",
                "command": "ScientificText(e,5)"
            }
        ],
        "note": "This command differs among variants of English: StandardForm (UK) and ScientificText (US + Aus). The text is placed with the top left corner (Corner 4) of its box at the origin of the coordinate system."
    },
    {
        "signature": "InverseNormal(<Mean>, <Standard Deviation>, <Probability>)",
        "commandBase": "InverseNormal",
        "description": "Evaluates the expression Φ⁻¹(P) × σ + μ at given probability P, where Φ⁻¹ is the inverse of the cumulative distribution function Φ for N(0,1), defined by the given parameters mean and standard deviation. Returns the x-coordinate of the point with the given probability (area) to the left, under the normal distribution curve.",
        "examples": [
            {
                "description": "Calculate the 90th percentile of a normal distribution with mean 50 and standard deviation 2",
                "command": "InverseNormal(50, 2, 0.9)"
            }
        ],
        "note": "Returns the x-coordinate of the point with the given probability (area) to the left, under the normal distribution curve."
    },
    {
        "signature": "GetTime() or GetTime(\"<Format>\")",
        "commandBase": "GetTime",
        "description": "Returns the current time and date in various formats. Without arguments, it returns a list with detailed components. With a format string, it creates a formatted text based on PHP date format characters.",
        "examples": [
            {
                "description": "Returns a list with the current time and date in order: milliseconds, seconds, minutes, hours (0-23), date, month (1-12), year, month (as text), day (as text), day (1 = Sunday, 2 = Monday, etc)",
                "command": "GetTime()"
            },
            {
                "description": "Creates a text using Format as a template replacing PHP date format characters prefixed by a backslash",
                "command": "GetTime(\"The date is \\l the \\j\\S of \\F \\Y\")"
            }
        ],
        "note": "For GetTime(\"<Format>\"), refer to http://php.net/manual/en/function.date.php for explanations of format characters like d, D, j, etc."
    },
    {
        "signature": "SetSeed( <Integer> )",
        "commandBase": "SetSeed",
        "description": "Seeds the random number generator so that subsequent random numbers will be determined by the seed.",
        "examples": [
            {
                "description": "Set the seed to 33",
                "command": "SetSeed(33)"
            }
        ],
        "note": "See also RandomBetween command, RandomElement command, RandomBinomial command, RandomNormal command, RandomPoisson command, RandomUniform command."
    },
    {
        "signature": "TravelingSalesman( <List of Points> )",
        "commandBase": "TravelingSalesman",
        "description": "Returns the shortest closed path which goes through each point exactly once. Returned object is a locus, so it is auxiliary.",
        "examples": [],
        "note": "This command differs among variants of English: * TravelingSalesman (US) * TravellingSalesman (UK + Aus)"
    },
    {
        "signature": "Append( <List>, <Object> ) or Append( <Object>, <List> )",
        "commandBase": "Append",
        "description": "Appends the object to the list and yields the results in a new list, or appends the list to the object and yields the results in a new list.",
        "examples": [
            {
                "description": "Append an object to a list",
                "command": "Append({1, 2, 3}, 4)"
            },
            {
                "description": "Append a list to an object",
                "command": "Append(4, {1, 2, 3})"
            }
        ],
        "note": "This command handles two cases: appending an object to a list or a list to an object, both resulting in a new list."
    },
    {
        "signature": "LCM( <Number>, <Number> ) | LCM( <List of Numbers> ) | LCM( <Polynomial>, <Polynomial> ) | LCM( <List of Polynomials> )",
        "commandBase": "LCM",
        "description": "Calculates the least common multiple of two numbers, a list of numbers, two polynomials, or a list of polynomials.",
        "examples": [
            {
                "description": "Calculates the least common multiple of two numbers",
                "command": "LCM(12, 15)"
            },
            {
                "description": "Calculates the least common multiple of the elements in the list",
                "command": "LCM({12, 30, 18})"
            },
            {
                "description": "Calculates the least common multiple of two polynomials",
                "command": "LCM(x2 + 4 x + 4, x2 - x - 6)"
            },
            {
                "description": "Calculates the least common multiple of the polynomials in the list",
                "command": "LCM({x2 + 4 x + 4, x2 - x - 6, x3 - 4 x2 - 3 x + 18})"
            }
        ],
        "note": "In the CAS View you can also use the syntax for polynomials. See also GCD Command."
    },
    {
        "signature": "SetConstructionStep( <Number> )",
        "commandBase": "SetConstructionStep",
        "description": "Changes the construction step to given value. You can use this command to create buttons that replace or enhance the Navigation Bar.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "RemovableDiscontinuity( <Function> )",
        "commandBase": "RemovableDiscontinuity",
        "description": "Computes the removable discontinuity at a point for broken rational functions (also for previews).",
        "examples": [
            {
                "description": "Example of computing removable discontinuity",
                "command": "RemovableDiscontinuity((3-x)/(2 x(2)-6 x)) yields (3,-0.17)."
            }
        ],
        "note": ""
    },
    {
        "signature": "Ordinal( <Integer> )",
        "commandBase": "Ordinal",
        "description": "Turns a number into an ordinal (as a text).",
        "examples": [
            {
                "description": "Ordinal(5) returns \"5th\".",
                "command": "Ordinal(5)"
            }
        ],
        "note": ""
    },
    {
        "signature": "TTest( <List of Sample Data>, <Hypothesized Mean>, <Tail> ) or TTest( <Sample Mean>, <Sample Standard Deviation>, <Sample Size>, <Hypothesized Mean>, <Tail> )",
        "commandBase": "TTest",
        "description": "Performs a one-sample t-test of a population mean using either sample data or sample statistics. Hypothesized Mean is the population mean assumed in the null hypothesis. Tail specifies the alternative hypothesis: '<' = population mean < Hypothesized Mean, '>' = population mean > Hypothesized Mean, '≠' = population mean ≠ Hypothesized Mean. Results are returned in list form as {Probability value, t-test statistic}.",
        "examples": [
            {
                "description": "Perform t-test with sample data list, hypothesized mean 3, and left-tailed alternative",
                "command": "TTest({1, 2, 3, 4, 5}, 3, \"<\")"
            },
            {
                "description": "Perform t-test with sample statistics, hypothesized mean 4, and two-tailed alternative",
                "command": "TTest(4, 1, 12, 4, \"≠\")"
            }
        ],
        "note": "The command has two signatures: one using raw sample data and another using sample statistics (mean, standard deviation, size). Tail parameter must be one of the three specified symbols."
    },
    {
        "signature": "UnitVector( <Vector> )\nUnitVector( <Line> )\nUnitVector( <Segment> )",
        "commandBase": "UnitVector",
        "description": "Yields a vector with length 1, which has the same direction and orientation as the given vector. The vector must be defined first. Also works with lines and segments to yield their direction vectors with length 1.",
        "examples": [
            {
                "description": "UnitVector with a vector",
                "command": "UnitVector(v) where v = (3,4) yields (0.6,0.8)"
            },
            {
                "description": "UnitVector with a line equation",
                "command": "UnitVector(3x + 4y = 5) yields (0.8,-0.6)"
            },
            {
                "description": "UnitVector with a segment",
                "command": "UnitVector(s) where s = Segment((1,1),(4,5)) yields (0.6,0.8)"
            },
            {
                "description": "UnitVector with symbolic 2D vector",
                "command": "UnitVector((a, b)) yields (a/√(a²+b²), b/√(a²+b²))"
            },
            {
                "description": "UnitVector with 3D vector",
                "command": "UnitVector((2, 4, 4)) yields (1/3, 2/3, 2/3)"
            }
        ],
        "note": "In the CAS View, three-dimensional vectors and vectors with undefined variables are also valid inputs."
    },
    {
        "signature": "Remove( <List>, <List> )",
        "commandBase": "Remove",
        "description": "Removes objects from the first list each time they appear in the second list.",
        "examples": [
            {
                "description": "Remove({1,3,4,4,9},{1,4,5}) yields list {3,4,9}.",
                "command": "Remove({1,3,4,4,9},{1,4,5})"
            }
        ],
        "note": "You can also type {1,3,4,4,9} \\ {1,4,5} if you want the set-theoretic difference. See also RemoveUndefined Command."
    },
    {
        "signature": "InverseLogNormal( <Mean>, <Standard Deviation>, <Probability> )",
        "commandBase": "InverseLogNormal",
        "description": "Computes the inverse of the cumulative distribution function of a log-normal distribution at probability p, where the log-normal distribution is defined by the given parameters mean and standard deviation. In other words, it finds t such that P(X ≤ t) = p, where X is a log-normal random variable. Probability p must be a value in the closed interval [0, 1].",
        "examples": [
            {
                "description": "Compute inverse log-normal with mean 10, standard deviation 20, and probability 1/3",
                "command": "InverseLogNormal(10, 20, 1/3)"
            },
            {
                "description": "Compute inverse log-normal with mean 1000, standard deviation 2, and probability 1",
                "command": "InverseLogNormal(1000, 2, 1)"
            }
        ],
        "note": "The second example returns infinity (∞) when probability equals 1."
    },
    {
        "signature": "Cubic( <Point>, <Point>, <Point>, <Number> )",
        "commandBase": "Cubic",
        "description": "Gives n-th triangle cubic (https://bernard-gibert.pagesperso-orange.fr/ctc.html) of the given triangle ABC.",
        "examples": [
            {
                "description": "Let A = (0, 1), B = (2, 1) and C = (1, 2). Cubic(A, B, C, 2) yields the implicit curve -x³ + 3x² + 5x y² - 14x y + 7x - 5y² + 14y = 9.",
                "command": "Cubic(A, B, C, 2)"
            }
        ],
        "note": "This command is in development, set of supported index n is changing. Some common triangle cubics: 1 - Neuberg Cubic, 2 - Thomson Cubic, 3 - McCay Cubic, 4 - Darboux Cubic, 5 - Napoleon/Feuerbach Cubic, 7 - Lucas Cubic, 17 - 1st Brocard Cubic, 18 - 2nd Brocard Cubic."
    },
    {
        "signature": "SampleVariance( <List of Raw Data> )",
        "commandBase": "SampleVariance",
        "description": "Returns the sample variance of the given list of numbers.",
        "examples": [
            {
                "description": "Calculate sample variance for a list of numbers",
                "command": "SampleVariance({1, 2, 3, 4, 5})"
            },
            {
                "description": "Calculate sample variance for a list of numbers with frequencies",
                "command": "SampleVariance({1, 2, 3, 4, 5}, {3, 2, 4, 4, 1})"
            },
            {
                "description": "Calculate sample variance for a list with undefined variables (yields formula)",
                "command": "SampleVariance({a, b, c})"
            }
        ],
        "note": "If the list contains undefined variables, this command yields a formula for the sample variance."
    },
    {
        "signature": "Intersection( <List>, <List> )",
        "commandBase": "Intersection",
        "description": "Gives you a new list containing all elements that are part of both lists.",
        "examples": [
            {
                "description": "Let list1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15} and list2 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30} be two lists. Intersection(list1, list2) yields a new list list3 = {2, 4, 6, 8, 10, 12, 14}.",
                "command": "Intersection(list1, list2)"
            }
        ],
        "note": ""
    },
    {
        "signature": "Periods( <Rate>, <Payment>, <Present Value>, <Future Value (optional)>, <Type (optional)> )",
        "commandBase": "Periods",
        "description": "Returns the number of periods for an annuity based on periodic, fixed payments and a fixed interest rate.",
        "examples": [
            {
                "description": "Calculate number of payments with end-of-period payments",
                "command": "Periods(10%/12, -200, -400, 10000)"
            },
            {
                "description": "Calculate number of payments with beginning-of-period payments",
                "command": "Periods(10%/12, -200, -400, 10000, 1)"
            }
        ],
        "note": "If you make monthly payments on an annual interest rate of 10 percent, use 10%/12 for <Rate>. For all arguments, cash paid out is represented by negative numbers and cash received by positive numbers. See also Payment, Rate, Present Value and Future Value commands."
    },
    {
        "signature": "MatrixRank( <Matrix> )",
        "commandBase": "MatrixRank",
        "description": "Returns the rank (https://en.wikipedia.org/wiki/Rank_(linear_algebra)) of given matrix.",
        "examples": [
            {
                "description": "Calculate rank of matrix {{2, 2}, {1, 1}}",
                "command": "MatrixRank({{2, 2}, {1, 1}})"
            },
            {
                "description": "Calculate rank of matrix {{1, 2}, {3, 4}}",
                "command": "MatrixRank({{1, 2}, {3, 4}})"
            },
            {
                "description": "Calculate rank of matrix A = {{1, 2, 3}, {1, 1, 1}, {2, 2, 2}}",
                "command": "MatrixRank(A)"
            },
            {
                "description": "Calculate rank of matrix with variable k",
                "command": "MatrixRank({{1, 2}, {k*1, k*2}})"
            }
        ],
        "note": "In the CAS View this command also works with undefined variables."
    },
    {
        "signature": "Surface( <Expression>, <Expression>, <Expression>, <Parameter Variable 1>, <Start Value>, <End Value>, <Parameter Variable 2>, <Start Value>, <End Value> )",
        "commandBase": "Surface",
        "description": "Yields the Cartesian parametric 3D surface for the given x-expression (first <Expression>), y-expression (second <Expression>) and z-expression (third <Expression>), using two <Parameter Variables> within the given intervals [<Start Value>, <End Value>].",
        "examples": [
            {
                "description": "Let r and R be two positive real numbers: Surface((R + r cos( u)) cos(v) , (R + r cos( u)) sin(v) , r sin(u ), u, 0, 2 π , v, 0, 2 π) creates the torus generated by a circle of radius r whose center rotates about zAxis at a distance R.",
                "command": "Surface((R + r cos( u)) cos(v) , (R + r cos( u)) sin(v) , r sin(u ), u, 0, 2 π , v, 0, 2 π)"
            }
        ],
        "note": "• End Value must be greater than or equal to Start Value and both must be finite.\n• x, y and z are not allowed as parameter variables.\n• Surface( <Function>, <Angle> ) creates a surface of revolution, rotating the given Function from 0 to given Angle around the x-axis.\n• Surface( <Curve>, <Angle>, <Line>) creates a surface of revolution, rotating the Curve from 0 to given Angle around the Line."
    },
    {
        "signature": "ZProportion2Estimate( <Sample Proportion 1 >, <Sample Size 1>, <Sample Proportion 2 >, <Sample Size 2>, <Confidence Level> )",
        "commandBase": "ZProportion2Estimate",
        "description": "Calculates a Z confidence interval estimate of the difference between two proportions using the given sample statistics and confidence level. Results are returned in list form as {lower confidence limit, upper confidence limit}.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Solve( <Equation in x> ), Solve( <Equation>, <Variable> ), Solve( <Equation in x>, <Assumption> ), Solve( <List of Equations>, <List of Variables> ), Solve( <Equation>, <Variable>, <List of assumptions> ), Solve( <List of Parametric Equations>, <List of Variables> )",
        "commandBase": "Solve",
        "description": "Commands Solve and Solutions solve an equation or a system of equations over the real numbers symbolically. To solve equations numerically, use the NSolve Command. For solving equations in complex numbers see CSolve Command.",
        "examples": [
            {
                "description": "Solves a given equation for the main variable and returns a list of all solutions.",
                "command": "Solve(x^2 = 4x)"
            },
            {
                "description": "Solves an equation for a given unknown variable and returns a list of all solutions.",
                "command": "Solve(x * a^2 = 4a, a)"
            },
            {
                "description": "Solves an equation x, conditional on the assumption",
                "command": "Solve(x^2 = 1, x > 0)"
            },
            {
                "description": "Solves a set of equations for a given set of unknown variables and returns a list of all solutions.",
                "command": "Solve({x = 4 x + y, y + x = 2}, {x, y})"
            },
            {
                "description": "Solves an equation for a given unknown variable with the list of assumptions and returns a list of all solutions.",
                "command": "Solve(u * x < a, x, u > 0)"
            },
            {
                "description": "Solves a set of parametric equations for a given set of unknown variables and returns a list of all solutions.",
                "command": "Solve({(x, y) = (3, 2) + t*(5, 1), (x, y) = (4, 1) + s*(1, -1)}, {x, y, t, s})"
            }
        ],
        "note": "The right hand side of equations (in any of the above syntaxes) can be omitted. If the right hand side is missing, it is treated as 0. Sometimes you need to do some manipulation to allow the automatic solver to work, for example Solve(TrigExpand(sin(5/4 π + x) - cos(x - 3/4 π) = sqrt(6) * cos(x) - sqrt(2))). For piecewise-defined functions, you will need to use NSolve."
    },
    {
        "signature": "Barycenter( <List of Points>, <List of Weights> )",
        "commandBase": "Barycenter",
        "description": "Set the center of a system of points in the list, defined as the average of their positions, weighted by their value, using the proper formula (https://en.wikipedia.org/wiki/Center_of_mass).",
        "examples": [
            {
                "description": "Barycenter({(2, 0), (0, 2), (-2, 0), (0, -2)}, {1, 1, 1, 1}) yields point A(0, 0)",
                "command": "Barycenter({(2, 0), (0, 2), (-2, 0), (0, -2)}, {1, 1, 1, 1})"
            },
            {
                "description": "Barycenter({(2, 0), (0, 2), (-2, 0), (0, -2)}, {2, 1, 1, 1}) yields point B(0.4, 0). The _x_-coordinate of this point was determined by stem:[ \\frac{1}{ 2+1+1+1 }*(2*2+1*0+1*(-2)+1*0)] = stem:[\\frac{1}{ 5 }*2] = 0.4",
                "command": "Barycenter({(2, 0), (0, 2), (-2, 0), (0, -2)}, {2, 1, 1, 1})"
            }
        ],
        "note": "This command differs among variants of English: * Barycenter (US) * Barycentre (UK + Aus)"
    },
    {
        "signature": "RigidPolygon Command",
        "commandBase": "RigidPolygon",
        "description": "Creates a copy of any polygon that can only be translated by dragging its first vertex and rotated by dragging its second vertex. Creates a copy of any polygon with the given offset that can only be translated by dragging its first vertex and rotated by dragging its second vertex. Creates polygon whose shape cannot be changed. This polygon can be translated by dragging its first vertex and rotated by dragging its second vertex.",
        "examples": [
            {
                "description": "Creates a copy of any polygon that can only be translated by dragging its first vertex and rotated by dragging its second vertex.",
                "command": "RigidPolygon( <Polygon> )"
            },
            {
                "description": "Creates a copy of any polygon with the given offset that can only be translated by dragging its first vertex and rotated by dragging its second vertex.",
                "command": "RigidPolygon( <Polygon>, <Offset x>, <Offset y> )"
            },
            {
                "description": "Creates polygon whose shape cannot be changed. This polygon can be translated by dragging its first vertex and rotated by dragging its second vertex.",
                "command": "RigidPolygon( <Free Point>, ..., <Free Point> )"
            }
        ],
        "note": "The copy will join in every change of the original polygon. If you want to change the shape of the copy, you have to change the original."
    },
    {
        "signature": "SelectedIndex( <List> )",
        "commandBase": "SelectedIndex",
        "description": "Returns the index of the selected element of a drop-down list.",
        "examples": [
            {
                "description": "See also SelectedElement command",
                "command": ""
            },
            {
                "description": "Set n as the index of the selected element in the drop-down list.",
                "command": "SetValue( <drop-down list>, <Number n > )"
            }
        ],
        "note": ""
    },
    {
        "signature": "InverseWeibull( <Shape>, <Scale>, <Probability> )",
        "commandBase": "InverseWeibull",
        "description": "Evaluates the inverse of the cumulative distribution function of a Weibull distribution at given p, where the Weibull distribution is defined by the given parameters shape and scale. In other words, it finds t such that P(X ≤ t) = p, where X is a random variable with Weibull distribution. Probability p must be a value in the closed interval [0,1].",
        "examples": [],
        "note": ""
    },
    {
        "signature": "ReadText( <Text> ):",
        "commandBase": "ReadText",
        "description": "This command allows authors to include information for visually impaired users, making their applets more accessible. To hear the output you need to install a screen reader such as NVDA (https://www.nvaccess.org/download/) or VoiceOver. Currently it is only supported in the online version of GeoGebra.",
        "examples": [],
        "note": "Tells the screen reader to read given text immediately."
    },
    {
        "signature": "InversePascal( <n>, <p>, <Probability> )",
        "commandBase": "InversePascal",
        "description": "Returns least integer n such that P(X≤n) ≥ p, where p is the probability and X is Pascal random variable (https://en.wikipedia.org/wiki/Negative_binomial_distribution) given by n and p.",
        "examples": [],
        "note": "See also Pascal Command."
    },
    {
        "signature": "IsPrime( <Number> )",
        "commandBase": "IsPrime",
        "description": "Gives true or false depending on whether the number is prime or not.",
        "examples": [
            {
                "description": "Check if 10 is prime",
                "command": "IsPrime(10)"
            },
            {
                "description": "Check if 11 is prime",
                "command": "IsPrime(11)"
            }
        ],
        "note": "The command is available in both standard and CAS syntax, with examples showing it yields false for 10 and true for 11."
    },
    {
        "signature": "SemiMinorAxisLength( <Conic> )",
        "commandBase": "SemiMinorAxisLength",
        "description": "Returns the length of the semiminor axis (half of the minor axis) of the conic section.",
        "examples": [
            {
                "description": "Calculate the semiminor axis length for a given conic equation",
                "command": "SemiMinorAxisLength(x2 + 2y2 - 2x - 4y = 5)"
            }
        ],
        "note": "See also SemiMajorAxisLength command."
    },
    {
        "signature": "RandomPolynomial( <Degree> , <Minimum for Coefficients>, <Maximum for Coefficients> )",
        "commandBase": "RandomPolynomial",
        "description": "Returns a randomly generated polynomial in x of degree d, whose (integer) coefficients are in the range from minimum to maximum, both included.",
        "examples": [
            {
                "description": "RandomPolynomial(0, 1, 2) yields either 1 or 2.",
                "command": "RandomPolynomial(0, 1, 2)"
            },
            {
                "description": "RandomPolynomial(2, 1, 2) yields a random polynomial with a degree of two and only 1 and 2 as coefficients, for example 2x2 + x + 1.",
                "command": "RandomPolynomial(2, 1, 2)"
            }
        ],
        "note": "In both cases if minimum or maximum are not integers, round(minimum) and round(maximum) are used instead."
    },
    {
        "signature": "IndexOf( <Object>, <List> ), IndexOf( <Object>, <List>, <Start Index> ), IndexOf( <Text>, <Text> ), IndexOf( <Text>, <Text>, <Start Index> )",
        "commandBase": "IndexOf",
        "description": "Returns position of first occurrence of Object in List or Text in Text.",
        "examples": [
            {
                "description": "Find first occurrence of 5 in list",
                "command": "IndexOf(5, {1, 3, 5, 2, 5, 4})"
            },
            {
                "description": "Find first occurrence of 5 in list starting at index 3",
                "command": "IndexOf(5, {1, 3, 5, 2, 5, 4}, 3)"
            },
            {
                "description": "Find first occurrence of 5 in list starting at index 4",
                "command": "IndexOf(5, {1, 3, 5, 2, 5, 4}, 4)"
            },
            {
                "description": "Find first occurrence of 5 in list starting at index 6",
                "command": "IndexOf(5, {1, 3, 5, 2, 5, 4}, 6)"
            },
            {
                "description": "Find first occurrence of 'Ge' in text",
                "command": "IndexOf(\"Ge\", \"GeoGebra\")"
            },
            {
                "description": "Find first occurrence of 'Ge' in text starting at index 2",
                "command": "IndexOf(\"Ge\", \"GeoGebra\", 2)"
            }
        ],
        "note": "When the object is not found, result is undefined."
    },
    {
        "signature": "Sample( <List>, <Size> )\nSample( <List>, <Size>, <With Replacement> )",
        "commandBase": "Sample",
        "description": "Returns list of n randomly chosen elements of a list; elements can be chosen several times.",
        "examples": [
            {
                "description": "Sample with default replacement behavior",
                "command": "Sample({1, 2, 3, 4, 5}, 5)"
            },
            {
                "description": "Sample with explicit replacement parameter",
                "command": "Sample({1, 2, 3, 4, 5}, 5, true)"
            },
            {
                "description": "Sample with mixed types in CAS View",
                "command": "Sample({-5, 2, a, 7, c}, 3)"
            },
            {
                "description": "Sample with lists included and without replacement",
                "command": "Sample({List1, 4, 5, 6, 7, 8}, 3, false)"
            }
        ],
        "note": "In the CAS View the input list can contain different types of objects, including lists. Elements can be chosen several times if and only if the last parameter is true."
    },
    {
        "signature": "CrossRatio( <Point A>, <Point B>, <Point C>, <Point D> )",
        "commandBase": "CrossRatio",
        "description": "Calculates the cross ratio λ of four collinear points A, B, C and D, where: λ = AffineRatio[B, C, D] / AffineRatio[A, C, D].",
        "examples": [
            {
                "description": "CrossRatio((-1, 1), (1, 1), (3, 1), (4, 1)) yields 1.2",
                "command": "CrossRatio((-1, 1), (1, 1), (3, 1), (4, 1))"
            }
        ],
        "note": ""
    },
    {
        "signature": "ContingencyTable( <List of Text>, <List of Text> )\nContingencyTable( <List of Text>, <List of Text>, <Options> )\nContingencyTable( <List of Row Values>, <List of Column Values>, <Frequency Table> )\nContingencyTable( <List of Row Values>, <List of Column Values>, <Frequency Table>, <Options> )",
        "commandBase": "ContingencyTable",
        "description": "Draws a Contingency Table (https://en.wikipedia.org/wiki/Contingency_table) created from the given lists. Unique values from the first list are used as row values, and unique values from the second list are used as column values. Options control the display of optional calculations within the table.",
        "examples": [
            {
                "description": "Draws a Contingency Table from two lists of text values.",
                "command": "ContingencyTable( <List of Text>, <List of Text> )"
            },
            {
                "description": "Draws a Contingency Table from two lists of text values with options for calculations.",
                "command": "ContingencyTable( <List of Text>, <List of Text>, <Options> )"
            },
            {
                "description": "Draws a Contingency Table using given row values, column values, and a frequency table.",
                "command": "ContingencyTable({\"Males\",\"Females\"},{\"Right-handed\", \"Left-handed\"},{{43,9},{44,4}})"
            },
            {
                "description": "Draws a Contingency Table with a frequency table and options, showing row percentages.",
                "command": "ContingencyTable({\"Males\",\"Females\"},{\"Right-handed\", \"Left-handed\"},{{43,9},{44,4}},\"_\")"
            }
        ],
        "note": "Possible values for Options are \"|\", \"_\", \"+\", \"e\", \"k\", \"=\". \"|\" = show column percentages, \"_\" = show row percentages, \"+\" = show total percentages, \"e\" = show expected counts, \"k\" = show Chi Squared contributions, \"=\" = show results of a Chi Squared test."
    },
    {
        "signature": "Voronoi( <List of Points> )",
        "commandBase": "Voronoi",
        "description": "Draws the Voronoi diagram (https://en.wikipedia.org/wiki/Voronoi_diagram) for given list of points. Returned object is a locus, so it is auxiliary.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "BetaDist( <Number α>, <Number β>, <Variable value> )\nBetaDist( <Number α>, <Number β>, <Variable value>, <Boolean Cumulative> )\nBetaDist( <Number α>, <Number β>, x, <Boolean Cumulative> )",
        "commandBase": "BetaDist",
        "description": "Calculates the value of the cumulative distribution function of a Beta distribution with parameters α, β at the variable value v, that is the probability P(X≤v) where X is a random variable with a beta distribution with parameters α and β. If Cumulative is true, calculates the value of the cumulative distribution function of a Beta distribution with parameters α and β at the variable value v. If Cumulative is false, it calculates the value of the probability density function (pdf) of the corresponding beta distribution at v. If Cumulative is true, creates the cumulative distribution function of a beta distribution with parameters α and β, otherwise it creates the probability density function (pdf) of the corresponding Beta distribution.",
        "examples": [],
        "note": "See also InverseBeta command."
    },
    {
        "signature": "Curve( <Expression>, <Expression>, <Parameter Variable>, <Start Value>, <End Value> ) or Curve( <Expression>, <Expression>, <Expression>, <Parameter Variable>, <Start Value>, <End Value> )",
        "commandBase": "Curve",
        "description": "Yields the Cartesian parametric curve for the given expressions using a parameter variable within a specified interval. Supports 2D (with x and y expressions) and 3D (with x, y, and z expressions) curves.",
        "examples": [
            {
                "description": "Creates a circle with radius 2 around the origin of the coordinate system.",
                "command": "Curve(2 cos(t), 2 sin(t), t, 0, 2π)"
            },
            {
                "description": "Creates a 3D spiral.",
                "command": "Curve(cos(t), sin(t), t, t, 0, 10π)"
            }
        ],
        "note": "End Value must be greater than or equal to Start Value and both must be finite. x, y and z are not allowed as parameter variables. See Curves for details, also see the Derivative Command and the Parametric Derivative Command."
    },
    {
        "signature": "Sphere( <Point>, <Radius> ) or Sphere( <Point>, <Point> )",
        "commandBase": "Sphere",
        "description": "Creates a sphere with center and radius, or with center in the first point through the second point.",
        "examples": [
            {
                "description": "Creates a sphere with center and radius.",
                "command": "Sphere( <Point>, <Radius> )"
            },
            {
                "description": "Creates a sphere with center in the first point through the second point.",
                "command": "Sphere( <Point>, <Point> )"
            },
            {
                "description": "Sphere((0, 0, 0), (1, 1, 1)) yields x² + y² + z² = 3",
                "command": "Sphere((0, 0, 0), (1, 1, 1))"
            }
        ],
        "note": "See also Sphere with Center through Point Tool and Sphere with Center and Radius Tool."
    },
    {
        "signature": "SD( <List of Raw Data> ) or SD( <List of Numbers>, <List of Frequencies> ), with equivalent syntax stdevp",
        "commandBase": "SD",
        "description": "Calculates the standard deviation of numbers in a list, with an option for weighted standard deviation using frequencies.",
        "examples": [
            {
                "description": "Calculate standard deviation of a list of numbers",
                "command": "SD({1, 2, 3, 4, 5})"
            },
            {
                "description": "Calculate weighted standard deviation with frequencies",
                "command": "SD({1, 2, 3, 4, 5}, {5, 4, 3, 2, 1})"
            },
            {
                "description": "Equivalent syntax using stdevp for standard deviation",
                "command": "stdevp({1, 2, 3, 4, 5})"
            },
            {
                "description": "Equivalent syntax using stdevp for weighted standard deviation",
                "command": "stdevp({1, 2, 3, 4, 5}, {5, 4, 3, 2, 1})"
            }
        ],
        "note": "This command has equivalent syntax stdevp. See also Mean Command."
    },
    {
        "signature": "ShowLayer( <Number> )",
        "commandBase": "ShowLayer",
        "description": "Makes all objects in given layer visible. Does not override Conditional Visibility.",
        "examples": [
            {
                "description": "ShowLayer(2) makes all objects in the second layer visible.",
                "command": "ShowLayer(2)"
            }
        ],
        "note": ""
    },
    {
        "signature": "GroebnerLex( <List of Polynomials> )\nGroebnerLex( <List of Polynomials>, <List of Variables> )",
        "commandBase": "GroebnerLex",
        "description": "Computes the Gröbner basis of the list of the polynomials with respect to lexicographical ordering of the variables (also known as lex, plex or pure lexical ordering).",
        "examples": [
            {
                "description": "Computes the Gröbner basis of the list of the polynomials with respect to lexicographical ordering of the variables",
                "command": "GroebnerLex({x3-y-2,x2+y+1}) yields {stem:[ y{3} + 4 y{2} + 7 y + 5, x - y{2} - 3 y - 3 ]}"
            },
            {
                "description": "Computes the Gröbner basis of the list of the polynomials with respect to lexicographical ordering of the given variables",
                "command": "GroebnerLex({x3-y-2,x2+y+1},{y,x}) yields {stem:[ -x{3} - x{2} + 1, -y - x{2} - 1 ]}"
            }
        ],
        "note": "See also GroebnerDegRevLex and GroebnerLexDeg commands."
    },
    {
        "signature": "ZProportionEstimate ( <Sample Proportion >, <Sample Size >, <Confidence Level> )",
        "commandBase": "ZProportionEstimate",
        "description": "Calculates a Z confidence interval estimate of a population proportion using the given sample statistics and confidence level. Results are returned in list form as {lower confidence limit, upper confidence limit}.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "BinomialDist( <Number of Trials>, <Probability of Success> )\nBinomialDist( <Number of Trials>, <Probability of Success>, <Boolean Cumulative> )\nBinomialDist( <Number of Trials>, <Probability of Success>, <Variable Value>, <Boolean Cumulative> )\nBinomialDist( <Number of Trials>, <Probability of Success>, <List of values> )",
        "commandBase": "BinomialDist",
        "description": "Returns a histogram or graph of a Binomial distribution, or calculates probabilities for a Binomial random variable, based on the number of trials and probability of success, with optional parameters for cumulative distribution, variable values, or lists of values.",
        "examples": [
            {
                "description": "Calculate probability of exactly one success in 10 trials with success probability 0.2",
                "command": "BinomialDist(10, 0.2, 1, false)"
            },
            {
                "description": "Calculate cumulative probability of at most two successes in 3 trials with success probability 0.9",
                "command": "BinomialDist(3, 0.9, 2, true)"
            },
            {
                "description": "Calculate probability of successes in a range using a list of values",
                "command": "BinomialDist(10, 0.2, {1,2,3})"
            },
            {
                "description": "Plot a graph of cumulative probabilities difference",
                "command": "f(x):=BinomialDist(100,x,36,true)-BinomialDist(100,x,23,true)"
            }
        ],
        "note": "The syntax BinomialDist(10, 0.2, {1,2,3}) is equivalent to BinomialDist(10, 0.2, 1..3). Ensure parameters are within valid ranges (e.g., probability between 0 and 1, non-negative integer trials)."
    },
    {
        "signature": "IntegralSymbolic(<Function>)",
        "commandBase": "IntegralSymbolic",
        "description": "Gives the indefinite symbolic integral with respect to the main variable. The constant of integration c is not shown automatically as a slider.",
        "examples": [
            {
                "description": "IntegralSymbolic(3x2) yields stem:[x3+c_{1}].",
                "command": "IntegralSymbolic(3x2)"
            }
        ],
        "note": "IntegralSymbolic(<Function>, <Variable>): Gives the partial symbolic integral with respect to the given variable. The constant of integration c is not shown automatically as a slider. Example: IntegralSymbolic(x³+3x y, x) gives _stem:[ \\frac{1}{4}x4] + stem:[\\frac{3}{2} x² y+c_{1} ]_."
    },
    {
        "signature": "AffineRatio( <Point A>, <Point B>, <Point C> )",
        "commandBase": "AffineRatio",
        "description": "Returns the affine ratio λ of three collinear points A, B and C, where C = A + λ * AB.",
        "examples": [
            {
                "description": "AffineRatio((-1, 1), (1, 1), (4, 1)) yields 2.5",
                "command": "AffineRatio((-1, 1), (1, 1), (4, 1))"
            }
        ],
        "note": ""
    },
    {
        "signature": "IntersectConic( <Plane>, <Quadric> )\nIntersectConic( <Quadric>, <Quadric> )",
        "commandBase": "IntersectConic",
        "description": "Intersects the plane with the quadric. Returns a conic defined in case where the intersection is actually a conic.",
        "examples": [
            {
                "description": "IntersectConic(sphere1, sphere2) creates the intersection conic of two spheres.",
                "command": "IntersectConic(sphere1, sphere2)"
            }
        ],
        "note": "See also Intersect and IntersectPath commands."
    },
    {
        "signature": "PreviousPrime( <Number> ):",
        "commandBase": "PreviousPrime",
        "description": "Returns the greatest prime smaller than the entered number.",
        "examples": [
            {
                "description": "PreviousPrime(10000) yields 9973.",
                "command": "PreviousPrime(10000)"
            }
        ],
        "note": "See also NextPrime Command."
    },
    {
        "signature": "TrigExpand( <Expression> ) | TrigExpand( <Expression>, <Target Function> ) | TrigExpand( <Expression>, <Target Function>, <Target Variable> ) | TrigExpand( <Expression>, <Target Function>, <Target Variable>, <Target Variable> )",
        "commandBase": "TrigExpand",
        "description": "Expands trigonometric functions of a sum of variables into trigonometric functions of a single variable, or expands products of trigonometric functions into linear expressions. Can also expand into expressions containing specific target functions and variables.",
        "examples": [
            {
                "description": "Expand tan(x + y) into basic trigonometric functions",
                "command": "TrigExpand(tan(x + y))"
            },
            {
                "description": "Expand sin(x)sin(x/3) into linear expressions",
                "command": "TrigExpand(sin(x)sin(x/3))"
            },
            {
                "description": "Expand tan(x + y) with tan(x) as target function",
                "command": "TrigExpand(tan(x + y), tan(x))"
            },
            {
                "description": "Expand sin(x) with sin(x) as target function and x/2 as target variable",
                "command": "TrigExpand(sin(x), sin(x), x/2)"
            },
            {
                "description": "Expand sin(x)/(1+cos(x)) with tan(x) as target function and x/2 as target variable",
                "command": "TrigExpand(sin(x)/(1+cos(x)), tan(x), x/2)"
            },
            {
                "description": "Expand csc(x) - cot(x) + csc(y) - cot(y) with tan(x) as target function and x/2, y/2 as target variables",
                "command": "TrigExpand(csc(x) - cot(x) + csc(y) - cot(y), tan(x), x/2, y/2)"
            }
        ],
        "note": "CAS syntaxes may show different results depending on the selected output mode (e.g., Evaluate mode vs Numeric mode). Some commands are only available in the CAS View. See also TrigSimplify Command and TrigCombine Command."
    },
    {
        "signature": "ConvexHull( <List of Points> )",
        "commandBase": "ConvexHull",
        "description": "Creates convex hull of given set of points. Returned object is a locus, so it is auxiliary.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "SigmaYY( <List of Points> ):",
        "commandBase": "SigmaYY",
        "description": "Calculates the sum of squares of _y_-coordinates of the given points.",
        "examples": [
            {
                "description": "Let list = {(-3, 4), (-1, 4), (-2, 3), (1, 3), (2, 2), (1, 5)} be a list of points. SigmaYY(list) yields a 79.",
                "command": "SigmaYY({(-3, 4), (-1, 4), (-2, 3), (1, 3), (2, 2), (1, 5)})"
            }
        ],
        "note": ""
    },
    {
        "signature": "CircularSector( <Midpoint>, <Point A>, <Point B> )",
        "commandBase": "CircularSector",
        "description": "Creates a circular sector with midpoint between the two points.",
        "examples": [
            {
                "description": "CircularSector( <Midpoint>, <Point A>, <Point B> ): Creates a circular sector with midpoint between the two points.",
                "command": "CircularSector( <Midpoint>, <Point A>, <Point B> )"
            }
        ],
        "note": "• The sector area is displayed in Algebra View\n• Point B does not have to lie on the arc of the sector.\n• See also [Image: Mode circlesector3.svg,width=24,height=24] Circular Sector tool."
    },
    {
        "signature": "LeftSum( <Function>, <Start x-Value>, <End x-Value>, <Number of Rectangles> )",
        "commandBase": "LeftSum",
        "description": "Calculates the left sum of the function in the interval using n rectangles.",
        "examples": [
            {
                "description": "LeftSum(x2 + 1, 0, 2, 4) yields a = 3.75",
                "command": "LeftSum(x2 + 1, 0, 2, 4)"
            }
        ],
        "note": "• This command draws the rectangles of the left sum as well.\n• This command is designed as a visual aid so won't give accurate answers if the number of rectangles is too large.\n• See also the commands: RectangleSum, TrapezoidalSum, LowerSum and UpperSum."
    },
    {
        "signature": "FromBase(\"<Number as Text>\", <Base>)",
        "commandBase": "FromBase",
        "description": "Converts given number from given base (https://en.wikipedia.org/wiki/Radix) into decimal base. The base must be between 2 and 36. The number must be an integer.",
        "examples": [
            {
                "description": "Convert hexadecimal FF to decimal",
                "command": "FromBase(\"FF\", 16)"
            },
            {
                "description": "Convert binary 100000000 to decimal",
                "command": "FromBase(\"100000000\", 2)"
            }
        ],
        "note": "See also ToBase command"
    },
    {
        "signature": "GeometricMean(List of Numbers)",
        "commandBase": "GeometricMean",
        "description": "Returns the geometric mean (https://en.wikipedia.org/wiki/Geometric_mean) of given list of numbers.",
        "examples": [
            {
                "description": "GeometricMean({13, 7, 26, 5, 19}) yields 11.76.",
                "command": "GeometricMean({13, 7, 26, 5, 19})"
            }
        ],
        "note": ""
    },
    {
        "signature": "Vertex( <Conic> ) | Vertex( <Inequality> ) | Vertex( <Polygon> ) | Vertex( <Polygon>, <Index n> ) | Vertex( <Segment>, <Index> )",
        "commandBase": "Vertex",
        "description": "Returns vertices of geometric objects such as conic sections, inequalities, polygons, or segments, with variations based on input parameters.",
        "examples": [
            {
                "description": "Returns (all) vertices of the conic section.",
                "command": "Vertex( <Conic> )"
            },
            {
                "description": "Returns the points of intersection of the borders for an inequality.",
                "command": "Vertex( <Inequality> )"
            },
            {
                "description": "Example: Vertex((x + y < 3) && (x - y > 1)) returns point A = (2, 1).",
                "command": "Vertex((x + y < 3) && (x - y > 1))"
            },
            {
                "description": "Example: {Vertex((x + y < 3) ∧ (x - y > 1) && (y > - 2))} returns list1 = {(2, 1), (5, -2), (-1, -2)}.",
                "command": "{Vertex((x + y < 3) ∧ (x - y > 1) && (y > - 2))}"
            },
            {
                "description": "Example: Vertex((y > x²) ∧ (y < x)) returns two points A = (0, 0) and B = (1, 1).",
                "command": "Vertex((y > x²) ∧ (y < x))"
            },
            {
                "description": "Example: {Vertex((y > x²) ∧ (y < x))} returns list1 = {(0, 0), (1, 1)}.",
                "command": "{Vertex((y > x²) ∧ (y < x))}"
            },
            {
                "description": "Returns (all) vertices of the polygon.",
                "command": "Vertex( <Polygon> )"
            },
            {
                "description": "Returns _n_-th vertex of the polygon.",
                "command": "Vertex( <Polygon>, <Index n> )"
            },
            {
                "description": "Returns the start-point (Index = 1) or end-point (Index = 2) of the Segment.",
                "command": "Vertex( <Segment>, <Index> )"
            }
        ],
        "note": "To get the vertices of the objects polygon / conic / inequality in a list, use {Vertex(Object)}."
    },
    {
        "signature": "TMeanEstimate( <List of Sample Data>, <Confidence level> )",
        "commandBase": "TMeanEstimate",
        "description": "Calculates a t confidence interval estimate of a population mean using the given sample data and confidence level. Results are returned in list form as {lower confidence limit, upper confidence limit}.",
        "examples": [],
        "note": "This command has two signatures: one using raw sample data and confidence level, and another using sample statistics (mean, standard deviation, size) and confidence level."
    },
    {
        "signature": "RectangleSum( <Function>, <Start x-Value>, <End x-Value>, <Number of Rectangles>, <Position for rectangle start> )",
        "commandBase": "RectangleSum",
        "description": "Calculates between the Start x-Value and the End x-Value the sum of rectangles with left height starting at a fraction d (0 ≤ d ≤ 1) of each interval, using n rectangles. When d = 0 it is equivalent to the LeftSum command, and when d = 1 it computes the right sum of the given function.",
        "examples": [],
        "note": "• This command draws the rectangles of the left sum as well.\n• This command is designed as a visual aid so won't give accurate answers if the number of rectangles is too large.\n• See also the commands: UpperSum, LowerSum, LeftSum, TrapezoidalSum."
    },
    {
        "signature": "Normalize( <List of Numbers> ) or Normalize( <List of Points> )",
        "commandBase": "Normalize",
        "description": "Returns a list containing the normalized form of the given numbers or points, mapping values to the interval [0, 1] using the linear function x → (x - Min(list)) / (Max(list) - Min(list)).",
        "examples": [
            {
                "description": "Normalize a list of numbers",
                "command": "Normalize({1, 2, 3, 4, 5})"
            },
            {
                "description": "Normalize a list of points",
                "command": "Normalize({(1,5), (2,4), (3,3), (4,2), (5,1)})"
            }
        ],
        "note": "This command differs among variants of English: Normalize (US) and Normalise (UK + Aus). It might avoid rounding/overflow errors when using big or small numbers (e.g., in FitGrowth calculations), but is not applicable to 3D points."
    },
    {
        "signature": "LocusEquation( <Locus> ), LocusEquation( <Point Creating Locus Line Q>, <Point P> ), LocusEquation( <Boolean Expression>, <Free Point> )",
        "commandBase": "LocusEquation",
        "description": "Calculates the equation of a Locus and plots this as an Implicit Curve. It supports three signatures: for a locus, for tracer and mover points, and for a boolean condition with a free point.",
        "examples": [
            {
                "description": "Construct a parabola as a locus using points A, B, F, P, and Q, where Q is the intersection of lines p and b.",
                "command": "LocusEquation(Q,P)"
            },
            {
                "description": "Calculate the set of positions of free point A that make points A, B, and C collinear, resulting in a line through B and C.",
                "command": "LocusEquation(AreCollinear(A, B, C), A)"
            }
        ],
        "note": "The Locus must be made from a Point (not from a Slider). Works only for a restricted set of geometric loci (points, lines, circles, conics; rays and line segments treated as infinite lines). If too complicated, returns 'undefined'. If no locus, implicit curve is 0=1. If whole plane, implicit curve is 0=0. Uses Gröbner bases, which may introduce extra branches. Further info and examples on geogebra.org, including a collection at https://www.geogebra.org/m/mbXQuvUV. See also Locus command and GeoGebra Automated Reasoning Tools tutorial."
    },
    {
        "signature": "Cross( <Vector u> , <Vector v> )",
        "commandBase": "Cross",
        "description": "Calculates the cross product of u and v. Instead of vectors you can also use lists.",
        "examples": [
            {
                "description": "Cross product of 3D vectors (1, 3, 2) and (0, 3, -2)",
                "command": "Cross((1, 3, 2), (0, 3, -2))"
            },
            {
                "description": "Cross product of 3D vectors {1, 1, 1} and {-1, -1, -1}",
                "command": "Cross({1, 1, 1}, {-1, -1, -1})"
            },
            {
                "description": "Cross product of 2D vectors (1,2) and (4,5), yielding the z-coordinate",
                "command": "Cross((1,2),(4,5))"
            }
        ],
        "note": "If a vector in the CAS View contains undefined variables, the command yields a formula for the cross product, e.g., Cross((a, b, c), (d, e, f)) yields (b f - c e, -a f + c d, a e - b d). You can also use the operator u ⊗ v. See also Dot Command."
    },
    {
        "signature": "SetTooltipMode( <Object>, <Number> )",
        "commandBase": "SetTooltipMode",
        "description": "Changes the tooltip mode for given object according to following table (values out of range [0,4] are treated as 0).",
        "examples": [],
        "note": "Tooltip modes: 0 = Automatic, 1 = On, 2 = Off, 3 = Caption, 4 = Next cell."
    },
    {
        "signature": "TextToUnicode(\"<Text>\")",
        "commandBase": "TextToUnicode",
        "description": "Turns the text into a list of Unicode numbers, one for each character.",
        "examples": [
            {
                "description": "TextToUnicode(\"Some text\") gives you the list of Unicode numbers {83, 111, 109, 101, 32, 116, 101, 120, 116}.",
                "command": "TextToUnicode(\"Some text\")"
            },
            {
                "description": "If text1 is \"hello\", then TextToUnicode(text1) gives you the list of Unicode numbers {104, 101, 108, 108, 111}.",
                "command": "TextToUnicode(text1)"
            }
        ],
        "note": "See also UnicodeToText Command and LetterToUnicode Command."
    },
    {
        "signature": "CircularArc( <Midpoint>, <Point A>, <Point B> )",
        "commandBase": "CircularArc",
        "description": "Creates a circular arc with midpoint between the two points.",
        "examples": [
            {
                "description": "Creates a circular arc with midpoint between the two points.",
                "command": "CircularArc( <Midpoint>, <Point A>, <Point B> )"
            }
        ],
        "note": "The arc length is displayed in Algebra View. Point B does not have to lie on the arc. See also Circular Arc tool."
    },
    {
        "signature": "MeanY( <List of Points> )",
        "commandBase": "MeanY",
        "description": "Calculates the mean of the _y_-coordinates of the points in the list.",
        "examples": [
            {
                "description": "MeanY({(0,0), (3,2), (5,1), (2,1), (2,4)}) yields 1.6",
                "command": "MeanY({(0,0), (3,2), (5,1), (2,1), (2,4)})"
            }
        ],
        "note": ""
    },
    {
        "signature": "SelectObjects( ) | SelectObjects( <Object>, <Object>, ... )",
        "commandBase": "SelectObjects",
        "description": "Deselects all selected objects. If objects are provided as parameters, it deselects all objects and selects the specified objects, which must be labeled objects.",
        "examples": [
            {
                "description": "Let A, B and C be points. SelectObjects(A, B, C) selects points A, B and C.",
                "command": "SelectObjects(A, B, C)"
            },
            {
                "description": "The command SelectObjects(Midpoint(A, B)) has no effect, besides deselecting all selected objects.",
                "command": "SelectObjects(Midpoint(A, B))"
            }
        ],
        "note": "This command now cancels any drag that is in progress (useful in scripts)."
    },
    {
        "signature": "InverseCauchy( <Median>, <Scale>, <Probability> )",
        "commandBase": "InverseCauchy",
        "description": "Computes the inverse of the cumulative distribution function of a Cauchy distribution (https://en.wikipedia.org/wiki/Cauchy_distribution) at probability p, where the Cauchy distribution is defined by parameters median and scale. In other words, finds t such that P(X ≤ t) = p, where X is a Cauchy random variable. Probability p must be a value in the closed interval [0,1].",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Segment( <Point>, <Point> ): Creates a segment between two points. Segment( <Point>, <Length> ): Creates a segment with the given starting point and length, as well as the end point of the segment.",
        "commandBase": "Segment",
        "description": "Creates a segment between two points or from a point with a specified length.",
        "examples": [
            {
                "description": "This command differs among variants of English: Interval (Aus), Segment (UK + US).",
                "command": "Segment( <Point>, <Point> )"
            }
        ],
        "note": "When computing intersections with other objects, only intersections lying on the segment are considered. To change this, you can use Outlying Intersections option. See also Segment and Segment_with_Given_Length tools."
    },
    {
        "signature": "Logistic( <Mean>, <Scale>, <Variable Value> )",
        "commandBase": "Logistic",
        "description": "Evaluates the cumulative distribution function of a logistic distribution at variable value v, i.e. calculates the probability P(X ≤ v) where X is a random variable with a logistic distribution defined by the given parameters mean and scale.",
        "examples": [
            {
                "description": "Evaluates the cumulative distribution function of a logistic distribution at a given variable value.",
                "command": "Logistic( <Mean>, <Scale>, <Variable Value> )"
            },
            {
                "description": "Evaluates the cumulative distribution function or probability density function of a logistic distribution based on the Boolean Cumulative parameter.",
                "command": "Logistic( <Mean>, <Scale>, <Variable Value>, <Boolean Cumulative> )"
            },
            {
                "description": "Creates the cumulative density function or probability density function of a logistic distribution based on the Boolean Cumulative parameter.",
                "command": "Logistic( <Mean>, <Scale>, x, <Boolean Cumulative> )"
            }
        ],
        "note": "This syntax returns the probability at a given value, that is the area under the logistic distribution curve to the left of the given x-coordinate."
    },
    {
        "signature": "Factors( <Polynomial> ) or Factors( <Number> )",
        "commandBase": "Factors",
        "description": "Gives a list of lists of the type {factor, exponent} for polynomials or a matrix of prime factors with exponents for numbers, representing the factorization.",
        "examples": [
            {
                "description": "Factor a polynomial",
                "command": "Factors(x^8 - 1)"
            },
            {
                "description": "Factor a number",
                "command": "Factors(1024)"
            },
            {
                "description": "Factor a number with multiple prime factors",
                "command": "Factors(42)"
            },
            {
                "description": "Factor a polynomial with undefined variables in CAS View",
                "command": "Factors(a^8 - 1)"
            }
        ],
        "note": "Not all factors are irreducible over the reals. See also PrimeFactors Command and Factor Command. In the CAS View, undefined variables can be used as input and results are returned as proper matrices."
    },
    {
        "signature": "Assume( <Condition>, <Expression> )",
        "commandBase": "Assume",
        "description": "Evaluates the expression according to the condition",
        "examples": [
            {
                "description": "Assume(a > 0, Integral(exp(-a x), 0, infinity)) yields 1 / a.",
                "command": "Assume(a > 0, Integral(exp(-a x), 0, infinity))"
            },
            {
                "description": "Assume(x>0 && n>0, Solve(log(n2*(x/n)lg(x))=log(x2), x)) yields {x = 100, x = n}",
                "command": "Assume(x>0 && n>0, Solve(log(n2*(x/n)lg(x))=log(x2), x))"
            },
            {
                "description": "Assume(x<2,Simplify(sqrt(x-2sqrt(x-1)))) yields -sqrt(x - 1) + 1",
                "command": "Assume(x<2, Simplify(sqrt(x-2sqrt(x-1))))"
            },
            {
                "description": "Assume(x>2,Simplify(sqrt(x-2sqrt(x-1)))) yields sqrt(x - 1) - 1",
                "command": "Assume(x>2, Simplify(sqrt(x-2sqrt(x-1))))"
            },
            {
                "description": "Assume(k>0, Extremum(k*3*x2/4-2*x/2)) yields stem:[ \\left\\{ \\left(\\frac{2}{3 k}, -\\frac{1}{3 k} \\right)\\right\\} ]",
                "command": "Assume(k>0, Extremum(k*3*x2/4-2*x/2))"
            },
            {
                "description": "Assume(k>0, InflectionPoint(0.25 k x3 - 0.5x2 + k)) yields stem:[ \\left\\{ \\left(\\frac{2}{3 k}, \\frac{27k{3} - 4}{27 k{2}} \\right) \\right\\} ]",
                "command": "Assume(k>0, InflectionPoint(0.25 k x3 - 0.5x2 + k))"
            }
        ],
        "note": "See also Solve Command."
    },
    {
        "signature": "PointList( <List> )",
        "commandBase": "PointList",
        "description": "Creates list of points from a list of two-element lists.",
        "examples": [
            {
                "description": "PointList({{1,2},{3,4}}) returns {(1,2),(3,4)}",
                "command": "PointList({{1,2},{3,4}})"
            }
        ],
        "note": ""
    },
    {
        "signature": "IterationList( <Function>, <Start Value>, <Number of Iterations> )",
        "commandBase": "IterationList",
        "description": "Gives you a list of length n+1 (n = number of iterations) whose elements are iterations of the function starting with the start value.",
        "examples": [
            {
                "description": "After defining f(x) = x^2 the command IterationList(f, 3, 2) gives you the list {3, 9, 81}.",
                "command": "IterationList(f, 3, 2)"
            },
            {
                "description": "Define f(k,a)=(k+1)*a, which corresponds to the recursive definition of factorial. The command IterationList(f, {3, 6}, 4) gives you the list {6, 24, 120, 720, 5040}.",
                "command": "IterationList(f, {3, 6}, 4)"
            },
            {
                "description": "Let A, B be points. The command IterationList(Midpoint(A, C), C, {B}, 3) yields {C0, C1, C2, C3}. Hence for A = (0,0) and B = (8,0) the result will be {(8,0), (4,0), (2,0), (1,0)}.",
                "command": "IterationList(Midpoint(A, C), C, {B}, 3)"
            },
            {
                "description": "Let f_0, f_1 be numbers. IterationList(a + b, a, b, {f_0, f_1}, 5) for f_0 = f_1 = 1 the result will be {1, 1, 2, 3, 5, 8}.",
                "command": "IterationList(a + b, a, b, {f_0, f_1}, 5)"
            }
        ],
        "note": "Only the first syntax is supported in the CAS currently. See also Iteration Command."
    },
    {
        "signature": "SetActiveView( <View> )",
        "commandBase": "SetActiveView",
        "description": "Makes given View active.",
        "examples": [],
        "note": "• 1 or \"G\" for Graphics View\n• 2 or \"D\" for Graphics View 2\n• -1 or \"T\" for 3D Graphics View\n• \"A\" for Algebra View\n• \"S\" for Spreadsheet View\n• \"C\" for CAS View\n[NOTE] See also ZoomIn, ZoomOut, Pan, SetPerspective commands."
    },
    {
        "signature": "AreEqual( <Object>, <Object> )",
        "commandBase": "AreEqual",
        "description": "Decides if the objects are equal. Normally this command computes the result numerically. This behavior can be changed by using the Prove command.",
        "examples": [
            {
                "description": "AreEqual(Circle((0, 0),1),x2+y2=1) yields true since the two circles have the same center and radius.",
                "command": "AreEqual(Circle((0, 0),1),x2+y2=1)"
            },
            {
                "description": "AreEqual(Segment((1, 2), (3, 4)), Segment((3, 4), (1, 6))) is different from Segment((1, 2), (3, 4)) == Segment((3, 4), (1, 6)) as the latter compares just the lengths",
                "command": "AreEqual(Segment((1, 2), (3, 4)), Segment((3, 4), (1, 6)))"
            }
        ],
        "note": "See also AreCollinear, AreConcyclic, AreConcurrent, AreCongruent, ArePerpendicular, AreParallel, IsTangent commands."
    },
    {
        "signature": "Coefficients( <Polynomial> )",
        "commandBase": "Coefficients",
        "description": "Yields the list of all coefficients [a_k, a_{k-1}, ..., a_1, a_0] of the polynomial a_k x^k + a_{k-1} x^{k-1} + ... + a_1 x + a_0.",
        "examples": [
            {
                "description": "Coefficients of a polynomial",
                "command": "Coefficients(x^3 - 3 x^2 + 3 x)"
            },
            {
                "description": "Coefficients of a polynomial with specified variable",
                "command": "Coefficients(a^3 - 3 a^2 + 3 a, a)"
            },
            {
                "description": "Coefficients with different variable",
                "command": "Coefficients(a^3 - 3 a^2 + 3 a, x)"
            }
        ],
        "note": "For non-polynomial curves obtained using fitting commands (e.g., f(x) = FitExp(l1)), Coefficients(f) returns the list of calculated parameters. For conics, returns coefficients a, b, c, d, e, f of standard form a·x² + b·y² + c + d·x·y + e·x + f·y = 0. For lines in implicit form l: ax + by + c = 0, use x(l), y(l), z(l) to get individual coefficients."
    },
    {
        "signature": "ZMeanTest( <List of Sample Data>, <σ>, <Hypothesized Mean>, <Tail> )",
        "commandBase": "ZMeanTest",
        "description": "Performs a one sample Z test of a population mean using the given list of sample data and the population standard deviation. Hypothesized Mean is the population mean assumed in the null hypothesis. Tail has possible values \"<\", \">\" , \"≠\". These specify the alternative hypothesis as follows: \"<\" = population mean < Hypothesized Mean, \">\" = population mean > Hypothesized Mean, \"≠\" = population mean ≠ Hypothesized Mean. Results are returned in list form as {Probability value, Z test statistic}.",
        "examples": [],
        "note": "This command has two signatures: one using raw sample data and another using sample statistics. The second signature is: ZMeanTest( <Sample Mean>, <σ>, <Sample Size>, <Hypothesized Mean>, <Tail> ) which performs a one sample Z test using given sample statistics and population standard deviation, returning results as {Probability value, Z test statistic}."
    },
    {
        "signature": "RootList( <List> )",
        "commandBase": "RootList",
        "description": "Converts a given list of numbers {a1,a2,...,an} to a list of points {(a1,0),(a2,0),...,(an,0)}, which is also displayed in the Graphics View.",
        "examples": [
            {
                "description": "Convert a list of numbers to points on the x-axis",
                "command": "RootList({3, 4, 5, 2, 1, 3})"
            }
        ],
        "note": "The result is displayed in the Graphics View."
    },
    {
        "signature": "Net( <Polyhedron> , <Number> )",
        "commandBase": "Net",
        "description": "Creates the net of a convex polyhedron, on the plane containing the face used for its construction. The number is used to define the progress of the unfolding procedure, and needs to be between 0 and 1. The net is totally unfold when the given number is 1.",
        "examples": [
            {
                "description": "The net of a cube is displayed as Latin cross.",
                "command": "Net( <Polyhedron>, <Number>, <Face>, <Edge>, <Edge>, ... )"
            },
            {
                "description": "To explore the different configurations of the net of a cube, see this example file (http://geogebra.org/material/show/id/136596) on GeoGebra.",
                "command": "Net( <Polyhedron>, <Number>, <Face>, <Edge>, <Edge>, ... )"
            }
        ],
        "note": "Applicable only to cubes (for the moment), allows you to create different nets of a cube, by specifying the face and edges that need to be cut to create the net. See also [Image: Mode net.svg,width=24,height=24] Net tool."
    },
    {
        "signature": "FractionText(<Number>) | FractionText(<Point>) | FractionText(<Number>, <Boolean Single fraction>)",
        "commandBase": "FractionText",
        "description": "Creates and shows in the Graphics View a LaTeX text containing the fraction form of the given number or point coordinates. For numbers with a boolean parameter, it controls the position of a negative sign in the fraction display.",
        "examples": [
            {
                "description": "Given line a: y = 1.5 x + 2, FractionText(Slope(a)) creates the LaTeX text stem:[\\frac{3}{2}].",
                "command": "FractionText(Slope(a))"
            },
            {
                "description": "Given point A=(1.33,0.8), FractionText(A) creates the LaTeX text stem:[ \\left( \\frac{133}{100} ,\\frac{4}{5} \\right) ].",
                "command": "FractionText(A)"
            },
            {
                "description": "Given the number n = -0.8, FractionText(n, true) creates the LaTeX text stem:[\\frac{- 4}{5}].",
                "command": "FractionText(n, true)"
            },
            {
                "description": "Given the number n = -0.8, FractionText(n, false) creates the LaTeX text stem:[-\\frac{4}{5}].",
                "command": "FractionText(n, false)"
            }
        ],
        "note": "See also SurdText command."
    },
    {
        "signature": "CopyFreeObject( <Object> ):",
        "commandBase": "CopyFreeObject",
        "description": "Creates a free copy of the object. Preserves all basic Object Properties and copy of Auxiliary Object is auxiliary as well.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Shuffle( <List> )",
        "commandBase": "Shuffle",
        "description": "Returns list with same elements, but in random order.",
        "examples": [
            {
                "description": "Shuffle a list of numbers",
                "command": "Shuffle({3, 5, 1, 7, 3})"
            },
            {
                "description": "Shuffle a sequence of numbers",
                "command": "Shuffle(Sequence(20))"
            }
        ],
        "note": "You can recompute the list via Recompute all objects in View Menu (or pressing F9). See also RandomElement Command and RandomBetween Command. CAS Syntax: Shuffle( <List> ): Returns list with same elements, but in random order."
    },
    {
        "signature": "SlopeField( <f(x,y)> ) | SlopeField( <f(x,y)>, <Number n> ) | SlopeField( <f(x,y)>, <Number n>, <Length Multiplier a> ) | SlopeField( <f(x,y)>, <Number n>, <Length Multiplier a>, <Min x>, <Min y>, <Max x>, <Max y> )",
        "commandBase": "SlopeField",
        "description": "Plots a slope field of the differential equation dy/dx = f(x,y).",
        "examples": [
            {
                "description": "Plots the slope field of the differential equation dy/dx = x+y.",
                "command": "SlopeField(x+y)"
            },
            {
                "description": "Plots a slope field on an n by n grid (default 40 if Graphics View is square).",
                "command": "SlopeField( <f(x,y)>, <Number n> )"
            },
            {
                "description": "Plots a slope field with a length multiplier a (0 < a ≤ 1) determining segment length.",
                "command": "SlopeField( <f(x,y)>, <Number n>, <Length Multiplier a> )"
            },
            {
                "description": "Plots a slope field inside a specified rectangle (Min x, Min y, Max x, Max y).",
                "command": "SlopeField( <f(x,y)>, <Number n>, <Length Multiplier a>, <Min x>, <Min y>, <Max x>, <Max y> )"
            }
        ],
        "note": "• Use the following tools: Move Graphics View, Zoom In, Zoom Out and observe the effect.\n• See also SolveODE, Locus, Integral."
    },
    {
        "signature": "SetCaption( <Object>, <Text> ):",
        "commandBase": "SetCaption",
        "description": "Changes the caption of the given object. Text must be enclosed in double quotes.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "HistogramRight( <List of Class Boundaries>, <List of Heights> ) | HistogramRight( <List of Class Boundaries>, <List of Raw Data>, <Boolean Use Density> , <Density Scale Factor> (optional) ) | HistogramRight( <Boolean Cumulative>, <List of Class Boundaries>, <List of Raw Data>, <Boolean Use Density> , <Density Scale Factor> (optional) )",
        "commandBase": "HistogramRight",
        "description": "Same as Histogram command, except that if a datum is equal to the right border of a class, it is counted in this class and not in the next one. Uses the a < x ≤ b rule for each class except for the first class which is a ≤ x ≤ b.",
        "examples": [
            {
                "description": "HistogramRight with class boundaries and heights",
                "command": "HistogramRight( <List of Class Boundaries>, <List of Heights> )"
            },
            {
                "description": "HistogramRight with class boundaries, raw data, use density, and optional density scale factor",
                "command": "HistogramRight( <List of Class Boundaries>, <List of Raw Data>, <Boolean Use Density> , <Density Scale Factor> (optional) )"
            },
            {
                "description": "HistogramRight with cumulative boolean, class boundaries, raw data, use density, and optional density scale factor",
                "command": "HistogramRight( <Boolean Cumulative>, <List of Class Boundaries>, <List of Raw Data>, <Boolean Use Density> , <Density Scale Factor> (optional) )"
            }
        ],
        "note": "By convention this uses the a < x ≤ b rule for each class except for the first class which is a ≤ x ≤ b."
    },
    {
        "signature": "Histogram( <List of Class Boundaries>, <List of Heights> ) | Histogram( <List of Class Boundaries>, <List of Raw Data>, <Boolean Use Density>, <Density Scale Factor>(optional) ) | Histogram( <Boolean Cumulative>, <List of Class Boundaries>, <List of Raw Data>, <Boolean Use Density>, <Density Scale Factor>(optional) )",
        "commandBase": "Histogram",
        "description": "Creates a histogram with bars of the given heights or using raw data, with options for density scaling and cumulative frequencies.",
        "examples": [
            {
                "description": "Creates a histogram with 5 bars of the given heights",
                "command": "Histogram({0, 1, 2, 3, 4, 5}, {2, 6, 8, 3, 1})"
            },
            {
                "description": "Default histogram with density scaling",
                "command": "Histogram({10, 20, 30, 40}, {10, 11, 11, 12, 18, 20, 25, 40}, true)"
            },
            {
                "description": "Count histogram without density scaling",
                "command": "Histogram({10, 20, 30, 40}, {10, 11, 11, 12, 18, 20, 25, 40}, false)"
            },
            {
                "description": "Relative frequency histogram",
                "command": "Histogram({10, 20, 30, 40}, {10, 11, 11, 12, 18, 20, 25, 40}, true, 10/8)"
            },
            {
                "description": "Normalized histogram with total area = 1",
                "command": "Histogram({10, 20, 30, 40}, {10, 11, 11, 12, 18, 20, 25, 40}, true, 1/8)"
            },
            {
                "description": "Cumulative histogram with density scaling",
                "command": "Histogram(true, {10, 20, 30, 40}, {10, 11, 11, 12, 18, 20, 25, 40}, true)"
            }
        ],
        "note": "All elements of Raw Data must be within the interval of the class boundaries, otherwise 'undefined' will be returned. By convention this uses the a ≤ x < b rule for each class except for the last class which is a ≤ x ≤ b."
    },
    {
        "signature": "SetAxesRatio( <Number>, <Number> ) or SetAxesRatio( <Number>, <Number>, <Number> )",
        "commandBase": "SetAxesRatio",
        "description": "Changes the axes ratio of active Graphics View so that X units on x-axis correspond to the same number of pixels as Y units on y-axis and point (0,0) stays on its coordinates. If a unitary ratio is used, the related axis is fixed with the unit value, and the other one is adjusted as indicated. Similar to above syntax, works with 3D Graphics View.",
        "examples": [
            {
                "description": "SetAxesRatio(1,2) fixes the x-axis and compresses the y-axis",
                "command": "SetAxesRatio(1,2)"
            },
            {
                "description": "SetAxesRatio(2,1) fixes the y-axis and shrinks the x-axis",
                "command": "SetAxesRatio(2,1)"
            }
        ],
        "note": "The command supports both 2D and 3D Graphics Views, with the third parameter for 3D."
    },
    {
        "signature": "TriangleCenter( <Point>, <Point>, <Point>, <Number> )",
        "commandBase": "TriangleCenter",
        "description": "gives _n_-th triangle center (https://en.wikipedia.org/wiki/Triangle_center) of triangle ABC. Works for n < 3054.",
        "examples": [
            {
                "description": "Let A = (1, -2), B = (6, 1) and C = (4, 3). TriangleCenter(A, B, C, 2) yields the centroid D = (3.67, 0.67) of the triangle ABC.",
                "command": "TriangleCenter(A, B, C, 2)"
            }
        ],
        "note": "This command differs among variants of English: • TriangleCenter (US) • TriangleCentre (UK + Aus). Some common triangle centers: Index n 1: Incenter, 2: Centroid, 3: Circumcenter, 4: Orthocenter, 5: Nine-point center, 6: Symmedian point, 7: Gergonne point, 8: Nagel point, 13: First isogonic center."
    },
    {
        "signature": "PerpendicularPlane( <Point>, <Line> ) or PerpendicularPlane( <Point>, <Vector> )",
        "commandBase": "PerpendicularPlane",
        "description": "Creates a plane through the given point, perpendicular to the given line or vector.",
        "examples": [
            {
                "description": "Creates a plane through the given point, perpendicular to the given line.",
                "command": "PerpendicularPlane( <Point>, <Line> )"
            },
            {
                "description": "Creates a plane through the given point, perpendicular to the given vector.",
                "command": "PerpendicularPlane( <Point>, <Vector> )"
            }
        ],
        "note": "See also [Image: Mode orthogonalplane.svg,width=24,height=24] Perpendicular Plane Tool."
    },
    {
        "signature": "Area( <Point>, ..., <Point> ) | Area( <Conic> ) | Area( <Polygon> )",
        "commandBase": "Area",
        "description": "Calculates the area of geometric objects including polygons defined by points, conic sections (circle or ellipse), and polygons.",
        "examples": [
            {
                "description": "Calculates the area of the polygon defined by the given points",
                "command": "Area((0, 0), (3, 0), (3, 2), (0, 2))"
            },
            {
                "description": "Calculates the area of a conic section (circle or ellipse)",
                "command": "Area(x2 + y2 = 2)"
            },
            {
                "description": "Calculates the area of the polygon",
                "command": "Area( <Polygon> )"
            }
        ],
        "note": "• For Polygons, the absolute value of the Algebraic Area is calculated (which gives unexpected answers for self-intersecting polygons)\n• In order to calculate the area between two function graphs, you need to use the command IntegralBetween.\n• See also the Area tool."
    },
    {
        "signature": "SetViewDirection( <Direction> ), SetViewDirection( ), SetViewDirection( <Direction>, <Boolean animated> )",
        "commandBase": "SetViewDirection",
        "description": "Sets the direction of the 3D view orientation depending on the given object.",
        "examples": [
            {
                "description": "Sets the direction of the 3D view orientation depending on the given object.",
                "command": "SetViewDirection(Vector((0, 0, 1)))"
            },
            {
                "description": "Sets the direction of the 3D view orientation depending on the given object.",
                "command": "SetViewDirection((0, 0, 1))"
            },
            {
                "description": "Sets the direction of the 3D view orientation depending on the given object.",
                "command": "SetViewDirection(x + y + z = 1)"
            },
            {
                "description": "Sets the direction of the 3D view orientation to the default position.",
                "command": "SetViewDirection()"
            },
            {
                "description": "Sets the direction of the 3D view orientation depending on the given object, with optional animation.",
                "command": "SetViewDirection(Vector((1; α; -30°)), false)"
            }
        ],
        "note": "The view direction can be set towards a line, segment, plane, etc. If you do eg SetViewDirection(x + y + z = 1) twice then there are two possible outcomes and the second one will rotate the view 180°. To avoid ambiguity use eg SetViewDirection(Vector((0, 0, 1))). See also [Image: Mode viewinfrontof.png,width=24,height=24] View in front of tool."
    },
    {
        "signature": "ExportImage( <Property>, <Value>, <Property>, <Value>, ... )",
        "commandBase": "ExportImage",
        "description": "Exports an image of the currently active view (or the view specified by the 'view' parameter)",
        "examples": [
            {
                "description": "Shows a popup of the current view so that the user can right-click -> Save Image As...",
                "command": "ExportImage(\"scale\", 5)"
            },
            {
                "description": "Saves a file called 'image.png' of the current view",
                "command": "ExportImage(\"filename\", \"image.png\")"
            },
            {
                "description": "Saves a file called 'image.png' of Graphics View 2",
                "command": "ExportImage(\"filename\", \"image.png\", \"view\", 2)"
            },
            {
                "description": "Saves a file called 'image.png' of View 3D Graphics",
                "command": "ExportImage(\"filename\", \"image.png\", \"view\", -1)"
            },
            {
                "description": "Saves a file called 'image.png' of the current view at 300 dpi (dots-per-inch)",
                "command": "ExportImage(\"filename\", \"image.png\", \"dpi\", 300)"
            },
            {
                "description": "Saves a file called 'image.png' of the current view at scale 2 (ie twice nominal screen resolution)",
                "command": "ExportImage(\"filename\", \"image.png\", \"scale\", 2)"
            },
            {
                "description": "Saves a file called 'image.png' of the current view at 600 dpi at a scale 1 unit = 2 cm",
                "command": "ExportImage(\"filename\", \"image.png\", \"scalecm\", 2, \"dpi\", 600)"
            },
            {
                "description": "Saves a file called 'image.png' of the current view with width = 1000 pixels",
                "command": "ExportImage(\"filename\", \"image.png\", \"width\", 1000)"
            },
            {
                "description": "Saves a file called 'image.png' of the current view with height = 1000 pixels",
                "command": "ExportImage(\"filename\", \"image.png\", \"height\", 1000)"
            },
            {
                "description": "Saves a transparent PNG file called 'image.png'. Setting the 'transparent' property as false saves also background images.",
                "command": "ExportImage(\"filename\", \"image.png\", \"transparent\", true)"
            },
            {
                "description": "Saves a file called 'image.svg' of the current view in SVG format",
                "command": "ExportImage(\"filename\", \"image.svg\", \"type\", \"svg\")"
            },
            {
                "description": "Saves a looping animated GIF of the current view controlled by slider 'a' with 200ms between frames. Keep the width and number of slider steps small",
                "command": "ExportImage(\"filename\", \"image.gif\", \"type\", \"gif\", \"slider\", a, \"loop\", true, \"time\", 200, \"width\", 400)"
            },
            {
                "description": "Saves a looping animated GIF of the current view controlled by slider 'a' with 200ms between frames and rotates the view 360° during the animation. Keep the size of the view and the number of steps small",
                "command": "ExportImage(\"filename\", \"image.gif\", \"type\", \"gif\", \"view\", -1, \"rotate\", 360°, \"slider\", a, \"loop\", true, \"time\", 200)"
            },
            {
                "description": "Creates a PDF of the current view (or a 2-page PDF if Graphics View 2 is open)",
                "command": "ExportImage(\"type\", \"pdf\", \"filename\", \"test.pdf\")"
            },
            {
                "description": "Creates a multi-page PDF of the current view where each page corresponds to one step of the slider 'n'",
                "command": "ExportImage(\"type\", \"pdf\", \"filename\", \"test.pdf\", \"slider\", n)"
            },
            {
                "description": "Creates a GeoGebra image of View 2 and puts it in the view with position defined by A and B",
                "command": "pic1 = ExportImage(\"view\", 2, \"corner\", A, \"corner2\", B)"
            }
        ],
        "note": "The Properties used in the command syntax, listed in the following examples, need to be entered in English. The values related to the View that will be saved as image are: 1 for Graphics View, 2 for Graphics View 2, -1 for 3D View. In GeoGebra Classic 5 if there is no filename parameter the image will be copied to the Clipboard. In the Chrome browser you can specify 'clipboard', true. To crop an export, make the Points Export_1 and Export_2 to define the rectangle to crop (*These also crop the exports from the menus eg File -> Export Image*). Some syntaxes aren't supported in GeoGebra 5 Classic. In Chrome, you can try the experimental syntax 'type', 'webm' to get a faster & smaller export than with animated GIFs. For the 2D Graphics Views you can try this syntax to get a monochrome export 'grayscale', true (PNG format only). For the 3D Graphics View, only bitmaps (eg png, gif) are supported. In GeoGebra Classic 5 you can try this to get a high-resolution output: ExportImage('filename', 'c:\\Users\\<username>\\AppData\\image.png', 'view', -1, 'width', 2000). Change <username> to your Windows username."
    },
    {
        "signature": "JordanDiagonalization Command",
        "commandBase": "JordanDiagonalization",
        "description": "No description provided.",
        "examples": [],
        "note": "No note provided."
    },
    {
        "signature": "ExtendedGCD( <Integer>,<Integer> ) or ExtendedGCD( <Polynomial>, <Polynomial> )",
        "commandBase": "ExtendedGCD",
        "description": "Returns a list containing the coefficients of Bézout's identity and the greatest common divisor of the given integers or polynomials, calculated using the Extended Euclidean algorithm.",
        "examples": [
            {
                "description": "ExtendedGCD with integers 240 and 46",
                "command": "ExtendedGCD(240,46)"
            },
            {
                "description": "ExtendedGCD with polynomials x²-1 and x+4",
                "command": "ExtendedGCD(x2-1,x+4)"
            }
        ],
        "note": "The GCD of two polynomials is not unique (it's unique up to a scalar multiple). See also GCD Command."
    },
    {
        "signature": "Eigenvectors( <Matrix> )",
        "commandBase": "Eigenvectors",
        "description": "Finds the eigenvectors of the given matrix.",
        "examples": [
            {
                "description": "CAS Syntax",
                "command": "Eigenvectors({{1, 2}, {3, 4}})"
            }
        ],
        "note": "See also Eigenvalues Command, SVD Command, Invert Command, Transpose Command"
    },
    {
        "signature": "transpose",
        "commandBase": "transpose",
        "description": "Transposes data, typically matrices or tables, swapping rows and columns.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "StickGraph( <List of Points> ) | StickGraph( <List of Points>, <Boolean Horizontal> ) | StickGraph( <List of x-coordinates>, <List of y-coordinates> ) | StickGraph( <List of x-coordinates>, <List of y-coordinates>, <Boolean Horizontal> )",
        "commandBase": "StickGraph",
        "description": "Draws a stick graph of the given points. For each point a vertical line segment is drawn from the x-axis to the point. If Horizontal = true, then horizontal line segments are drawn from the y-axis to each point. If Horizontal = false, then vertical line segments are drawn from the x-axis to each point.",
        "examples": [
            {
                "description": "Draws a stick graph of the given points with vertical lines",
                "command": "StickGraph({(1, 1), (3, 2), (4, 5), (5, 7)})"
            },
            {
                "description": "Draws a stick graph of the given points with vertical lines (Horizontal = false)",
                "command": "StickGraph({(1, 1), (3, 2), (4, 5), (5, 7)}, false)"
            },
            {
                "description": "Draws a stick graph of points created from two lists of coordinates with vertical lines",
                "command": "StickGraph({1, 3, 4, 5}, {1, 2, 5, 7})"
            },
            {
                "description": "Draws a stick graph of points created from two lists of coordinates with horizontal lines (Horizontal = true)",
                "command": "StickGraph({1, 3, 4, 5}, {1, 2, 5, 7}, true)"
            }
        ],
        "note": "The command supports multiple signatures for flexibility in specifying points and orientation of line segments."
    },
    {
        "signature": "IsInteger( <Number> )",
        "commandBase": "IsInteger",
        "description": "Returns true or false depending whether the number is an integer or not.",
        "examples": [
            {
                "description": "Check if a division result is an integer",
                "command": "IsInteger(972 / 9)"
            }
        ],
        "note": ""
    },
    {
        "signature": "Slider( <Min>, <Max>, <Increment>, <Speed>, <Width>, <Is Angle>, <Horizontal>, <Animating>, <Boolean Random>)",
        "commandBase": "Slider",
        "description": "Creates a slider. The parameters settings can be as follows: * Min, Max: set the range of the slider - These parameters are compulsory. * Increment: set the increment of the slider's value - default: 0.1 * Speed: set the slider speed during animations - default: 1 * Width: sets the slider width in pixels - default: 100 * Is Angle: sets if the slider is related to an angle. This parameter can be true or false - default: false * Horizontal: sets whether the slider is shown as an horizontal (_true_) or vertical (_false_) segment - default: true * Animating: sets the automatic animation of the slider - default: false * Random: sets if the slider assumes continuous values in the [Min, Max] range (_false_), or random values in the same interval (_true_) - default: false",
        "examples": [],
        "note": "See also the [Image: Mode slider.svg,width=26,height=26] Slider tool."
    },
    {
        "signature": "Simplify( <Function> ) or Simplify( <Text> )",
        "commandBase": "Simplify",
        "description": "Simplifies the terms of the given function or tidies up text expressions by removing repeated negatives etc.",
        "examples": [
            {
                "description": "Simplify(x + x + x) yields the function f(x) = 3x.",
                "command": "Simplify(x + x + x)"
            },
            {
                "description": "For a = b = c = -1 Simplify(\"f(x) = \" + a + \"x² + \" + b + \"x + \" + c) yields the text f(x) = -x2 - x - 1.",
                "command": "Simplify(\"f(x) = \" + a + \"x² + \" + b + \"x + \" + c)"
            },
            {
                "description": "Simplify(3 * x + 4 * x + a * x) yields a x + 7x.",
                "command": "Simplify(3 * x + 4 * x + a * x)"
            },
            {
                "description": "Assume(x<2,Simplify(sqrt(x-2sqrt(x-1)))) yields -sqrt(abs(x - 1)) + 1",
                "command": "Assume(x<2,Simplify(sqrt(x-2sqrt(x-1))))"
            },
            {
                "description": "Assume(x>2,Simplify(sqrt(x-2sqrt(x-1)))) yields sqrt(x - 1) + 1",
                "command": "Assume(x>2,Simplify(sqrt(x-2sqrt(x-1))))"
            }
        ],
        "note": "The FormulaText Command normally produces better results and is simpler. This command needs to load the Computer Algebra System, so can be slow on some computers. Try using the Polynomial Command instead. See also Factor Command, Assume Command, PartialFractions Command, Expand Command, Polynomial Command."
    },
    {
        "signature": "Product( <List of Raw Data> ) | Product( <List of Numbers>, <Number of Elements> ) | Product( <List of Numbers>, <List of Frequencies> ) | Product( <Expression>, <Variable>, <Start Value>, <End Value> )",
        "commandBase": "Product",
        "description": "Calculates the product of numbers or expressions using various syntax forms, including product of list elements, partial list products, element-wise exponentiation, and product sequences over integer ranges.",
        "examples": [
            {
                "description": "Product of all numbers in a list",
                "command": "Product({2, 5, 8})"
            },
            {
                "description": "Product of the first n elements in a list",
                "command": "Product({1, 2, 3, 4}, 3)"
            },
            {
                "description": "Product of elements raised to corresponding frequencies",
                "command": "Product({20, 40, 50, 60}, {4, 3, 2, 1})"
            },
            {
                "description": "Product of expressions with variable substitution over integer range",
                "command": "Product(k, k, 1, 7)"
            },
            {
                "description": "CAS syntax: Product of list elements",
                "command": "Product({1, 2, x})"
            },
            {
                "description": "CAS syntax: Product with variable substitution",
                "command": "Product(x + 1, x, 2, 3)"
            }
        ],
        "note": "For Product( <List of Numbers>, <List of Frequencies> ), the two lists must have the same length. Some examples show symbolic results like _f_(_x_)=(_x_ + 2)(_x_ + 3)."
    },
    {
        "signature": "InverseGamma( <Alpha>, <Beta>, <Probability> )",
        "commandBase": "InverseGamma",
        "description": "Computes the inverse of the Gamma cumulative distribution with parameters α and β for a given probability p. In other words, the command finds t such that P(X ≤ t) = p, where X is a random variable with a Gamma distribution. Probability p is any value in the interval [0,1].",
        "examples": [],
        "note": ""
    },
    {
        "signature": "FitGrowth( <List of Points> )",
        "commandBase": "FitGrowth",
        "description": "Calculates a function of the form a·b^x to the points in the list. (Very similar to FitExp[ <List of Points> ], just in a slightly different form).",
        "examples": [
            {
                "description": "Fit a growth function to points",
                "command": "FitGrowth({(0, 1), (2, 3), (4, 3), (6, 4)})"
            }
        ],
        "note": "You can do a direct least-squares fitting with Fit(list, a*b^x). See also Fit, FitExp, FitLine, FitLineX, FitLog, FitLogistic, FitPoly, FitPow and FitSin."
    },
    {
        "signature": "TurtleDown( <Turtle> )",
        "commandBase": "TurtleDown",
        "description": "Authorizes the turtle named to trace its movement from now.",
        "examples": [
            {
                "description": "Authorizes the turtle named to trace its movement from now.",
                "command": "TurtleDown( <Turtle> )"
            }
        ],
        "note": "See also command TurtleUp"
    },
    {
        "signature": "Translate( <Object>, <Vector> )",
        "commandBase": "Translate",
        "description": "Translates the geometric object by the vector.",
        "examples": [
            {
                "description": "When translating a polygon, the transformed new vertices and segments are created as well.",
                "command": "Translate( <Vector>, <Start Point> )"
            }
        ],
        "note": "See also [Image: Mode translatebyvector.svg,width=24,height=24]Translate by Vector tool."
    },
    {
        "signature": "JordanDiagonalization( <Matrix> )",
        "commandBase": "JordanDiagonalization",
        "description": "Decomposes the given matrix into the form S J S⁻¹ where J is in Jordan Canonical Form.",
        "examples": [
            {
                "description": "JordanDiagonalization for a 2x2 matrix",
                "command": "JordanDiagonalization({{1, 2}, {3, 4}})"
            }
        ],
        "note": "This command differs among variants of English: JordanDiagonalization (US), JordanDiagonalisation (UK + Aus). See also Eigenvalues Command, Eigenvectors Command, SVD Command, Invert Command."
    },
    {
        "signature": "NInvert( <Function> )",
        "commandBase": "NInvert",
        "description": "Gives the inverse of the function without showing the inverted formula. If you want to get the formula, use the Invert Command instead.",
        "examples": [
            {
                "description": "NInvert(sin(x)) yields a function f such that sin(f(x))=x for -1 < x < 1.",
                "command": "NInvert(sin(x))"
            }
        ],
        "note": "• No account is taken of domain or range, for example for f(x) = x2 or f(x) = sin(x).\n• The command works faster for functions that only contain one x.\n• To make your construction more efficient you may want to rearrange your functions and use eg NInvert((x+1)2-1) rather than NInvert(x2+2x)."
    },
    {
        "signature": "ResidualPlot( <List of Points>, <Function> )",
        "commandBase": "ResidualPlot",
        "description": "Returns a list of points whose x-coordinates are equal to the x-coordinates of the elements of the given list, and y-coordinates are the residuals with respect to f. If the _i_-th element of the given list is a point (a,b) then _i_-th element of the result is (a,b-f(a)).",
        "examples": [
            {
                "description": "Let list = {(-1, 1), (-0.51, 2), (0, 0.61), (0.51, -1.41), (0.54, 1.97), (1.11, 0.42), (1.21, 2.53), (-0.8, -0.12)} be the list of points and f(x) = x5 + x4 - x - 1 the function. The ResidualPlot(list, f ) command yields list1 = {(-1, 1), (-0.51, 2.46), (0, 1.61), (0.51, 0), (0.54, 3.38), (1.11, -0.66), (1.21, 0), (-0.8, 0)} and creates the corresponding points in Graphics View.",
                "command": "ResidualPlot(list, f)"
            }
        ],
        "note": ""
    },
    {
        "signature": "FormulaText(<Object>), FormulaText(<Object>, <Boolean for Substitution of Variables>), FormulaText(<Object>, <Boolean for Substitution of Variables>, <Boolean Show Name>)",
        "commandBase": "FormulaText",
        "description": "Returns the formula that defines the object as a LaTeX text. Values are substituted for variables by default.",
        "examples": [
            {
                "description": "Let a = 2 and f(x) = a x2. FormulaText(f) returns 2 x2 (as a LaTeX text).",
                "command": "FormulaText(f)"
            },
            {
                "description": "Let a = 2 and f(x) = a x2. FormulaText(f, true) returns 2 x2 (as a LaTeX text).",
                "command": "FormulaText(f, true)"
            },
            {
                "description": "Let a = 2 and f(x) = a x2. FormulaText(f, false) returns a x2 (as a LaTeX text).",
                "command": "FormulaText(f, false)"
            },
            {
                "description": "Let a = 2 and f(x) = a x2. FormulaText(f, true, true) returns f(x) = 2 x2 (as a LaTeX text).",
                "command": "FormulaText(f, true, true)"
            },
            {
                "description": "Let a = 2 and f(x) = a x2. FormulaText(f, false, false) returns a x2 (as a LaTeX text).",
                "command": "FormulaText(f, false, false)"
            }
        ],
        "note": "In GeoGebra Classic v.5, the command FormulaText($1) returns the content of cell 1 of the CAS View as a LaTeX text."
    },
    {
        "signature": "TTest2( <List of Sample Data 1>, <List of Sample Data 2>, <Tail>, <Boolean Pooled> )",
        "commandBase": "TTest2",
        "description": "Performs a t-test of the difference between two population means using the given lists of sample data. Tail has possible values \"<\", \">\" , \"≠\" that determine the following alternative hypotheses: \"<\" = difference in population means < 0, \">\" = difference in population means > 0, \"≠\" = difference in population means ≠ 0. If Pooled = true, then population variances are assumed equal and sample standard deviations are combined in calculation. If Pooled = false, then population variances are not assumed equal and sample standard deviations are not combined. Results are returned in list form as {Probability value, t-test statistic}.",
        "examples": [],
        "note": "This command also has an alternative signature: TTest2( <Sample Mean 1>, <Sample Standard Deviation 1>, <Sample Size 1>, <Sample Mean 2>, <Sample Standard Deviation 2>, <Sample Size 2>, <Tail>, <Boolean Pooled> ), which performs a t-test using the given sample statistics with Tail and Pooled defined as above, returning results in list form as {Probability value, t-test statistic}."
    },
    {
        "signature": "ConstructionStep() or ConstructionStep(<Object>)",
        "commandBase": "ConstructionStep",
        "description": "Returns the current Construction Protocol step as a number, or returns the Construction Protocol step for a given object as a number.",
        "examples": [
            {
                "description": "Get the current Construction Protocol step",
                "command": "ConstructionStep()"
            },
            {
                "description": "Get the Construction Protocol step for a specific object",
                "command": "ConstructionStep(<Object>)"
            }
        ],
        "note": "The command can be used without arguments to get the current step, or with an object argument to get the step for that object."
    },
    {
        "signature": "CircumcircularSector( <Point>, <Point>, <Point> )",
        "commandBase": "CircumcircularSector",
        "description": "Creates a circular sector whose arc runs through the three points, where the first point is the starting point and the third point is the endpoint of the arc.",
        "examples": [
            {
                "description": "Creates a circular sector whose arc runs through the three points, where the first point is the starting point and the third point is the endpoint of the arc.",
                "command": "CircumcircularSector( <Point>, <Point>, <Point> )"
            }
        ],
        "note": "See also [Image: Mode circumcirclesector3.svg,width=24,height=24] Circumcircular Sector through Three Points tool."
    },
    {
        "signature": "Rotate( <Object>, <Angle> )\nRotate( <Object>, <Angle>, <Point> )\nRotate( <Object>, <Angle>, <Axis of Rotation> )\nRotate( <Object>, <Angle>, <Point on Axis>, <Axis Direction or Plane> )",
        "commandBase": "Rotate",
        "description": "Rotates the geometric object by the angle around the axis origin.",
        "examples": [],
        "note": "Vectors are not rotated around axis origin, but around their initial point. When a polygon, segment, arc, etc. is rotated, also images of the vertices / endpoints and sides (in case of polygon) are created. This command also rotates images. For text rotation use RotateText Command. See also Rotate around Point and Rotate around Line tools."
    },
    {
        "signature": "RandomUniform( <Min>, <Max> ) or RandomUniform( <Min>, <Max>, <Number of Samples n> )",
        "commandBase": "RandomUniform",
        "description": "Returns random real number(s) from uniform distribution on interval [_min_, _max_].",
        "examples": [
            {
                "description": "RandomUniform(0, 1) returns a random number between 0 and 1",
                "command": "RandomUniform(0, 1)"
            },
            {
                "description": "RandomUniform(0, 1, 3) returns a list of three random numbers between 0 and 1",
                "command": "RandomUniform(0, 1, 3)"
            }
        ],
        "note": "• RandomUniform(0,1) is equivalent to random() (see Predefined Functions and Operators).\n• See also SetSeed, RandomBetween, RandomElement, RandomBinomial, RandomNormal, RandomPoisson commands."
    },
    {
        "signature": "FitLog( <List of Points> )",
        "commandBase": "FitLog",
        "description": "Calculates the logarithmic regression curve.",
        "examples": [
            {
                "description": "FitLog({(ℯ, 1), (ℯ², 4)}) yields -2 + 3 ln(x)",
                "command": "FitLog({(ℯ, 1), (ℯ², 4)})"
            },
            {
                "description": "FitLog({(ℯ, 1), (ℯ², 4)}) yields 3 ln(x) - 2",
                "command": "FitLog({(ℯ, 1), (ℯ², 4)})"
            }
        ],
        "note": "Euler's number ℯ can be obtained by pressing ALT + e. See also FitExp Command, FitPoly Command, FitPow Command and FitSin Command. If you work with big/small numbers, you should consider normalizing them for a more accurate result, see Normalize Command."
    },
    {
        "signature": "UnitPerpendicularVector( <Line> ) | UnitPerpendicularVector( <Segment> ) | UnitPerpendicularVector( <Vector> ) | UnitPerpendicularVector( <Plane> )",
        "commandBase": "UnitPerpendicularVector",
        "description": "Returns the perpendicular vector with length 1 of the given line, segment, vector, or plane.",
        "examples": [
            {
                "description": "Get unit perpendicular vector of a line",
                "command": "UnitPerpendicularVector(3x + 4y = 5)"
            },
            {
                "description": "Get unit perpendicular vector of a segment",
                "command": "UnitPerpendicularVector(s) where s = Segment((1,1), (4,5))"
            },
            {
                "description": "Get unit perpendicular vector of a vector",
                "command": "UnitPerpendicularVector(v) where v = Vector(3,4)"
            },
            {
                "description": "Get unit perpendicular vector with undefined variables in CAS View",
                "command": "UnitPerpendicularVector((a, b))"
            }
        ],
        "note": "In the CAS View, vectors with undefined variables are also valid input. See also PerpendicularVector Command."
    },
    {
        "signature": "PlaneBisector( <Point> , <Point> )\nPlaneBisector( <Segment> )",
        "commandBase": "PlaneBisector",
        "description": "Creates the plane orthogonal bisector between the two points or of the segment.",
        "examples": [],
        "note": "This command has two overloads: one for two points and one for a segment."
    },
    {
        "signature": "Numerator( <Expression> )",
        "commandBase": "Numerator",
        "description": "Returns the numerator of a rational number or expression. For functions, returns the numerator of the function. For numbers, returns the numerator of a rational number (simplified) or the numerator of its continued fraction for irrational input.",
        "examples": [
            {
                "description": "Get the numerator of a function",
                "command": "Numerator((3x² + 1) / (2x - 1))"
            },
            {
                "description": "Get the numerator of a rational number (simplified)",
                "command": "Numerator(5 / 3)"
            },
            {
                "description": "Get the numerator of a rational number after simplification",
                "command": "Numerator(10 / 6)"
            },
            {
                "description": "Get the numerator of a rational number (simplified)",
                "command": "Numerator(15 / 3)"
            },
            {
                "description": "Get the numerator of an expression",
                "command": "Numerator(2/3 + 1/15)"
            },
            {
                "description": "Get the numerator of a variable expression",
                "command": "Numerator(a/b)"
            },
            {
                "description": "Get the numerator after simplification",
                "command": "Numerator(Simplify(a + b/c))"
            }
        ],
        "note": "For numbers, it uses a numerical method that limits this command to numbers with small denominators. See also Denominator Command and FractionText Command. CAS Syntax: Numerator( <Expression> )."
    },
    {
        "signature": "InflectionPoint( <Polynomial> )",
        "commandBase": "InflectionPoint",
        "description": "Yields all inflection points of the polynomial as points on the function graph.",
        "examples": [
            {
                "description": "InflectionPoint[x3] yields (0, 0)",
                "command": "InflectionPoint[x3]"
            }
        ],
        "note": "CAS Syntax: InflectionPoint( <Function> ): Yields all inflection points of the function (where possible) as a list. Example: InflectionPoint[x exp(-x)] yields stem:[ \\left\\{ \\left(2, \\frac{2}{\\textit{e}{2}} \\right) \\right\\} ]"
    },
    {
        "signature": "Maximize( <Dependent number>, <Free number> ) or Maximize( <Dependent Number>, <Point on Path> )",
        "commandBase": "Maximize",
        "description": "Calculates the free number or position of the point which gives the maximal value of the dependent number, using a slider interval or path as the search interval. The relationship should be continuous and have only one local maximum point in the interval. If the construction is complicated, this command might return ? to avoid using too much processor time.",
        "examples": [
            {
                "description": "Maximize a triangle's area using a slider",
                "command": "Maximize(t1,a)"
            },
            {
                "description": "Maximize distance from a point outside a circle to a point on the circle",
                "command": "Maximize(f,C)"
            }
        ],
        "note": "This command differs among variants of English: Maximize (US), Maximise (UK + Aus). See also Minimize command."
    },
    {
        "signature": "MeanX( <List of Points> )",
        "commandBase": "MeanX",
        "description": "Calculates the mean of the _x_-coordinates of the points in the list.",
        "examples": [
            {
                "description": "Calculate the mean of the x-coordinates for a given list of points",
                "command": "MeanX({(0,0), (3,2), (5,1), (2,1), (2,4)})"
            }
        ],
        "note": "The example yields 2.4 as the result."
    },
    {
        "signature": "ZoomIn( ) | ZoomIn( <Scale Factor> ) | ZoomIn( <Scale Factor>, <Center Point> ) | ZoomIn( <Min x>, <Min y>, <Max x>, <Max y> ) | ZoomIn( <Min x>, <Min y>, <Min z>, <Max x>, <Max y>, <Max z> )",
        "commandBase": "ZoomIn",
        "description": "Zooms the Graphics View in by various methods: restoring to default, scaling by factor with optional center, zooming to a 2D rectangle, or zooming to a 3D cuboid.",
        "examples": [
            {
                "description": "Restores the Graphics View to the default initial position",
                "command": "ZoomIn( )"
            },
            {
                "description": "Zooms the Graphics View in by factor 2 with respect to current zoom, using center of screen as center point",
                "command": "ZoomIn(2)"
            },
            {
                "description": "Zooms the Graphics View in by factor 2 with respect to current zoom, using (0, 0) as center point",
                "command": "ZoomIn(2, (0, 0))"
            },
            {
                "description": "Zooms the graphics view to the rectangle given by vertices (0, 1), (5, 6)",
                "command": "ZoomIn(0, 1, 5, 6)"
            },
            {
                "description": "Makes the zoom of the view dependent on slider a",
                "command": "ZoomIn(-a, -a, a, a)"
            },
            {
                "description": "Zooms the 3D graphics view to the cuboid given by vertices (-5, -5, -5), (5, 5, 5)",
                "command": "ZoomIn(-5, -5, -5, 5, 5, 5)"
            }
        ],
        "note": "If parameters are dependent or have label set, the bounds of the view become dynamic (use CopyFreeObject to avoid). The dynamic behavior isn't supported for the 3D version. If multiple Graphics Views are present, the active one is used. See also ZoomOut, SetActiveView, Pan commands."
    },
    {
        "signature": "InfiniteCylinder( <Line>, <Radius> ) or InfiniteCylinder( <Point>, <Vector>, <Radius> ) or InfiniteCylinder( <Point>, <Point>, <Radius> )",
        "commandBase": "InfiniteCylinder",
        "description": "Creates an infinite cylinder with given radius and given line as an axis of symmetry.",
        "examples": [
            {
                "description": "Creates an infinite cylinder with radius 2 and with the x-axis as axis of symmetry.",
                "command": "InfiniteCylinder( xAxis, 2 )"
            },
            {
                "description": "Creates an infinite cylinder with given radius and with axis of symmetry through a given point parallel to the vector.",
                "command": "InfiniteCylinder( <Point>, <Vector>, <Radius> )"
            },
            {
                "description": "Creates an infinite cylinder with given radius and with line through two points as an axis of symmetry.",
                "command": "InfiniteCylinder( <Point>, <Point>, <Radius> )"
            }
        ],
        "note": "See also the Cylinder command and [Image: Mode cylinder.svg,width=24,height=24] Cylinder tool."
    },
    {
        "signature": "StemPlot( <List> )\nStemPlot( <List>, <Adjustment -1|0|1> )",
        "commandBase": "StemPlot",
        "description": "Returns a stem plot of the given list of numbers. Outliers are removed from the plot and listed separately. An outlier is defined as a value outside the interval [ Q1 - 1.5 (Q3 - Q1) , Q3 + 1.5 (Q3 - Q1) ]. For the variant with Adjustment: * If Adjustment = -1 the default stem unit is divided by 10 * If Adjustment = 0 nothing is changed * If Adjustment = 1 the default stem unit is multiplied by 10",
        "examples": [
            {
                "description": "This command differs among variants of English: • StemPlot (US) • StemAndLeaf (UK + Aus)",
                "command": "[Image: Globe.png,width=64,height=64,role=left]"
            }
        ],
        "note": "None"
    },
    {
        "signature": "AreConcurrent( <Line>, <Line>, <Line> )",
        "commandBase": "AreConcurrent",
        "description": "Decides if the lines are concurrent. If the lines are parallel, they considered to have a common point in infinity, thus this command returns true in this case. Normally this command computes the result numerically. This behavior can be changed by using the Prove command.",
        "examples": [
            {
                "description": "Check if three lines are concurrent",
                "command": "AreConcurrent(Line((1, 2), (3, 4)), Line((1, 2), (3, 5)), Line((1, 2), (3, 6)))"
            }
        ],
        "note": "See also AreCollinear, AreConcyclic, AreCongruent, AreEqual, ArePerpendicular, AreParallel, IsTangent commands."
    },
    {
        "signature": "InverseBinomialMinimumTrials(Cumulative Probability, Probability of Success, Number of Successes)",
        "commandBase": "InverseBinomialMinimumTrials",
        "description": "Returns the minimum number n of trials to obtain the given number of successes.",
        "examples": [
            {
                "description": "Calculate minimum trials for cumulative probability 0.5, success probability 0.2, and 50 successes",
                "command": "InverseBinomialMinimumTrials(0.5, 0.2, 50)"
            }
        ],
        "note": "The example shows that InverseBinomialMinimumTrials(0.5, 0.2, 50) yields 254."
    },
    {
        "signature": "Reflect( <Object>, <Point> )::, Reflect( <Object>, <Line> )::, Reflect( <Object>, <Circle> )::, Reflect( <Object>, <Plane> )::",
        "commandBase": "Reflect",
        "description": "Reflects the geometric object through a given point, across a given line, inverts with respect to a circle, or about a plane.",
        "examples": [
            {
                "description": "When reflecting polygons through a point, the transformed vertices and segments are created as well.",
                "command": "Reflect( <Object>, <Point> )::"
            },
            {
                "description": "When reflecting polygons across a line, the transformed vertices and segments are created as well.",
                "command": "Reflect( <Object>, <Line> )::"
            },
            {
                "description": "See also Reflect about Point, Reflect about Line, Reflect about Plane, and Reflect about Circle tools.",
                "command": "Reflect( <Object>, <Plane> )::"
            }
        ],
        "note": "The command has multiple signatures for different geometric transformations: point reflection, line reflection, circle inversion, and plane reflection."
    },
    {
        "signature": "Polygon( <Point>, ..., <Point> )",
        "commandBase": "Polygon",
        "description": "Returns a polygon defined by the given points.",
        "examples": [
            {
                "description": "Creates a quadrilateral from four points",
                "command": "Polygon((1, 1), (3, 0), (3, 2), (0, 4))"
            },
            {
                "description": "Creates a regular hexagon from two points and vertex count",
                "command": "Polygon((1, 1), (4, 1), 6)"
            },
            {
                "description": "Creates a triangle from a list of points",
                "command": "Polygon({(0, 0), (2, 1), (1, 3)})"
            }
        ],
        "note": "See also Polygon and Regular Polygon tools. Multiple signatures exist: Polygon(<Point>,...,<Point>), Polygon(<Point>,<Point>,<Number of Vertices>), Polygon(<List of Points>), Polygon(<Point>,<Point>,<Number of Vertices n>,<Direction>)."
    },
    {
        "signature": "Axes( <Conic> ) or Axes( <Quadric> )",
        "commandBase": "Axes",
        "description": "Returns the equations of the major and minor axes of a conic section or creates the 3 axes of the given quadric.",
        "examples": [
            {
                "description": "Returns the equations of the major and minor axes of a conic section.",
                "command": "Axes( <Conic> )"
            },
            {
                "description": "Creates the 3 axes of the given quadric.",
                "command": "Axes( <Quadric> )"
            },
            {
                "description": "Axes(x2 + y2 + z2= 3) returns the three lines a: X = (0, 0, 0) + λ (1, 0, 0), b: X = (0, 0, 0) + λ (0, 1, 0) and c: X = (0, 0, 0) + λ (0, 0, 1)",
                "command": "Axes(x2 + y2 + z2= 3)"
            }
        ],
        "note": "See also MajorAxis and MinorAxis commands. Specifically: • if the given quadric is a cylinder, the command yields the two axes of the bottom circle and the rotation axis. • if the given quadric is a sphere, the command yields the three axes parallel to the coordinate system axes."
    },
    {
        "signature": "Polyline( <List of Points> ) or Polyline( <Point>, ..., <Point> )",
        "commandBase": "Polyline",
        "description": "Creates an open polygonal chain (i.e. a connected series of segments) having the initial vertex in the first point of the list, and the final vertex in the last point of the list.",
        "examples": [
            {
                "description": "Creates an open polygonal chain from a list of points.",
                "command": "Polyline( <List of Points> )"
            },
            {
                "description": "Creates an open polygonal chain from multiple individual points.",
                "command": "Polyline( <Point>, ..., <Point> )"
            },
            {
                "description": "Example with specific points and resulting length in Algebra View.",
                "command": "Polyline((1, 3), (4, 3), (?,?), (6, 2), (4, -2), (2, -2))"
            }
        ],
        "note": "The polygonal chain length is displayed in the Algebra View. It is also possible to create a discontinuous polygonal. See also Polygon command."
    },
    {
        "signature": "TableText( <List>, <List>, ... ):",
        "commandBase": "TableText",
        "description": "Creates a text that contains a table of the list objects.",
        "examples": [
            {
                "description": "TableText({x2, 4}, {x3, 8}, {x4, 16}) creates a table as a text object with three rows and two columns. All items of the table are left aligned.",
                "command": "TableText({x2, 4}, {x3, 8}, {x4, 16})"
            },
            {
                "description": "TableText(Sequence(i2, i, 1, 10)) creates a table as a text object with one row. All items of the table are left aligned.",
                "command": "TableText(Sequence(i2, i, 1, 10))"
            },
            {
                "description": "TableText({1, 2, 3, 4}, {1, 4, 9, 16}, \"v\") creates a text with two columns and four rows whose elements are left aligned.",
                "command": "TableText({1, 2, 3, 4}, {1, 4, 9, 16}, \"v\")"
            },
            {
                "description": "TableText({1, 2, 3, 4}, {1, 4, 9, 16}, \"h\") creates a text with two rows and four columns whose elements are left aligned.",
                "command": "TableText({1, 2, 3, 4}, {1, 4, 9, 16}, \"h\")"
            },
            {
                "description": "TableText({11.2, 123.1, 32423.9, \"234.0\"}, \"vr\") creates a text with one column whose elements are right aligned.",
                "command": "TableText({11.2, 123.1, 32423.9, \"234.0\"}, \"vr\")"
            },
            {
                "description": "TableText({A1:A10, B1:B10, C1:C10}, \"vl\") creates a text with three columns whose elements (left aligned) are the objects in the given Spreadsheet cells.",
                "command": "TableText({A1:A10, B1:B10, C1:C10}, \"vl\")"
            },
            {
                "description": "TableText({{2011.56, 2, 3.7, 4}, {1, 4.2, 9, 16.365}}, \"v.\") creates a text whose elements are aligned on decimal points.",
                "command": "TableText({{2011.56, 2, 3.7, 4}, {1, 4.2, 9, 16.365}}, \"v.\")"
            },
            {
                "description": "TableText({{2011.56, 2, 3.7, 4}, {1, 4.2, 9, 16.365}}, \"v%\") creates a text whose elements are converted to a percentage, and aligned on decimal points.",
                "command": "TableText({{2011.56, 2, 3.7, 4}, {1, 4.2, 9, 16.365}}, \"v%\")"
            },
            {
                "description": "TableText({x², 4}, {x³, 8}, {x⁴, 16}, \"c\", 50) creates a table with three rows and two columns. All items in the table are centered and the cell width is 50 px.",
                "command": "TableText({x², 4}, {x³, 8}, {x⁴, 16}, \"c\", 50)"
            },
            {
                "description": "TableText({{\"left\", \"center\", \"right\"}, {\"l\", \"c\", \"r\"}}, \"lcr\", 45, 80) creates a table with two rows and three columns. All items in the table have a different alignment. Each cell of the table is 45 px wide and 80 px high.",
                "command": "TableText({{\"left\", \"center\", \"right\"}, {\"l\", \"c\", \"r\"}}, \"lcr\", 45, 80)"
            },
            {
                "description": "TableText({1, 2}, {3, 4}, \"c()\") creates the text stem:[\\begin{pmatrix}{} 1 & 2 \\\\ 3 & 4 \\\\ \\end{pmatrix} ]",
                "command": "TableText({1, 2}, {3, 4}, \"c()\")"
            },
            {
                "description": "TableText({1, 2}, {3, 4}, \"c|_\") creates the text",
                "command": "TableText({1, 2}, {3, 4}, \"c|_\")"
            },
            {
                "description": "TableText({1, 2}, {3, 4}, \"||\") creates the text stem:[ \\begin{vmatrix}{} 1 & 2 \\\\ 3 & 4 \\\\ \\end{vmatrix} ]",
                "command": "TableText({1, 2}, {3, 4}, \"||\")"
            },
            {
                "description": "TableText({1, 2}, {3, 4}, \"||||\") creates the text stem:[\\begin{Vmatrix}{} 1 & 2 \\\\ 3 & 4 \\\\ \\end{Vmatrix} ]",
                "command": "TableText({1, 2}, {3, 4}, \"||||\")"
            },
            {
                "description": "TableText({{\"2x+3y=5\",\"5x+8y=12\"}},\"{v\") creates the text stem:[ \\left\\{\\begin{matrix} 2x+3y=5\\\\ 5x+8y=12 \\end{matrix}\\right.]",
                "command": "TableText({{\"2x+3y=5\",\"5x+8y=12\"}},\"{v\")"
            },
            {
                "description": "TableText({{1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}}, \"-/|_v\") creates a table with border and no separation lines.",
                "command": "TableText({{1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}}, \"-/|_v\")"
            },
            {
                "description": "TableText({{1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}}, \"|11001 _110001 h\") creates a table with border and one separation line to the right of the first column and under the first row of contents. The value 1 in the syntax means that there is a separation line between the numbers and the value 0 means that there is no separation line or border.",
                "command": "TableText({{1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}}, \"|11001 _110001 h\")"
            },
            {
                "description": "TableText({{\"\\blue{0, 1, 2, 3, 4}\", \"\\red{4, 3, 2, 1, 0}\"}}, \"v\") creates a table having the objects in the first row coloured in blue, the ones in the second row coloured in red.",
                "command": "TableText({{\"\\blue{0, 1, 2, 3, 4}\", \"\\red{4, 3, 2, 1, 0}\"}}, \"v\")"
            }
        ],
        "note": "By default, each list is displayed in its own row of the table. Possible values for alignment are \"vl\", \"vc\", \"vr\", \"v\", \"h\", \"hl\", \"hc\", \"hr\" and \".\" or \"%\" - the default value is \"hl\". The width and the height of a TableText depend on the font size setting. It's also possible to insert different types of brackets, line separators, column separators, and different colourings. The Style Bar of a TableText object allows the user to customize the object's appearance, background and text colour and text style. Online examples by Mike (https://www.geogebra.org/m/Eq5T3vV3)."
    },
    {
        "signature": "Name( <Object> )",
        "commandBase": "Name",
        "description": "Returns the name of an object as a text in the Graphics View.",
        "examples": [
            {
                "description": "Returns the name of an object as a text in the Graphics View.",
                "command": "Name( <Object> )"
            }
        ],
        "note": "This command works properly only in dynamic text for objects (so that they work after objects are renamed). The Name command is the opposite of the Object command."
    },
    {
        "signature": "DivisorsSum( <Number> )",
        "commandBase": "DivisorsSum",
        "description": "Calculates the sum of all the positive divisors, including the number itself.",
        "examples": [
            {
                "description": "DivisorsSum(15) yields 24, the sum 1 + 3 + 5 + 15.",
                "command": "DivisorsSum(15)"
            }
        ],
        "note": "See also Divisors Command and DivisorsList Command."
    },
    {
        "signature": "Intersect( <Object>, <Object> ) | Intersect( <Object>, <Object>, <Index of Intersection Point> ) | Intersect( <Object>, <Object>, <Initial Point> ) | Intersect( <Function>, <Function>, <Start x-Value>, <End x-Value> ) | Intersect( <Curve 1>, <Curve 2>, <Parameter 1>, <Parameter 2> )",
        "commandBase": "Intersect",
        "description": "Yields the intersection points of two objects, with multiple syntaxes for different object types and parameters.",
        "examples": [
            {
                "description": "Intersection points of a line and an ellipse",
                "command": "Intersect(a, c) where a: -3x + 7y = -10 and c: x2 + 2y2 = 8"
            },
            {
                "description": "Intersection of a line and a curve",
                "command": "Intersect(y = x + 3, Curve(t, 2t, t, 0, 10))"
            },
            {
                "description": "Intersection of two curves",
                "command": "Intersect(Curve(2s, 5s, s,-10, 10), Curve(t, 2t, t, -10, 10))"
            },
            {
                "description": "Nth intersection point of a function and a line",
                "command": "Intersect(a, b, 2) where a(x) = x3 + x2 - x and b: -3x + 5y = 4"
            },
            {
                "description": "Intersection point using initial point",
                "command": "Intersect(a, b, C) where a(x) = x3 + x2 - x, b: -3x + 5y = 4, and C = (0, 0.8)"
            },
            {
                "description": "Intersection points of two functions in an interval",
                "command": "Intersect(f, g, -1, 2) where f(x) = x3 + x2 - x and g(x) = 4 / 5 + 3 / 5 x"
            },
            {
                "description": "Intersection point of two curves using parameters",
                "command": "Intersect(a, b, 0, 2) where a = Curve(cos(t), sin(t), t, 0, π) and b = Curve(cos(t) + 1, sin(t), t, 0, π)"
            },
            {
                "description": "CAS syntax for intersection points of two functions",
                "command": "Intersect(f(x), g(x)) where f(x):= x3 + x2 - x and g(x):= x"
            }
        ],
        "note": "Multiple syntaxes exist for different object types (lines, conics, functions, curves, planes, etc.). Use {Intersect(a,b)} to get all intersection points in a list. See also IntersectConic, IntersectPath commands, and the Intersect tool."
    },
    {
        "signature": "ZMean2Estimate( <List of Sample Data 1>, <List of Sample Data 2>, <σ1>, <σ2>, <Confidence Level> ) or ZMean2Estimate( <Sample Mean 1>, <σ1>, <Sample Size 1>, <Sample Mean 2>, <σ2>, <Sample Size 2>, <Confidence Level> )",
        "commandBase": "ZMean2Estimate",
        "description": "Calculates a Z confidence interval estimate of the difference between two population means using the given sample data sets, population standard deviations and confidence level. Results are returned in list form as {lower confidence limit, upper confidence limit}.",
        "examples": [
            {
                "description": "Two sample data list1 = {1, 4, 5, 4, 1, 3, 4, 2}, list2 = {2, 1, 3, 1, 2, 5, 2, 4} are given. The standard deviation of list1 is σ_1 = sqrt(2), the standard deviation of list2 is σ_2 = sqrt(1.75) and the confidence level is 0.75.",
                "command": "ZMean2Estimate(list1, list2, σ_1, σ_2, 0.75)"
            },
            {
                "description": "Calculates a Z confidence interval estimate of the difference between two population means using the given sample means, population standard deviations and confidence level.",
                "command": "ZMean2Estimate( <Sample Mean 1>, <σ1>, <Sample Size 1>, <Sample Mean 2>, <σ2>, <Sample Size 2>, <Confidence Level> )"
            }
        ],
        "note": "The command has two signatures: one using sample data lists and another using sample means and sizes. Results are returned as a list {lower confidence limit, upper confidence limit}."
    },
    {
        "signature": "Union( <List>, <List> ) or Union( <Polygon>, <Polygon> )",
        "commandBase": "Union",
        "description": "Joins the two lists and removes elements that appear multiple times, or finds the union of two polygons under specific conditions.",
        "examples": [
            {
                "description": "Union of two lists",
                "command": "Union( {1, 2, 3, 4, 5}, {3, 2, 1, 7} ) yields {1, 2, 3, 4, 5, 7}."
            },
            {
                "description": "Union of two polygons",
                "command": "Union( <Polygon>, <Polygon> ) works only for non-self-intersecting polygons where the union is a single polygon."
            }
        ],
        "note": "For polygons, the operation is limited to cases where the polygons are not self-intersecting and the union results in a single polygon."
    },
    {
        "signature": "Solutions( <Equation> ) | Solutions( <Equation>, <Variable> ) | Solutions( <List of Equations>, <List of Variables> )",
        "commandBase": "Solutions",
        "description": "Solves equations for variables and returns a list of all solutions. From version 823, behaves like Solve command but returns a list of values instead of equations.",
        "examples": [
            {
                "description": "Solves a given equation for the main variable",
                "command": "Solutions(x^2 = 4x)"
            },
            {
                "description": "Solves an equation for a specific variable",
                "command": "Solutions(x * a^2 = 4a, a)"
            },
            {
                "description": "Solves a system of equations for multiple variables",
                "command": "Solutions({x = 4x + y, y + x = 2}, {x, y})"
            },
            {
                "description": "Solves another system of equations",
                "command": "Solutions({2a^2 + 5a + 3 = b, a + b = 3}, {a, b})"
            },
            {
                "description": "Example requiring manipulation for the solver to work",
                "command": "Solutions(TrigExpand(sin(5/4 π + x) - cos(x - 3/4 π) = sqrt(6) * cos(x) - sqrt(2)))"
            }
        ],
        "note": "From version 823, Solutions behaves like Solve but returns a list of values instead of equations. Sometimes manipulation (like TrigExpand) is needed for the solver to work. See also Solve Command."
    },
    {
        "signature": "Division( <Dividend Number>, <Divisor Number> )",
        "commandBase": "Division",
        "description": "Gives the quotient (integer part of the result) and the remainder of the division of the two numbers.",
        "examples": [
            {
                "description": "Division of numbers",
                "command": "Division(16, 3)"
            },
            {
                "description": "Division of polynomials",
                "command": "Division(x2 + 3 x + 1, x - 1)"
            },
            {
                "description": "Multivariable division in CAS View",
                "command": "Division(x2+y2, x+y)"
            },
            {
                "description": "Multivariable division with reversed terms",
                "command": "Division(x2+y2, y+x)"
            }
        ],
        "note": "In the Algebra View only one variable can be used and it will always be renamed to x. In the CAS View multivariable division is also supported."
    },
    {
        "signature": "Slope( <Line> )",
        "commandBase": "Slope",
        "description": "Returns the slope of the given line.",
        "examples": [
            {
                "description": "This command also draws the slope triangle whose size may be changed on tab Style of the Properties Dialog.",
                "command": "Slope( <Line> )"
            },
            {
                "description": "See also Slope tool.",
                "command": "Slope( <Line> )"
            }
        ],
        "note": "This command also draws the slope triangle whose size may be changed on tab Style of the Properties Dialog. See also Slope tool."
    },
    {
        "signature": "ComplexRoot( <Polynomial> )",
        "commandBase": "ComplexRoot",
        "description": "Finds the complex roots of a given polynomial in x. Points are created in Graphics View.",
        "examples": [
            {
                "description": "ComplexRoot(x2 + 4) yields (0 + 2 ί) and (0 - 2 ί) in CAS Syntax",
                "command": "ComplexRoot(x2 + 4)"
            },
            {
                "description": "ComplexRoot(x2 + 4) yields {- 2 ί, 2 ί}",
                "command": "ComplexRoot(x2 + 4)"
            }
        ],
        "note": "Use CSolve Command instead."
    },
    {
        "signature": "IsTangent( <Line>, <Conic> )",
        "commandBase": "IsTangent",
        "description": "Decides if the line is tangent to the conic. Normally this command computes the result numerically. This behavior can be changed by using the Prove command.",
        "examples": [
            {
                "description": "Check if a line is tangent to a circle",
                "command": "IsTangent(Line((0,0),(1,0)),Circle((0,1),1))"
            }
        ],
        "note": "See also AreCollinear, AreConcurrent, AreCongruent, AreConcyclic, AreEqual, AreParallel, ArePerpendicular commands."
    },
    {
        "signature": "ModularExponent( <Number>, <Number>, <Number> )",
        "commandBase": "ModularExponent",
        "description": "Returns the modular exponent of the given numbers. See also Modular exponentiation (https://en.wikipedia.org/wiki/Modular_exponentiation) for further details.",
        "examples": [
            {
                "description": "ModularExponent(5,12,13) yields 1, since mod(5^12,13)=1.",
                "command": "ModularExponent(5,12,13)"
            }
        ],
        "note": ""
    },
    {
        "signature": "PerpendicularVector( <Line> ), PerpendicularVector( <Segment> ), PerpendicularVector( <Vector> ), PerpendicularVector( <Plane> )",
        "commandBase": "PerpendicularVector",
        "description": "Returns one of the perpendicular vectors to the given geometric object (line, segment, vector, or plane). For lines, segments, and vectors, it returns a perpendicular vector; for planes, it creates an orthogonal vector.",
        "examples": [
            {
                "description": "Perpendicular vector to a line defined by two points",
                "command": "PerpendicularVector(Line((1, 4), (5, -3)))"
            },
            {
                "description": "Perpendicular vector to a segment with same length",
                "command": "PerpendicularVector(Segment((3, 2), (14, 5)))"
            },
            {
                "description": "Perpendicular vector to a given vector",
                "command": "PerpendicularVector(Vector((-12, 8)))"
            },
            {
                "description": "Perpendicular vector using undefined variables in CAS View",
                "command": "PerpendicularVector((a, b))"
            },
            {
                "description": "Orthogonal vector to a plane",
                "command": "PerpendicularVector(xOyPlane)"
            }
        ],
        "note": "If a point is specified in the definition of the line, segment, or vector, the perpendicular vector will originate from that point; otherwise, it originates at (0, 0). For planes, the vector starts at (0,0,0). In CAS View, undefined variables are allowed. See also UnitPerpendicularVector Command."
    },
    {
        "signature": "UpperSum( <Function>, <Start x-Value>, <End x-Value>, <Number of Rectangles> )",
        "commandBase": "UpperSum",
        "description": "Calculates the upper sum of the function on the interval [Start x-Value, End x-Value] using n rectangles.",
        "examples": [
            {
                "description": "Calculate upper sum for x² from -2 to 4 with 6 rectangles",
                "command": "UpperSum(x2, -2, 4, 6)"
            }
        ],
        "note": "This command draws the rectangles of the upper sum as well. This command is designed as a visual aid so won't give accurate answers if the number of rectangles is too large. See also the commands: LowerSum, LeftSum, RectangleSum, and TrapezoidalSum."
    },
    {
        "signature": "NSolutions( <Equation> ), NSolutions( <Equation>, <Variable> ), NSolutions( <Equation>, <Variable = starting value> ), NSolutions( <List of Equations>, <List of Variables> )",
        "commandBase": "NSolutions",
        "description": "Attempts (numerically) to find a solution for the equation for the main variable. For non-polynomials you should always specify a starting value.",
        "examples": [
            {
                "description": "Solve polynomial equation",
                "command": "NSolutions(x^6 - 2x + 1 = 0)"
            },
            {
                "description": "Solve equation with specified variable",
                "command": "NSolutions(a^4 + 34a^3 = 34, a)"
            },
            {
                "description": "Solve equation with starting value",
                "command": "NSolutions(cos(x) = x, x = 0)"
            },
            {
                "description": "Solve equation with starting value for specific variable",
                "command": "NSolutions(a^4 + 34a^3 = 34, a = 3)"
            },
            {
                "description": "Solve system of equations with starting values",
                "command": "NSolutions({pi / x = cos(x - 2y), 2 y - pi = sin(x)}, {x = 3, y = 1.5})"
            }
        ],
        "note": "If you don't give a starting point like a=3 or {x = 3, y = 1.5} the numerical algorithm may find it hard to find a solution (and giving a starting point doesn't guarantee that a solution will be found). The number of decimals depends on the chosen global rounding. NSolutions won't work for functions that are asymptotic to the x-axis. They can often be reformulated though. NSolutions will work only if the function is continuous. See also Solutions Command and NSolve Command."
    },
    {
        "signature": "Hyperbola( <Focus>, <Focus>, <Semimajor Axis Length> ), Hyperbola( <Focus>, <Focus>, <Segment> ), Hyperbola( <Focus>, <Focus>, <Point> )",
        "commandBase": "Hyperbola",
        "description": "Creates a hyperbola with given focus points and semimajor axis length, or with a segment defining the semimajor axis, or passing through a given point.",
        "examples": [
            {
                "description": "Creates a hyperbola with given focus points and semimajor axis length.",
                "command": "Hyperbola((0, -4), (2, 4), 1)"
            },
            {
                "description": "Creates a hyperbola with given focus points where the length of the semimajor axis equals the length of the segment.",
                "command": "Let a = Segment((0,1), (2,1)). Hyperbola((4, 1), (-2, 1), a)"
            },
            {
                "description": "Creates a hyperbola with given focus points passing through a given point.",
                "command": "Hyperbola((1, 1), (2, 1), (-2,-4))"
            }
        ],
        "note": "If the condition: 0 < 2*semimajor axis length < Distance between the focus points isn't met, you will get an ellipse. See also [Image: Mode hyperbola3.svg,width=24,height=24] Hyperbola tool."
    },
    {
        "signature": "Height( <Solid> )",
        "commandBase": "Height",
        "description": "Calculates the \"oriented\" height of the given solid.",
        "examples": [
            {
                "description": "Height( <Cone> ) calculates the \"oriented\" height of the given cone.",
                "command": "Height( <Cone> )"
            },
            {
                "description": "Height( <Cylinder> ) calculates the \"oriented\" height of the given cylinder.",
                "command": "Height( <Cylinder> )"
            },
            {
                "description": "Height( <Polyhedron> ) calculates the \"oriented\" height of the given solid polyhedron.",
                "command": "Height( <Polyhedron> )"
            }
        ],
        "note": ""
    },
    {
        "signature": "Exponential( <Lambda>, <Variable Value> ) and Exponential( <Lambda>, <Variable Value>, <Boolean Cumulative> )",
        "commandBase": "Exponential",
        "description": "Calculates the value of the cumulative distribution function (cdf) or probability density function (pdf) of an Exponential distribution at a given variable value, based on the lambda parameter and optional cumulative flag.",
        "examples": [
            {
                "description": "Calculate the cumulative distribution function at a specific value",
                "command": "Exponential(2, 1)"
            },
            {
                "description": "Calculate the cumulative distribution function with cumulative flag set to true",
                "command": "Exponential( <Lambda>, <Variable Value>, true )"
            },
            {
                "description": "Calculate the probability density function with cumulative flag set to false",
                "command": "Exponential( <Lambda>, x, false )"
            }
        ],
        "note": "This syntax returns the probability at a given value, which is the area under the Exponential distribution curve to the left of the given x-coordinate for cdf. CAS syntax example: Exponential(2, 1) yields approximately 0.86."
    },
    {
        "signature": "Iteration( <Function>, <Start Value>, <Number of Iterations> ) or Iteration( <Expression>, <Variable Name>, ..., <Start Values>, <Number of Iterations> )",
        "commandBase": "Iteration",
        "description": "Iterates a function or expression n times (n = number of iterations) using the given start value(s).",
        "examples": [
            {
                "description": "After defining f(x) = x^2, the command Iteration(f, 3, 2) gives you the result (3^2)^2 = 81.",
                "command": "Iteration(f, 3, 2)"
            },
            {
                "description": "To obtain the repeated addition of 7 to the number 3, define g(x) = x + 7, then Iteration(g, 3, 4) yields (((3+7) +7) +7) +7 = 31.",
                "command": "Iteration(g, 3, 4)"
            },
            {
                "description": "Iteration(a^2+1, a, {(1+ί)/(sqrt(2))}, 5) will do a repeated iteration on a complex number.",
                "command": "Iteration(a^2+1, a, {(1+ί)/(sqrt(2))}, 5)"
            }
        ],
        "note": "See IterationList Command for further details."
    },
    {
        "signature": "Pyramid( <Point>, <Point>, ...):\n  Returns a pyramid defined by the given points.\nPyramid( <Polygon>, <Point> ):\n  Creates a pyramid with the given polygon as base and the point as apex.\nPyramid( <Polygon>, <Height> ):\n  Returns a centered pyramid defined by the polygon as base and given height.",
        "commandBase": "Pyramid",
        "description": "Returns a pyramid defined by the given points.",
        "examples": [
            {
                "description": "Pyramid(A, B, C, D) creates the pyramid with base ABC and apex D.",
                "command": "Pyramid(A, B, C, D)"
            },
            {
                "description": "Pyramid(poly1, A) creates a pyramid with base poly1 and apex A.",
                "command": "Pyramid(poly1, A)"
            },
            {
                "description": "Pyramid(poly1, 3) creates a centered pyramid with base poly1 and height 3.",
                "command": "Pyramid(poly1, 3)"
            }
        ],
        "note": "See also Pyramid and Extrude to Pyramid tools."
    },
    {
        "signature": "Relation( <List> )",
        "commandBase": "Relation",
        "description": "Shows a message box that gives you information about the relation between two or more (up to 4) objects. This command allows you to find out whether two lines are perpendicular, two lines are parallel, two (or more) objects are equal, a point lies on a line or conic, a line is tangent or a passing line to a conic, three points are collinear, three lines are concurrent (or parallel), four points are concyclic (or collinear). Some of these checks can also be performed symbolically. If GeoGebra supports symbolic check for a certain property, the \"More\" button appears. By clicking it, GeoGebra may provide more information whether the property is true in general (eventually under certain conditions).",
        "examples": [],
        "note": "See also Relation tool."
    },
    {
        "signature": "Polynomial( <Function> ) | Polynomial( <List of Points> ) | Polynomial( <Function>, <Variable> )",
        "commandBase": "Polynomial",
        "description": "Yields the expanded polynomial function, creates interpolation polynomials from points, or expands functions as polynomials in specified variables.",
        "examples": [
            {
                "description": "Expand a function to polynomial form",
                "command": "Polynomial((x - 3)2)"
            },
            {
                "description": "Expand a multivariate expression to polynomial form",
                "command": "Polynomial(y2+(x+y)2)"
            },
            {
                "description": "Create interpolation polynomial from points",
                "command": "Polynomial({(1, 1), (2, 3), (3, 6)})"
            },
            {
                "description": "Expand function and write as polynomial in x (CAS syntax)",
                "command": "Polynomial((x - 3)2 + (a + x)2)"
            },
            {
                "description": "Expand function as polynomial in specified variable (CAS syntax)",
                "command": "Polynomial((x - 3)2 + (a + x)2, a)"
            }
        ],
        "note": "The command has multiple syntax forms: basic expansion, interpolation from points, and CAS syntax with optional variable specification for coefficient grouping."
    },
    {
        "signature": "CorrelationCoefficient( <List of x-coordinates>, <List of y-coordinates> )",
        "commandBase": "CorrelationCoefficient",
        "description": "Calculates the product moment correlation coefficient using the given x- and y-coordinates.",
        "examples": [
            {
                "description": "Calculate correlation coefficient from x and y coordinate lists",
                "command": "CorrelationCoefficient({1, 3, 2, 1, 5, 2}, {1, 6, 4, 3, 3, 2})"
            },
            {
                "description": "Calculate correlation coefficient from a list of points",
                "command": "CorrelationCoefficient({(1, 1), (3, 6), (2, 4), (1, 3), (5, 3), (2, 2)})"
            }
        ],
        "note": "The command has two signatures: one accepting separate x and y coordinate lists, and another accepting a list of points. Both examples yield the same result of 0.36."
    },
    {
        "signature": "Rate( <Number of Periods>, <Payment>, <Present Value>, <Future Value (optional)>, <Type (optional)>, <Guess (optional)> )",
        "commandBase": "Rate",
        "description": "Returns the interest rate per period of an annuity.",
        "examples": [
            {
                "description": "Calculate monthly rate for a loan",
                "command": "Rate(5*12, -300, 10000)"
            }
        ],
        "note": "If you make monthly payments on a five-year loan use 5*12 for <Number of Periods>. For all arguments, cash paid out is represented by negative numbers and cash received by positive numbers. See also Payment, Periods, Present Value and Future Value commands."
    },
    {
        "signature": "Angle( <Object> )\nAngle( <Vector>, <Vector> )\nAngle( <Line>, <Line> )\nAngle( <Line>, <Plane> )\nAngle( <Plane>, <Plane> )\nAngle( <Point>, <Apex>, <Point> )\nAngle( <Point>, <Apex>, <Angle> )\nAngle( <Point>, <Point>, <Point>, <Direction> )",
        "commandBase": "Angle",
        "description": "Returns angles based on different inputs: conic sections, vectors, points, numbers, polygons, lines, planes, and combinations thereof, with results in degrees or radians depending on the default angle unit.",
        "examples": [
            {
                "description": "Returns the angle of twist of a conic section's major axis",
                "command": "Angle(x²/4+y²/9=1)"
            },
            {
                "description": "Returns the angle between the x-axis and a vector",
                "command": "Angle(Vector((1, 1)))"
            },
            {
                "description": "Returns the angle between the x-axis and a point",
                "command": "Angle((1, 1))"
            },
            {
                "description": "Converts a number into an angle",
                "command": "Angle(20)"
            },
            {
                "description": "Creates all angles of a polygon",
                "command": "Angle(Polygon((4, 1), (2, 4), (1, 1)))"
            },
            {
                "description": "Returns the angle between two vectors",
                "command": "Angle(Vector((1, 1)), Vector((2, 5)))"
            },
            {
                "description": "Returns the angle between two lines",
                "command": "Angle(y = x + 2, y = 2x + 3)"
            },
            {
                "description": "Returns the angle between a line and a plane",
                "command": "Angle(Line((1, 2, 3),(-2, -2, 0)), z = 0)"
            },
            {
                "description": "Returns the angle between two planes",
                "command": "Angle(2x - y + z = 0, z = 0)"
            },
            {
                "description": "Returns the angle defined by three points",
                "command": "Angle((1, 1), (1, 4), (4, 2))"
            },
            {
                "description": "Draws an angle of specified size from a point with an apex",
                "command": "Angle((0, 0), (3, 3), 30°)"
            },
            {
                "description": "Returns the angle defined by points and a direction",
                "command": "Angle((1, -1, 0),(0, 0, 0),(-1, -1, 0), zAxis)"
            }
        ],
        "note": "The command has multiple signatures for different object types. Results depend on the default angle unit (degrees or radians). In GeoGebra 5.0 Web and Tablet App Version, it is not possible to change the Angle Unit to Radian. For polygons, orientation affects whether interior or exterior angles are returned. Using a Direction in 3D allows bypassing standard angle display intervals. See also Angle and Angle with Given Size tools."
    },
    {
        "signature": "SetLineStyle( <Line>, <Number> )",
        "commandBase": "SetLineStyle",
        "description": "Changes the line style of given object according to following table (numbers out of range [0,4] are treated as 0).",
        "examples": [
            {
                "description": "Set line style to Full (0)",
                "command": "SetLineStyle( <Line>, 0 )"
            },
            {
                "description": "Set line style to Dashed long (1)",
                "command": "SetLineStyle( <Line>, 1 )"
            },
            {
                "description": "Set line style to Dashed short (2)",
                "command": "SetLineStyle( <Line>, 2 )"
            },
            {
                "description": "Set line style to Dotted (3)",
                "command": "SetLineStyle( <Line>, 3 )"
            },
            {
                "description": "Set line style to Dash-dot (4)",
                "command": "SetLineStyle( <Line>, 4 )"
            }
        ],
        "note": "Numbers out of range [0,4] are treated as 0. Valid styles: 0=Full, 1=Dashed long, 2=Dashed short, 3=Dotted, 4=Dash-dot."
    },
    {
        "signature": "Tetrahedron( <Equilateral Triangle> )\nTetrahedron( <Point>, <Point>, <Direction> )\nTetrahedron( <Point>, <Point>, <Point>)\nTetrahedron( <Point>, <Point>)",
        "commandBase": "Tetrahedron",
        "description": "Creates a tetrahedron using various input combinations: with an equilateral triangle as base; with two points and a direction to determine other vertices; with three points forming an equilateral triangle; or with two points where the third is automatically generated on a circle for rotation around the first edge.",
        "examples": [
            {
                "description": "Tetrahedron(A, B) is a shortcut for Tetrahedron(A, B, C) with C = Point(Circle(Midpoint(A, B), Distance(A, B) sqrt(3) / 2, Segment(A, B)))",
                "command": "Tetrahedron(A, B)"
            },
            {
                "description": "See also Cube, Octahedron, Icosahedron, Dodecahedron commands",
                "command": "Tetrahedron(A, B, C)"
            }
        ],
        "note": "For Tetrahedron( <Point>, <Point>, <Direction> ), the direction must be a vector, segment, line, ray orthogonal to the segment, or a polygon/plane parallel to the segment. The created tetrahedron will have a face with the segment as an edge in a plane orthogonal to the vector/segment/line/ray, or parallel to the polygon/plane. For Tetrahedron( <Point>, <Point>, <Point>), the three points must form an equilateral triangle."
    },
    {
        "signature": "DynamicCoordinates( <Point>, <x-Coordinate>, <y-Coordinate> )",
        "commandBase": "DynamicCoordinates",
        "description": "Creates a new point with given coordinates: this point is dependent, but can be moved. Whenever you try to move the new point to coordinates (x, y), the given point is moved there and coordinates for the new point are calculated. Works best if the given point is not visible and dragging is done with the mouse. At least one of the given coordinates should depend on the given point.",
        "examples": [
            {
                "description": "Let A be a point and B = DynamicCoordinates(A, round(x(A)), round(y(A))). When you try to move B to (1.3, 2.1) using the Move Tool, point A becomes (1.3, 2.1) and B appears at (1,2).",
                "command": "B = DynamicCoordinates(A, round(x(A)), round(y(A)))"
            },
            {
                "description": "B = DynamicCoordinates(A, x(A), min(y(A), sin(x(A)))) creates a point under sin(x).",
                "command": "B = DynamicCoordinates(A, x(A), min(y(A), sin(x(A))))"
            },
            {
                "description": "Let A = Point(xAxis) and B = Point(xAxis). Now type in the Input Bar: DynamicCoordinates(B, Min(x(B), x(A)), 0) and press Enter. SetVisibleInView(B, 1, false) and press Enter. SetLayer(C, 1) and press Enter. Now, C cannot be moved to the right of A.",
                "command": "DynamicCoordinates(B, Min(x(B), x(A)), 0)"
            },
            {
                "description": "Define A=(1, 2). Now, type in the Input Bar: SetVisibleInView(A, 1, false) and press Enter. B = DynamicCoordinates(A, If(x(A) > 3, 3, If(x(A) < -3, -3, If(x(A) < 0, round(x(A)), x(A)))), If(x(A) < 0, 0.5, If(y(A) > 2, 2, If(y(A) < 0, 0, y(A))))) and press Enter.",
                "command": "B = DynamicCoordinates(A, If(x(A) > 3, 3, If(x(A) < -3, -3, If(x(A) < 0, round(x(A)), x(A)))), If(x(A) < 0, 0.5, If(y(A) > 2, 2, If(y(A) < 0, 0, y(A)))))"
            },
            {
                "description": "This example makes A a sticky point when a point C is dragged near it. Define A = (1, 2) and B = (2, 3). Now, type in the Input Bar: SetVisibleInView(B, 1, false) and press Enter. C = DynamicCoordinates(B, If(Distance(A, B) < 1, x(A), x(B)), If(Distance(A, B) < 1, y(A), y(B))).",
                "command": "C = DynamicCoordinates(B, If(Distance(A, B) < 1, x(A), x(B)), If(Distance(A, B) < 1, y(A), y(B)))"
            }
        ],
        "note": "PointIn(y < sin(x)) is the easier solution in this case. The following examples show other ways to restrain the positions of a point C. Also note: DynamicCoordinates( <Point>, <x-Coordinate>, <y-Coordinate>, <z-Coordinate> ) creates a new 3D point with given coordinates: this point is dependent, but can be moved. Whenever you try to move the new point to coordinates (x, y, z), the given point is moved there and coordinates for the new point are calculated. Works best if the given point is not visible and dragging is done with the mouse. At least one of the given coordinates should depend on the given point."
    },
    {
        "signature": "Directrix( <Conic> )",
        "commandBase": "Directrix",
        "description": "Yields the directrix of the conic.",
        "examples": [
            {
                "description": "Directrix(x2 - 3x + 3y = 9) yields the line y = 4.5",
                "command": "Directrix(x2 - 3x + 3y = 9)"
            }
        ],
        "note": "See also the Focus command."
    },
    {
        "signature": "NormalQuantilePlot( <List of Raw Data> )",
        "commandBase": "NormalQuantilePlot",
        "description": "Creates a normal quantile plot from the given list of data and draws a line through the points showing the ideal plot for exactly normal data. Points are formed by plotting data values on the _x_-axis against their expected normal score (Z-score) on the _y_-axis. More precisely the _y_-values are computed using Filliben's estimate.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Tangent( <Point>, <Conic> ), Tangent( <Point>, <Function> ), Tangent( <Point on Curve>, <Curve> ), Tangent( <x-Value>, <Function> ), Tangent( <Line>, <Conic> ), Tangent( <Circle>, <Circle> ), Tangent( <Point>, <Spline> ), Tangent( <Point>, <Implicit Curve> )",
        "commandBase": "Tangent",
        "description": "Creates tangents based on different input combinations, such as from a point to a conic or function, from a line to a conic, between circles, or to curves like splines or implicit curves.",
        "examples": [
            {
                "description": "Tangent from a point to a conic section",
                "command": "Tangent((5, 4), 4x2 - 5y2 = 20)"
            },
            {
                "description": "Tangent to a function at the x-coordinate of a point",
                "command": "Tangent((1, 0), x2)"
            },
            {
                "description": "Tangent to a curve at a given point on the curve",
                "command": "Tangent((0, 1), Curve(cos(t), sin(t), t, 0, π))"
            },
            {
                "description": "Tangent to a function at a specific x-value",
                "command": "Tangent(1, x2)"
            },
            {
                "description": "Tangents to a conic section parallel to a given line",
                "command": "Tangent(y = 4, x2 + y2 = 4)"
            },
            {
                "description": "Common tangents to two circles",
                "command": "Tangent(x2 + y2 = 4, (x - 6)2 + y2 = 4)"
            },
            {
                "description": "Tangent to a spline at a given point",
                "command": "Tangent(A, Spline({A, B, C}))"
            },
            {
                "description": "Tangent to an implicit curve at a given point",
                "command": "Tangent((1,1), x2+y2=1)"
            }
        ],
        "note": "x(A) is the x-coordinate of the given point A. See also Tangents tool."
    },
    {
        "signature": "Semicircle( <Point>, <Point> )",
        "commandBase": "Semicircle",
        "description": "Creates a semicircle above the segment between the two points and displays its length in Algebra View.",
        "examples": [
            {
                "description": "Semicircle( <Point>, <Point> )",
                "command": "Semicircle( <Point>, <Point> )"
            }
        ],
        "note": "See also [Image: Mode semicircle.svg,width=24,height=24] Semicircle tool."
    },
    {
        "signature": "Line tool and FitLine Command",
        "commandBase": "Line tool and FitLine",
        "description": "If you work with big/small numbers, you should consider normalizing them for a more accurate result, see Normalize Command.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Delete( <Object> )",
        "commandBase": "Delete",
        "description": "Deletes the object and all its dependent objects.",
        "examples": [
            {
                "description": "Let P be a point, sli a slider, and seg=Segment(P, sli). The command Delete(sli) deletes the slider sli and the segment seg, but doesn't delete point P from the construction, since the point does not depend on the slider sli.",
                "command": "Delete(sli)"
            },
            {
                "description": "Let P be a point, sli a slider, and seg=Segment(P,sli). The command Delete(sli) deletes the slider sli and the segment seg, but doesn't delete point P from the construction, since the point does not depend on the slider sli.",
                "command": "Delete(sli)"
            }
        ],
        "note": "See also [Image: Mode delete.svg,width=24,height=24] Delete tool."
    },
    {
        "signature": "OsculatingCircle( <Point>, <Function> )",
        "commandBase": "OsculatingCircle",
        "description": "Yields the osculating circle of the object (function, curve, conic) in the given point.",
        "examples": [
            {
                "description": "Osculating circle of a function at a point",
                "command": "OsculatingCircle((0, 0), x^2)"
            },
            {
                "description": "Osculating circle of a curve at a point",
                "command": "OsculatingCircle((1, 0), Curve(cos(t), sin(2t), t, 0, 2π))"
            },
            {
                "description": "Osculating circle examples for function, curve, and conic",
                "command": "OsculatingCircle((0, 0), x^2); OsculatingCircle((1, 0), Curve(cos(t), sin(2t), t, 0, 2π)); OsculatingCircle((-1, 0), Conic({1, 1, 1, 2, 2, 3}))"
            }
        ],
        "note": "This command is for 2D objects only. For 3D, you can make a custom tool, e.g., at https://www.geogebra.org/m/tan7dxjt"
    },
    {
        "signature": "CSolve( <Equation> ) | CSolve( <Equation>, <Variable> ) | CSolve( <List of Equations>, <List of Variables> )",
        "commandBase": "CSolve",
        "description": "Solves a given equation for the main variable and returns a list of all solutions, allowing for complex solutions.",
        "examples": [
            {
                "description": "Solves x² = -1 for complex solutions",
                "command": "CSolve(x² = -1)"
            },
            {
                "description": "Solves a² = -1 for variable a with complex solutions",
                "command": "CSolve(a² = -1, a)"
            },
            {
                "description": "Solves a system of equations {y² = x - 1, x = 2y - 1} for variables {x, y} with complex solutions",
                "command": "CSolve({y² = x - 1, x = 2y - 1}, {x, y})"
            }
        ],
        "note": "The complex ί is obtained by pressing ALT + i. See also CSolutions Command and Solve Command."
    },
    {
        "signature": "RandomPointIn( <Region> ):\nCreates a random point inside a given polygon or closed conic.\nRandomPointIn( <List of Points> ):\nReturns a random point inside the polygon with given vertices.\n[EXAMPLE]\nRandomPointIn(Polygon(A,B,C)) and RandomPointIn(A,B,C) both give random point inside triangle ABC.\nTo get a random point that belongs to the list use Random Element instead.\nRandomPointIn( <xMin>, <xMax>, <yMin>, <yMax> ):\nCreates a random point with x-coordinate from interval [xMin,xMax] and y-coordinate from interval [yMin, yMax].",
        "commandBase": "RandomPointIn",
        "description": "Creates a random point inside a given polygon, closed conic, or within specified coordinate intervals.",
        "examples": [
            {
                "description": "Creates a random point inside a given polygon or closed conic, or from a list of points defining a polygon.",
                "command": "RandomPointIn(Polygon(A,B,C)) or RandomPointIn(A,B,C)"
            },
            {
                "description": "Creates a random point with x-coordinate from interval [xMin,xMax] and y-coordinate from interval [yMin, yMax].",
                "command": "RandomPointIn( <xMin>, <xMax>, <yMin>, <yMax> )"
            }
        ],
        "note": "To get a random point that belongs to a list, use Random Element instead."
    },
    {
        "signature": "InverseTDistribution( <Degrees of Freedom>, <Probability> )",
        "commandBase": "InverseTDistribution",
        "description": "Evaluates at p the inverse of the cumulative distribution function of a t-distribution with the given number of degrees of freedom. Finds r such that P(X≤r)=p, where X is a random variable with a t-distribution. Probability p must be a value in the closed interval [0,1].",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Extremum( <Polynomial> ) or Extremum( <Function>, <Start x-Value>, <End x-Value> )",
        "commandBase": "Extremum",
        "description": "Yields all local extrema of the polynomial function as points on the function graph or calculates (numerically) the extremum of the function in the open interval ( <Start x-Value>, <End x-Value> ).",
        "examples": [
            {
                "description": "Create local extrema for a polynomial",
                "command": "Extremum(x³ + 3x² - 2x + 1)"
            },
            {
                "description": "Calculate extremum in a specific interval",
                "command": "Extremum((x⁴ - 3x³ - 4x² + 4) / 2, 0, 5)"
            },
            {
                "description": "CAS syntax for local extrema of a continuous and differentiable function",
                "command": "Extremum(x³ + 3x² - 2x + 1)"
            },
            {
                "description": "Assume range and find local turning points",
                "command": "Assume(0 < x < 20, Extremum(15/2 * sin( 2/15*pi * x) + 56/5))"
            }
        ],
        "note": "This command differs among variants of English: Extremum (US), TurningPoint (UK + Aus). The function should be continuous in [ <Start x-Value>, <End x-Value> ], otherwise false extrema near discontinuity might be calculated."
    },
    {
        "signature": "Identity( <Number> )",
        "commandBase": "Identity",
        "description": "Gives the identity matrix of the given order.",
        "examples": [
            {
                "description": "Identity(3) yields the matrix stem:[\\begin{pmatrix}1&0&0\\\\0&1&0\\\\0&0&1\\end{pmatrix}].",
                "command": "Identity(3)"
            },
            {
                "description": "If A is a square matrix of order n, A0 yields the same as Identity(n).",
                "command": "A0"
            }
        ],
        "note": ""
    },
    {
        "signature": "RightSide( <Equation> ) | RightSide( <List of Equations> ) | RightSide( <List of Equations>, <Index> )",
        "commandBase": "RightSide",
        "description": "Gives the right-hand side of the simplified equation or list of equations.",
        "examples": [
            {
                "description": "Get the right-hand side of a single equation",
                "command": "RightSide(x + 2 = 3x + 1)"
            },
            {
                "description": "Get the right-hand side of a single equation (CAS syntax example)",
                "command": "RightSide(x + 3 = 3 x + 1)"
            },
            {
                "description": "Get the list of right-hand sides from multiple equations",
                "command": "RightSide({a2 + b2 = c2, x + 2 = 3x + 1})"
            },
            {
                "description": "Get the right-hand side of a specific equation by index",
                "command": "RightSide({a2 + b2 = c2, x + 2 = 3 x + 1}, 1)"
            }
        ],
        "note": "See also LeftSide Command."
    },
    {
        "signature": "FitLineX( <List of Points> )",
        "commandBase": "FitLineX",
        "description": "Calculates the x on y regression line of the points.",
        "examples": [
            {
                "description": "FitLineX with a list of points",
                "command": "FitLineX({(-1, 3), (2, 1), (3, 4), (5, 3), (6, 5)})"
            },
            {
                "description": "CAS Syntax example for FitLineX",
                "command": "FitLineX({(-1, 3), (2, 1), (3, 4), (5, 3), (6, 5)})"
            }
        ],
        "note": "See also Best Fit"
    },
    {
        "signature": "Function( <List of Numbers> ) | Function(Function, Start x-value, End x-value) | Function( <Expression>, <Parameter Variable 1>, <Start Value>, <End Value>, <Parameter Variable 2>, <Start Value>, <End Value> )",
        "commandBase": "Function",
        "description": "Yields a function or restricts visualization of a function based on the input format: 1) Creates a piecewise function from a list of numbers where first two are x-range and rest are y-values; 2) Restricts 2D function visualization to an interval; 3) Restricts 3D surface visualization for two-variable functions.",
        "examples": [
            {
                "description": "Creates a triangular wave between x = 2 and x = 4",
                "command": "Function[{2, 4, 0, 1, 0, 1, 0}]"
            },
            {
                "description": "Creates a linear equation with slope = 1 between x = -3 and x = 3",
                "command": "Function[{-3, 3, 0, 1, 2, 3, 4, 5}]"
            },
            {
                "description": "Restricts visualization of y = x + 2 to interval [1, 2]",
                "command": "Function(x + 2, 1, 2)"
            },
            {
                "description": "Creates a 3D surface for function b(u,v)=u restricted to u in [0,3] and v in [0,2]",
                "command": "Function[u, u, 0, 3, v, 0, 2]"
            }
        ],
        "note": "The command has three distinct overloads for different purposes: creating piecewise functions from numeric lists, restricting 2D function graphs, and defining 3D surfaces for two-variable functions."
    },
    {
        "signature": "ShowGrid( ), ShowGrid( <Boolean> ), ShowGrid( <View>, <Boolean> )",
        "commandBase": "ShowGrid",
        "description": "Shows the grid in the active View. Shows/hides the grid in the active View. Shows/hides the grid in the Graphics View specified by the number 1 or 2 (or 3 for 3D View).",
        "examples": [
            {
                "description": "Shows the grid in the active View",
                "command": "ShowGrid(true)"
            },
            {
                "description": "Hides the grid in the active View",
                "command": "ShowGrid(false)"
            },
            {
                "description": "Shows the grid in Graphics View",
                "command": "ShowGrid(1, true)"
            },
            {
                "description": "Hides the grid in Graphics 2 View",
                "command": "ShowGrid(2, false)"
            }
        ],
        "note": "See also ShowAxes command."
    },
    {
        "signature": "CompleteSquare( <Quadratic Function> )",
        "commandBase": "CompleteSquare",
        "description": "Returns the quadratic function in the form: a (x - h)2 + k.",
        "examples": [
            {
                "description": "CompleteSquare(x2 - 4x + 7) yields 1 (x - 2)2 + 3.",
                "command": "CompleteSquare(x2 - 4x + 7)"
            },
            {
                "description": "CompleteSquare(x2 - 4x + 7) yields (x - 2)2 + 3.",
                "command": "CompleteSquare(x2 - 4x + 7)"
            }
        ],
        "note": "CAS Syntax: CompleteSquare( <Quadratic Function> ) returns the quadratic function in the form: a(x-h)2+k."
    },
    {
        "signature": "Numeric( <Expression> ) or Numeric( <Expression>, <Significant Figures> )",
        "commandBase": "Numeric",
        "description": "Tries to determine a numerical approximation of the given expression. The number of decimals depends on the global rounding you choose in the Options Menu.",
        "examples": [
            {
                "description": "Numeric(3 / 2) yields 1.5.",
                "command": "Numeric(3 / 2)"
            },
            {
                "description": "Numeric(sin(1), 20) yields 0.84147098480789650665.",
                "command": "Numeric(sin(1), 20)"
            },
            {
                "description": "Numeric(-500000000/785398163*sin(785398163/500000000)*1258025227.192+500000000/785398163*1258025227.192,10) will give 4096 but Numeric(-500000000/785398163*sin(785398163/500000000)*1258025227.192+500000000/785398163*1258025227.192,30) will give 0.318309886345536696694580314215.",
                "command": "Numeric(-500000000/785398163*sin(785398163/500000000)*1258025227.192+500000000/785398163*1258025227.192,10) and Numeric(-500000000/785398163*sin(785398163/500000000)*1258025227.192+500000000/785398163*1258025227.192,30)"
            }
        ],
        "note": "If you don't specify enough digits then you can get an apparently wrong answer due to floating point cancelation (http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html). See also Numeric tool."
    },
    {
        "signature": "Circumference(Conic)",
        "commandBase": "Circumference",
        "description": "If the given conic is a circle or ellipse, this command returns its circumference. Otherwise the result is undefined.",
        "examples": [
            {
                "description": "Circumference of ellipse x² + 2y² = 1",
                "command": "Circumference(x2 + 2y2 = 1)"
            }
        ],
        "note": "See also Perimeter command."
    },
    {
        "signature": "CharacteristicPolynomial( <Matrix> )",
        "commandBase": "CharacteristicPolynomial",
        "description": "Returns the characteristic polynomial (https://en.wikipedia.org/wiki/Characteristic_polynomial) of the given matrix.",
        "examples": [
            {
                "description": "CharacteristicPolynomial({{1,2},{3,4}}) yields stem:[x2-5x-2].",
                "command": "CharacteristicPolynomial({{1,2},{3,4}})"
            }
        ],
        "note": "CAS Syntax"
    },
    {
        "signature": "IntersectPath( <Line>, <Polygon> ) | IntersectPath( <Polygon>, <Polygon> ) | IntersectPath( <Plane>, <Polygon> ) | IntersectPath( <Plane>, <Quadric> )",
        "commandBase": "IntersectPath",
        "description": "Creates the intersection path between different geometric objects: line and polygon, two polygons, plane and polygon, or plane and quadric.",
        "examples": [
            {
                "description": "Creates a segment between the first and second intersection point of line a and polygon triangle.",
                "command": "IntersectPath(a, triangle)"
            },
            {
                "description": "Creates a new polygon as intersection of the two given polygons.",
                "command": "IntersectPath(quadrilateral, triangle)"
            },
            {
                "description": "Creates a segment between the first and second intersection point of plane a and polygon triangle in the plane of the polygon.",
                "command": "IntersectPath(a, triangle)"
            },
            {
                "description": "Creates a circle as intersection between plane a and quadric sphere.",
                "command": "IntersectPath(a, sphere)"
            }
        ],
        "note": "The new polygon can either be a quadrilateral, a pentagon or a hexagon. This depends on the position of the vertices of the given polygons. See also Intersect and IntersectConic commands."
    },
    {
        "signature": "Element( <List>, <Position of Element n> )\nElement( <Matrix>, <Row>, <Column> )\nElement( <List>, <Index1>, <Index2>, ...)",
        "commandBase": "Element",
        "description": "Yields the nth element of the list. Yields the element of the matrix in the given row and column. Provided list is n-dimensional list, one can specify up to n indices to obtain an element (or list of elements) at given coordinates.",
        "examples": [
            {
                "description": "Element({1, 3, 2}, 2) yields 3, the second element of {1, 3, 2}.",
                "command": "Element({1, 3, 2}, 2)"
            },
            {
                "description": "Element({a, b, c}, 2) yields b, the second element of {a, b, c}.",
                "command": "Element({a, b, c}, 2)"
            },
            {
                "description": "Element({{1, 3, 2}, {0, 3, -2}}, 2, 3) yields -2, the third element of the second row of the matrix.",
                "command": "Element({{1, 3, 2}, {0, 3, -2}}, 2, 3)"
            },
            {
                "description": "Element({{a, b, c}, {d, e, f}}, 2, 3) yields f, the third element of the second row of the matrix.",
                "command": "Element({{a, b, c}, {d, e, f}}, 2, 3)"
            },
            {
                "description": "Let L = {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}}. Then Element(L, 1, 2, 1) yields 3, Element(L, 2, 2) yields {7, 8}.",
                "command": "Element(L, 1, 2, 1)"
            }
        ],
        "note": "In the CAS View undefined variables can be used as well. This command only works, if the list or matrix contains elements of one object type (e.g. only numbers or only points). See also First Command, Last Command and RandomElement Command."
    },
    {
        "signature": "Icosahedron( <Equilateral Triangle> )\nIcosahedron( <Point>, <Point>, <Direction> )\nIcosahedron( <Point>, <Point>, <Point> )\nIcosahedron( <Point>, <Point> )",
        "commandBase": "Icosahedron",
        "description": "Creates an icosahedron with various input methods: using an equilateral triangle as base, two points and a direction to define an edge and orientation, three points forming an equilateral triangle for the first face, or two points with automatic third point generation for rotation around the first edge.",
        "examples": [
            {
                "description": "Icosahedron(A, B) is a shortcut for Icosahedron(A, B, C) with C = Point(Circle(Midpoint(A, B), Distance(A, B) sqrt(3) / 2, Segment(A, B)))",
                "command": "Icosahedron(A, B)"
            },
            {
                "description": "See also Cube, Tetrahedron, Octahedron, Dodecahedron commands",
                "command": "Icosahedron"
            }
        ],
        "note": "The command supports multiple signatures for creating icosahedrons based on different geometric inputs, with specific constraints on direction types and point configurations."
    },
    {
        "signature": "HarmonicMean( <List of Numbers> )",
        "commandBase": "HarmonicMean",
        "description": "Returns the harmonic mean (https://en.wikipedia.org/wiki/Harmonic_mean) of given list of numbers.",
        "examples": [
            {
                "description": "HarmonicMean({13, 7, 26, 5, 19}) yields 9.79.",
                "command": "HarmonicMean({13, 7, 26, 5, 19})"
            }
        ],
        "note": ""
    },
    {
        "signature": "ParametricDerivative( <Curve> )",
        "commandBase": "ParametricDerivative",
        "description": "Returns a new parametric curve given by stem:[ \\left( x(t), \\frac{y'(t)}{ x'(t)} \\right) ].",
        "examples": [
            {
                "description": "ParametricDerivative(Curve(2t, t², t, 0, 10)) returns the parametric curve (x(t) = 2t, y(t) = t). The curve given as argument to the command is the function f(x) = stem:[ \\frac{x²}{4}], and the result is the derivative of that function: f'(x) = stem:[ \\frac{x}{2}].",
                "command": "ParametricDerivative(Curve(2t, t², t, 0, 10))"
            }
        ],
        "note": ""
    },
    {
        "signature": "Covariance( <List of Numbers>, <List of Numbers> ) or Covariance( <List of Points> )",
        "commandBase": "Covariance",
        "description": "Calculates the covariance between the elements of the specified lists or between the x and y coordinates of the specified points.",
        "examples": [
            {
                "description": "Covariance between two lists of numbers",
                "command": "Covariance({1, 2, 3}, {1, 3, 7})"
            },
            {
                "description": "Covariance from a list of points",
                "command": "Covariance({(1, 1), (2, 3), (3, 7)})"
            }
        ],
        "note": "The command yields 2 for both examples, representing the covariance of {1, 2, 3} and {1, 3, 7}."
    },
    {
        "signature": "Sector( <Conic>, <Point>, <Point> ) or Sector( <Conic>, <Parameter Value>, <Parameter Value> )",
        "commandBase": "Sector",
        "description": "Yields a conic sector between two points on the conic section and calculates its area, or yields a conic sector between two parameter values between 0 and 2π on the conic section and calculates its area.",
        "examples": [
            {
                "description": "Let c: x2 + 2y2 = 8 be an ellipse, D = (-2.83, 0) and E = (0, -2) two points on the ellipse.",
                "command": "Sector(c, D, E)"
            },
            {
                "description": "Let c: x2 + y2 = 9 be a circle, A = (3, 0) and B = (0, 3) two points on the circle.",
                "command": "Sector(c, A, B)"
            },
            {
                "description": "Let c: x2 + y2 = 9 be a circle.",
                "command": "Sector(c, 0, 3/4 π)"
            }
        ],
        "note": "This works only for a circle or ellipse. Internally the following parametric forms are used: • Circle: (r cos(t), r sin(t)) where r is the circle's radius. • Ellipse: (a cos(t), b sin(t)) where a and b are the lengths of the semimajor and semiminor axes."
    },
    {
        "signature": "Gamma( <Alpha>, <Beta>, <Variable Value> ) or Gamma( <Alpha>, <Beta>, <Variable Value>, <Boolean Cumulative> ) or Gamma( <Alpha>, <Beta>, x, <Boolean Cumulative> )",
        "commandBase": "Gamma",
        "description": "Calculates the value of the cumulative distribution function (cdf) or probability density function (pdf) of a Gamma distribution at a given variable value, based on parameters alpha and beta, and optionally a cumulative flag.",
        "examples": [
            {
                "description": "Calculates the cumulative distribution function (cdf) of a Gamma distribution at variable value v, i.e., the probability P(X ≤ v).",
                "command": "Gamma( <Alpha>, <Beta>, <Variable Value> )"
            },
            {
                "description": "If Cumulative = true, calculates the cdf; otherwise, calculates the pdf of the Gamma distribution at the given variable value.",
                "command": "Gamma( <Alpha>, <Beta>, <Variable Value>, <Boolean Cumulative> )"
            },
            {
                "description": "If Cumulative = true, creates the cdf; otherwise, creates the pdf of the Gamma distribution.",
                "command": "Gamma( <Alpha>, <Beta>, x, <Boolean Cumulative> )"
            }
        ],
        "note": "This syntax returns the probability at a given value, that is the area under the Gamma distribution curve to the left of the given x-coordinate for cdf, or the density value for pdf."
    },
    {
        "signature": "ContinuedFraction( <Number>, <Level> (optional), <Boolean Shorthand> )",
        "commandBase": "ContinuedFraction",
        "description": "Creates the continued fraction approximating a given number. The fraction is computed numerically within precision 10-8.",
        "examples": [
            {
                "description": "Creates the continued fraction approximating a given number. The result is a LaTeX text object.",
                "command": "ContinuedFraction(5.45)"
            },
            {
                "description": "Creates the continued fraction approximating the given number with a specified level. The number of quotients is less than or equal to Level, but never exceeding the number of quotients needed to achieve the numerical precision of 10-8.",
                "command": "ContinuedFraction(5.45, 3)"
            },
            {
                "description": "Creates the continued fraction approximating the given number with optional level and shorthand syntax. When Shorthand is true, the LaTeX text uses a shorter syntax and contains a list of the integer parts.",
                "command": "ContinuedFraction(5.45, true)"
            },
            {
                "description": "Creates the continued fraction approximating the given number with specified level and shorthand syntax.",
                "command": "ContinuedFraction(5.45, 3, true)"
            }
        ],
        "note": "The fraction is computed numerically within precision 10-8. The number of quotients is limited by the Level parameter but never exceeds what's needed for the specified precision."
    },
    {
        "signature": "FDistribution( <Numerator Degrees of Freedom>, <Denominator Degrees of Freedom>, <Variable Value> ) or FDistribution( <Numerator Degrees of Freedom>, <Denominator Degrees of Freedom>, <Variable Value>, <Boolean Cumulative> )",
        "commandBase": "FDistribution",
        "description": "Calculates the value of the cumulative distribution function (CDF) or probability density function (PDF) of an F-distribution at a given variable value, depending on the presence and value of the Boolean Cumulative parameter.",
        "examples": [
            {
                "description": "Calculates the value of the cumulative distribution function of an F-distribution at variable value v, i.e. the probability P(X≤v) where X is a random variable with F-distribution with given numerator and denominator degrees of freedom.",
                "command": "FDistribution( <Numerator Degrees of Freedom>, <Denominator Degrees of Freedom>, <Variable Value> )"
            },
            {
                "description": "If Cumulative = true, calculates the value of the cumulative distribution function of an F-distribution with given numerator and denominator degrees of freedom at the given variable value, otherwise it calculates the probability density function of the F-distribution at variable value.",
                "command": "FDistribution( <Numerator Degrees of Freedom>, <Denominator Degrees of Freedom>, <Variable Value>, <Boolean Cumulative> )"
            },
            {
                "description": "If Cumulative = true, creates the cumulative density function (cdf) of an F-distribution with given numerator and denominator degrees of freedom, otherwise it creates the probability density function (pdf) of the distribution.",
                "command": "FDistribution( <Numerator Degrees of Freedom>, <Denominator Degrees of Freedom>, x, <Boolean Cumulative> )"
            }
        ],
        "note": "This command is also available in the CAS View."
    },
    {
        "signature": "Volume( <Solid> )",
        "commandBase": "Volume",
        "description": "Calculates the volume of the given solid.",
        "examples": [
            {
                "description": "Volume( <Pyramid> ) calculates the volume of the given pyramid.",
                "command": "Volume( <Pyramid> )"
            },
            {
                "description": "Volume( <Prism> ) calculates the volume of the given prism.",
                "command": "Volume( <Prism> )"
            },
            {
                "description": "Volume( <Cone> ) calculates the volume of the given cone.",
                "command": "Volume( <Cone> )"
            },
            {
                "description": "Volume( <Cylinder> ) calculates the volume of the given cylinder.",
                "command": "Volume( <Cylinder> )"
            }
        ],
        "note": "See also [Image: Mode volume.svg,width=24,height=24] Volume tool."
    },
    {
        "signature": "Median( <List of Raw Data> )",
        "commandBase": "Median",
        "description": "Determines the median of the list elements.",
        "examples": [
            {
                "description": "Median of {1, 2, 3} yields 2",
                "command": "Median({1, 2, 3})"
            },
            {
                "description": "Median of {1, 1, 8, 8} yields 4.5",
                "command": "Median({1, 1, 8, 8})"
            }
        ],
        "note": "If the length of the given list is even, the arithmetic mean of the two center elements is returned. See also Mean command."
    },
    {
        "signature": "Frequency( <List of Raw Data> )\nFrequency( <Boolean Cumulative>, <List of Raw Data> )\nFrequency( <List of Class Boundaries>, <List of Raw Data> )\nFrequency( <List of Text>, <List of Text> )\nFrequency( <Boolean Cumulative>, <List of Class Boundaries>, <List of Raw Data> )\nFrequency( <List of Class Boundaries>, <List of Raw Data>, <Use Density> , <Density Scale Factor> (optional) )\nFrequency( <Boolean Cumulative>, <List of Class Boundaries>, <List of Raw Data>, <Use Density> , <Density Scale Factor>(optional) )",
        "commandBase": "Frequency",
        "description": "Returns a list with a count of the occurrences of each unique value in the given list of data. This input list can be numbers or text. The list is sorted in ascending order of the unique values. To get a list of the corresponding unique values use the Unique Command.",
        "examples": [
            {
                "description": "Enter list1 = { \"a\", \"a\", \"x\", \"x\", \"x\", \"b\" }. Frequency(list1) returns the list { 2, 1, 3 }. Unique(list1) returns the list { \"a\", \"b\", \"x\" }.",
                "command": "Frequency(list1)"
            },
            {
                "description": "Enter list1 = { 0, 0, 0, 1, 1, 2 }. Frequency(true, list1) returns the list { 3, 5, 6 }. Frequency(false, list1) returns the list { 3, 2, 1}. Unique(list1) returns the list { 0, 1, 2 }.",
                "command": "Frequency(true, list1)"
            },
            {
                "description": "Frequency({1, 2, 3}, {1, 1, 2, 3}) returns the list { 2, 2 }.",
                "command": "Frequency({1, 2, 3}, {1, 1, 2, 3})"
            },
            {
                "description": "Let list1 = {\"a\", \"b\", \"b\", \"c\", \"c\", \"c\", \"c\"} and list2 = {\"a\", \"b\", \"a\", \"a\", \"c\", \"c\", \"d\"}. Then Frequency(list1, list2) returns the matrix stem:[\\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 1 &1 & 0 &0 \\\\ 1 & 0 & 2 & 1 \\\\ \\end{pmatrix}]",
                "command": "Frequency(list1, list2)"
            },
            {
                "description": "Let data = {1, 2, 2, 2, 3, 3, 4, 4, 4, 4} be the list of raw data and classes={0, 2, 5} the list of class boundaries. Then Frequency(classes, data, false) and Frequency(classes, data) both return the list {1, 9}, while Frequency(classes, data, true) returns the list {0.5, 3}.",
                "command": "Frequency(classes, data, true)"
            }
        ],
        "note": "See also the ContingencyTable command."
    },
    {
        "signature": "SetConditionToShowObject( <Object>, <Condition> ):",
        "commandBase": "SetConditionToShowObject",
        "description": "Sets the condition to show given object.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "InverseExponential( <Lambda>, <Probability> )",
        "commandBase": "InverseExponential",
        "description": "Computes the inverse of the cumulative distribution function of an Exponential distribution at probability p, where the Exponential distribution is defined by the given parameter lambda. In other words, finds t such that P(X ≤ t) = p, where X is an Exponential random variable. Probability p must be a value in the closed interval [0,1].",
        "examples": [],
        "note": ""
    },
    {
        "signature": "SampleSDY( <List of Points> )",
        "commandBase": "SampleSDY",
        "description": "Returns the sample standard deviation (https://en.wikipedia.org/wiki/Standard_deviationEstimation) of the _y_-coordinates of the points in the given list.",
        "examples": [
            {
                "description": "SampleSDY({(2, 3), (1, 5), (3, 6), (4, 2), (1, 1), (2, 5)}) yields a = 1.97.",
                "command": "SampleSDY({(2, 3), (1, 5), (3, 6), (4, 2), (1, 1), (2, 5)})"
            }
        ],
        "note": ""
    },
    {
        "signature": "Direction( <Line> ): Yields the direction vector of the line. Circle( <Point>, <Radius Number> ): Yields a circle with given center and radius. Circle( <Point>, <Segment> ): Yields a circle with given center and radius equal to the length of the given segment. Circle( <Point>, <Point> ): Yields a circle with given center through a given point. Circle( <Point>, <Point>, <Point> ): Yields a circle through the three given points (if they do not lie on the same line). Circle( <Line>, <Point> ): Creates a circle with line as axis and through the point. Circle( <Point>, <Radius>, <Direction> ): Creates a circle with center, radius, and axis parallel to direction, which can be a line, vector or plane. Circle( <Point>, <Point>, <Direction> ): Creates a circle with center, through a point, and axis parallel to direction.",
        "commandBase": "Direction, Circle",
        "description": "Direction yields the direction vector of a line. Circle creates circles with various parameters such as center, radius, points, or direction.",
        "examples": [
            {
                "description": "Yields the direction vector of the line -2x + 3y + 1 = 0",
                "command": "Direction(-2x + 3y + 1 = 0)"
            },
            {
                "description": "Yields a circle with given center and radius",
                "command": "Circle( <Point>, <Radius Number> )"
            },
            {
                "description": "Yields a circle with given center and radius equal to the length of a segment",
                "command": "Circle( <Point>, <Segment> )"
            },
            {
                "description": "Yields a circle with given center through a given point",
                "command": "Circle( <Point>, <Point> )"
            },
            {
                "description": "Yields a circle through three given points (if not collinear)",
                "command": "Circle( <Point>, <Point>, <Point> )"
            },
            {
                "description": "Creates a circle with line as axis and through a point",
                "command": "Circle( <Line>, <Point> )"
            },
            {
                "description": "Creates a circle with center, radius, and axis parallel to direction",
                "command": "Circle( <Point>, <Radius>, <Direction> )"
            },
            {
                "description": "Creates a circle with center, through a point, and axis parallel to direction",
                "command": "Circle( <Point>, <Point>, <Direction> )"
            }
        ],
        "note": "For Direction: A line with equation ax + by = c has the direction vector (b, -a). For Circle: See also Compass, Circle with Center through Point, Circle with Center and Radius, and Circle through 3 Points tools. Avoid ambiguity in 2D/3D by not using equations like x = 0 or y = 0 for Direction; use expressions like x + 0y + 0z = 0 for plane direction. See also Circle with Axis through Point and Circle with Center, Radius and Direction tools."
    },
    {
        "signature": "RandomDiscrete( <List>, <List> )",
        "commandBase": "RandomDiscrete",
        "description": "Returns a random number from the first list according to the (relative) probability distribution defined in the second list. The two lists must have the same length, and the sum of values in the second list may not be 1, since the probabilities are normalized.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "LimitBelow( <Function>, <Value> )",
        "commandBase": "LimitBelow",
        "description": "Computes the left one-sided limit of the function for the given value of the main function variable.",
        "examples": [
            {
                "description": "Compute the left one-sided limit of 1/x as x approaches 0",
                "command": "LimitBelow(1 / x, 0)"
            },
            {
                "description": "Compute the left one-sided limit of 1/a as a approaches 0",
                "command": "LimitBelow(1 / a, a, 0)"
            }
        ],
        "note": "Not all limits can be calculated by GeoGebra, so undefined or ? will be returned in those cases (as well as when the correct result is undefined). See also Limit Command and LimitAbove Command."
    },
    {
        "signature": "Degree( <Polynomial> ) or Degree( <Polynomial>, <Variable> )",
        "commandBase": "Degree",
        "description": "Gives the degree of a polynomial (in the main variable or monomial).",
        "examples": [
            {
                "description": "Degree of a polynomial in the main variable",
                "command": "Degree(x4 + 2 x2)"
            },
            {
                "description": "Degree of a polynomial in multiple variables",
                "command": "Degree(x6 y3 + 2 x2 y3)"
            },
            {
                "description": "Degree of a polynomial in a specific variable x",
                "command": "Degree(x4 y3 + 2 x2 y3, x)"
            },
            {
                "description": "Degree of a polynomial in a specific variable y",
                "command": "Degree(x4 y3 + 2 x2 y3, y)"
            }
        ],
        "note": "The command has two syntax forms: one for the main variable and one for a specified variable. Examples show outputs like 'yields 4' or 'yields 9'."
    },
    {
        "signature": "SetFilling( <Object>, <Number> )",
        "commandBase": "SetFilling",
        "description": "Changes the opacity of given object. Number must be from interval [0,1], where 0 means transparent and 1 means 100% opaque. Other numbers are ignored.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Invert( <Matrix> ):\n  Inverts the given matrix.\nInvert( <Function> ):\n  Gives the inverse of the function.",
        "commandBase": "Invert",
        "description": "Inverts the given matrix or gives the inverse of the function.",
        "examples": [
            {
                "description": "Invert a matrix with specific values",
                "command": "Invert({{1, 2}, {3, 4}})"
            },
            {
                "description": "Invert a matrix with undefined variables",
                "command": "Invert({{a, b}, {c, d}})"
            },
            {
                "description": "Invert a function",
                "command": "Invert(sin(x))"
            }
        ],
        "note": "• In the CAS View undefined variables are allowed too.\n• No account is taken of domain or range, for example for f(x) = x2 or f(x) = sin(x).\n• The command works faster for functions that only contain one x. To make your construction more efficient you may want to rearrange your functions and use eg NInvert((x+1)2-1) rather than NInvert(x2+2x).\n• See also NInvert Command, Eigenvalues Command, Eigenvectors Command, SVD Command, Transpose Command, JordanDiagonalization Command."
    },
    {
        "signature": "ReplaceAll( <Text>, <Text to Match>, <Text to Replace> )",
        "commandBase": "ReplaceAll",
        "description": "Creates a new text containing the given text whose text to match has been replaced with the given text to replace.",
        "examples": [
            {
                "description": "Replace 'cos' with 'sin' in a string",
                "command": "ReplaceAll(\"3cos(t)+cos(2y)\", \"cos\", \"sin\")"
            },
            {
                "description": "Create a LaTeX text by using ReplaceAll within FormulaText",
                "command": "FormulaText(ReplaceAll(\"3cos(t)+cos(2y)\", \"cos\", \"sin\"))"
            }
        ],
        "note": "Use the FormulaText command to create a LaTeX text."
    },
    {
        "signature": "NIntegral( <Function> ) | NIntegral( <Function>, <Start x-Value>, <End x-Value> ) | NIntegral( <Function>, <Start x-Value>, <Start y-Value>, <End x-Value> ) | NIntegral( <Function>, <Variable>, <Start Value>, <End Value> )",
        "commandBase": "NIntegral",
        "description": "Computes and plots indefinite or definite integrals numerically. For indefinite integrals, plots the graph of y=F(x)+c with c=0. For definite integrals, computes the numerical value of the integral over a specified interval.",
        "examples": [
            {
                "description": "Plots the indefinite integral of e^(-x^2) with constant of integration c=0",
                "command": "NIntegral(ℯ^(-x^2))"
            },
            {
                "description": "Computes the definite integral of e^(-x^2) from 0 to 1, yielding 0.75",
                "command": "NIntegral(ℯ^(-x^2), 0, 1)"
            },
            {
                "description": "Plots the indefinite integral of sin(x)/x through point (π,1) in interval [π,2π]",
                "command": "NIntegral(sin(x)/x, π, 1, 2π)"
            },
            {
                "description": "Computes the definite integral of e^(-a^2) with respect to variable a from 0 to 1, yielding 0.75",
                "command": "NIntegral(ℯ^(-a^2), a, 0, 1)"
            }
        ],
        "note": "In the CAS View, the syntax NIntegral(<Function>, <Variable>, <Start Value>, <End Value>) can be used to compute definite integrals with respect to a specified variable. The indefinite integral equation is not shown in Algebra View as it is computed numerically."
    },
    {
        "signature": "AxisStepX( )",
        "commandBase": "AxisStepX",
        "description": "Returns the current step width for the _x_‐axis.",
        "examples": [
            {
                "description": "See also AxisStepY command.",
                "command": "AxisStepX( )"
            },
            {
                "description": "Together with the Corner and Sequence commands, the AxisStepX and AxisStepY commands allow you to create custom axes (also see section Customizing Coordinate Axes and Grid).",
                "command": "AxisStepX( )"
            }
        ],
        "note": "No additional note provided."
    },
    {
        "signature": "CurvatureVector( <Point>, <Object> )",
        "commandBase": "CurvatureVector",
        "description": "Yields the curvature vector of the object (function, curve, conic) in the given point.",
        "examples": [
            {
                "description": "CurvatureVector((0, 0), x2) yields vector (0, 2)",
                "command": "CurvatureVector((0, 0), x2)"
            },
            {
                "description": "CurvatureVector((0, 0), Curve(cos(t), sin(2t), t, 0, π)) yields vector (0, 0)",
                "command": "CurvatureVector((0, 0), Curve(cos(t), sin(2t), t, 0, π))"
            },
            {
                "description": "CurvatureVector((-1, 0), Conic({1, 1, 1, 2, 2, 3})) yields vector (0, -2)",
                "command": "CurvatureVector((-1, 0), Conic({1, 1, 1, 2, 2, 3}))"
            }
        ],
        "note": ""
    },
    {
        "signature": "ToComplex( <Vector> )",
        "commandBase": "ToComplex",
        "description": "Transforms a vector or point to a complex number in algebraic form.",
        "examples": [
            {
                "description": "ToComplex((3, 2)) yields 3 + 2ί.",
                "command": "ToComplex((3, 2))"
            }
        ],
        "note": "The complex ί is obtained by pressing ALT + i. See also ToExponential Command, ToPoint Command and ToPolar Command."
    },
    {
        "signature": "Eliminate( <List of Polynomials>, <List of Variables> )",
        "commandBase": "Eliminate",
        "description": "Considers the algebraic equation system defined by the polynomials, and computes an equivalent system after eliminating all variables in the given list.",
        "examples": [
            {
                "description": "Eliminate({x2 + x, y2 - x}, {x}) yields {stem:[ y{4} + y{2} ]}.",
                "command": "Eliminate({x^2 + x, y^2 - x}, {x})"
            }
        ],
        "note": "See also GroebnerLexDeg command."
    },
    {
        "signature": "Limit( <Function>, <Value> )",
        "commandBase": "Limit",
        "description": "Computes the limit (https://en.wikipedia.org/wiki/Limit_of_a_function) of the function for the given value of the main function variable. (This may also yield infinity.)",
        "examples": [
            {
                "description": "Limit((x2 + x) / x2, +∞) yields 1.",
                "command": "Limit((x2 + x) / x2, +∞)"
            },
            {
                "description": "Limit(a sin(x) / x, 0) yields a.",
                "command": "Limit(a sin(x) / x, 0)"
            },
            {
                "description": "Limit(a sin(v) / v, v, 0) yields a.",
                "command": "Limit(a sin(v) / v, v, 0)"
            }
        ],
        "note": "Not all limits can be calculated by GeoGebra, so undefined will be returned in those cases (as well as when the correct result is undefined). If you want the limit of a piecewise-defined function you need to use LimitAbove or LimitBelow, for example LimitAbove(If(x>1, x2, -2x), 1). See also Asymptote Command, LimitAbove Command and LimitBelow Command."
    },
    {
        "signature": "Denominator( <Expression> )",
        "commandBase": "Denominator",
        "description": "Returns the denominator of a rational number or expression.",
        "examples": [
            {
                "description": "For a function, returns the denominator of the function",
                "command": "Denominator(5 / (x2 + 2))"
            },
            {
                "description": "For a rational number returns its simplified denominator",
                "command": "Denominator(5 / 3)"
            },
            {
                "description": "Simplifies the denominator when possible",
                "command": "Denominator(10 / 6)"
            },
            {
                "description": "Returns 1 when numerator is divisible by denominator",
                "command": "Denominator(15 / 3)"
            },
            {
                "description": "Works with expressions involving multiple fractions",
                "command": "Denominator(2 / 3 + 1 / 15)"
            }
        ],
        "note": "For irrational input the denominator of its continued fraction is returned. See also Numerator Command and FractionText Command."
    },
    {
        "signature": "InfiniteCone( <Point>, <Vector>, <Angle α> ): Creates an infinite cone with given point as vertex, axis of symmetry parallel to the given vector and apex angle 2α. InfiniteCone( <Point>, <Point>, <Angle α> ): Creates an infinite cone with given first point as vertex, line through two points as axis of symmetry and apex angle 2α. InfiniteCone( <Point>, <Line>, <Angle α> ): Creates an infinite cone with given point as vertex, axis of symmetry parallel to given line and apex angle 2α.",
        "commandBase": "InfiniteCone",
        "description": "Creates an infinite cone with specified parameters for vertex, axis of symmetry, and apex angle.",
        "examples": [
            {
                "description": "Creates an infinite cone with given point as vertex, axis of symmetry parallel to the given vector and apex angle 2α.",
                "command": "InfiniteCone( <Point>, <Vector>, <Angle α> )"
            },
            {
                "description": "Creates an infinite cone with given first point as vertex, line through two points as axis of symmetry and apex angle 2α.",
                "command": "InfiniteCone( <Point>, <Point>, <Angle α> )"
            },
            {
                "description": "Creates an infinite cone with given point as vertex, axis of symmetry parallel to given line and apex angle 2α.",
                "command": "InfiniteCone( <Point>, <Line>, <Angle α> )"
            }
        ],
        "note": "If you enter the angle without the degree symbol, you will get the apex angle in radian. See also the Cone command and [Image: Mode cone.svg,width=24,height=24] Cone tool."
    },
    {
        "signature": "Dilate( <Object>, <Dilation Factor> ) or Dilate( <Object>, <Dilation Factor>, <Dilation Center Point> )",
        "commandBase": "Dilate",
        "description": "Dilates the object from a point of origin using the given factor, or from a specified dilation center point.",
        "examples": [
            {
                "description": "Dilate an object with a dilation factor",
                "command": "Dilate( <Object>, <Dilation Factor> )"
            },
            {
                "description": "Dilate an object with a dilation factor and a specific center point",
                "command": "Dilate( <Object>, <Dilation Factor>, <Dilation Center Point> )"
            }
        ],
        "note": "This command differs among variants of English: Dilate (US), Enlarge (UK + Aus). When dilating polygons, GeoGebra creates also all the transformed vertices and segments. See also Dilate from Point by Factor tool."
    },
    {
        "signature": "Row( <Spreadsheet Cell> )",
        "commandBase": "Row",
        "description": "Returns the row number of the spreadsheet cell (starting at 1).",
        "examples": [
            {
                "description": "Row(B3) yields r = 3.",
                "command": "Row(B3)"
            }
        ],
        "note": ""
    },
    {
        "signature": "PresentValue( <Rate>, <Number of Periods>, <Payment>, <Future Value (optional)>, <Type (optional)> )",
        "commandBase": "PresentValue",
        "description": "Returns the total amount of payments of an investment.",
        "examples": [
            {
                "description": "Calculate present value with payment due at end of period",
                "command": "PresentValue(12%/12, 4*12, -100, 5000, 0)"
            },
            {
                "description": "Calculate present value with payment due at beginning of period",
                "command": "PresentValue(12%/12, 4*12, -100, 5000, 1)"
            }
        ],
        "note": "Make sure that you are consistent about the units you use for <Rate> and <Number of Periods>. If you make monthly payments on a four-year loan at an annual interest rate of 12 percent, use 12%/12 for rate and 4*12 for number of payments. For all arguments, cash paid out is represented by negative numbers and cash received by positive numbers. See also Payment, Periods, Rate and Future Value commands."
    },
    {
        "signature": "TaylorPolynomial( <Function>, <x-Value>, <Order Number> )",
        "commandBase": "TaylorPolynomial",
        "description": "Creates the Taylor series expansion of the given function at the point x-Value up to the given order.",
        "examples": [
            {
                "description": "Taylor series expansion of x² at x = 3 up to order 1",
                "command": "TaylorPolynomial(x², 3, 1)"
            },
            {
                "description": "Taylor series expansion of x² at x = a up to order 1",
                "command": "TaylorPolynomial(x², a, 1)"
            },
            {
                "description": "Taylor series expansion with respect to x of x³ sin(y) at x = 3 up to order 2",
                "command": "TaylorPolynomial(x³ sin(y), x, 3, 2)"
            },
            {
                "description": "Taylor series expansion with respect to y of x³ sin(y) at y = 3 up to order 2",
                "command": "TaylorPolynomial(x³ sin(y), y, 3, 2)"
            }
        ],
        "note": "The order has got to be an integer greater or equal to zero."
    },
    {
        "signature": "Conic( <Point>, <Point>, <Point>, <Point>, <Point> ) | Conic( <Number a>, <Number b>, <Number c>, <Number d>, <Number e>, <Number f> ) | Conic( <List> )",
        "commandBase": "Conic",
        "description": "Returns a conic section through the five given points or defined by coefficients.",
        "examples": [
            {
                "description": "Returns a conic section through five given points",
                "command": "Conic((0, -4), (2, 4), (3,1), (-2,3), (-3,-1))"
            },
            {
                "description": "Returns a conic section defined by coefficients a, b, c, d, e, f",
                "command": "Conic(2, 3, -1, 4, 2, -3)"
            },
            {
                "description": "Returns a conic section defined by a list of coefficients",
                "command": "Conic({2, 3, -1, 4, 2, -3})"
            }
        ],
        "note": "If four of the points lie on one line, then the conic section is not defined. See also Conic through 5 Points tool and Coefficients command."
    },
    {
        "signature": "SDX( <List of Points> )",
        "commandBase": "SDX",
        "description": "Returns the standard deviation of the _x_-coordinates of the points in the given list.",
        "examples": [
            {
                "description": "Calculate standard deviation of x-coordinates for a set of points",
                "command": "SDX({(1, 1), (2, 2), (3, 1), (3, 3), (4, 2), (3, -1)})"
            }
        ],
        "note": "The result for the example is approximately 0.94."
    },
    {
        "signature": "SetImage( <Object>, <Image> )",
        "commandBase": "SetImage",
        "description": "Fills the given object with an image. The object needs to allow filling, e.g. polygons, closed conics, buttons. Alternatively, fills the object with one of GeoGebra's predefined action images, identified by specific text strings.",
        "examples": [
            {
                "description": "Shows GeoGebra's predefined Pause icon on button1",
                "command": "SetImage(button1,\"pause\")"
            }
        ],
        "note": "The current version of the command supports only button objects. The names of the images (Text parameter) need to be enclosed in \" \". Predefined action images include: pause, play, stop, replay, skip_next, skip_previous, loop, zoom_in, zoom_out, close, arrow_up, arrow_down, arrow_forward, arrow_back, fast_forward, fast_rewind, zoom_to_fit, center_view, help, settings."
    },
    {
        "signature": "LeftSide( <Equation> ) or LeftSide( <List of Equations> ) or LeftSide( <List of Equations>, <Index> )",
        "commandBase": "LeftSide",
        "description": "Gives the left-hand side of the simplified equation or equations.",
        "examples": [
            {
                "description": "Get left-hand side of a single equation",
                "command": "LeftSide(4x = 1 - 3y)"
            },
            {
                "description": "Get left-hand side of another equation",
                "command": "LeftSide(x + 2 = 3 x + 1)"
            },
            {
                "description": "Get list of left-hand sides from multiple equations",
                "command": "LeftSide({a2 + b2 = c2, x + 2 = 3 x + 1})"
            },
            {
                "description": "Get left-hand side of specific equation by index",
                "command": "LeftSide({a2 + b2 = c2, x + 2 = 3 x + 1}, 1)"
            }
        ],
        "note": "See also RightSide Command."
    },
    {
        "signature": "FillColumn( <Column>, <List> )",
        "commandBase": "FillColumn",
        "description": "Copies values from the list to the first cells of the column given by number (1 for A, 2 for B, etc.). Resulting cells are free objects, i.e. independent of the list.",
        "examples": [
            {
                "description": "FillColumn( <Column>, <List> ): Copies values from the list to the first cells of the column given by number (1 for A, 2 for B, etc.). Resulting cells are free objects, i.e. independent of the list.",
                "command": "FillColumn( <Column>, <List> )"
            }
        ],
        "note": "See also the FillRow and FillCells commands."
    },
    {
        "signature": "Unique( <List> )",
        "commandBase": "Unique",
        "description": "Returns list of elements of the given list in ascending order, repetitive elements are included only once. Works for both a list of numbers and a list of text.",
        "examples": [
            {
                "description": "Unique({1, 2, 4, 1, 4}) yields {1, 2, 4}.",
                "command": "Unique({1, 2, 4, 1, 4})"
            },
            {
                "description": "Unique({\"a\", \"b\", \"Hello\", \"Hello\"}) yields {\"'Hello\", \"a\", \"b\"}.",
                "command": "Unique({\"a\", \"b\", \"Hello\", \"Hello\"})"
            },
            {
                "description": "Unique({1, x, x, 1, a}) yields {1, x, a}.",
                "command": "Unique({1, x, x, 1, a})"
            }
        ],
        "note": "See also Frequency command."
    },
    {
        "signature": "UpdateConstruction( ) or UpdateConstruction( <Number of times> )",
        "commandBase": "UpdateConstruction",
        "description": "Recomputes all objects (random numbers are regenerated). Same as F9 or Ctrl + R.",
        "examples": [
            {
                "description": "Recomputes all objects (random numbers are regenerated). Same as F9 or Ctrl + R.",
                "command": "UpdateConstruction( )"
            },
            {
                "description": "Performs the command UpdateConstruction() several times, e.g., to record several dice throws to the spreadsheet.",
                "command": "UpdateConstruction(2)"
            }
        ],
        "note": "If you want to refresh the view (e.g., to remove traces from Graphics View) you can use ZoomIn(1) instead, which is the same as Ctrl + F. You may also need SetActiveView(1) or SetActiveView(2) first to activate the View to update if you are using two Graphics Views."
    },
    {
        "signature": "Cube( <Square> )\nCube( <Point>, <Point>, <Direction> )\nCube( <Point>, <Point>, <Point>)\nCube( <Point>, <Point>)",
        "commandBase": "Cube",
        "description": "Creates a cube with various parameter combinations: using a square as base; using two points and a direction to define an edge and orientation; using three adjacent points to define a face; or using two adjacent points with automatic third point generation for rotation.",
        "examples": [
            {
                "description": "Cube(A, B) is a shortcut for Cube(A, B, C) with C = Point(Circle(B, Distance(A, B), Segment(A, B)))",
                "command": "Cube(A, B)"
            },
            {
                "description": "See also Tetrahedron, Octahedron, Icosahedron, Dodecahedron commands",
                "command": "Cube"
            }
        ],
        "note": "For Cube( <Point>, <Point>, <Direction> ), the direction should be one of: a vector, a segment, a line, a ray orthogonal to the segment, or a polygon, a plane parallel to the segment. The created cube will have a face with the segment as an edge in a plane orthogonal to the given vector/segment/line/ray, or a face with the segment as an edge in a plane parallel to the polygon/plane. For Cube( <Point>, <Point>, <Point>), the points have to start a square for the cube to be defined. For Cube( <Point>, <Point>), the third point is automatically created on a circle, so that the cube can rotate around its first edge."
    },
    {
        "signature": "LogNormal( <Mean>, <Standard Deviation>, <Variable Value> ) or LogNormal( <Mean>, <Standard Deviation>, <Variable Value>, <Boolean Cumulative> ) or LogNormal( <Mean>, <Standard Deviation>, x, <Boolean Cumulative> )",
        "commandBase": "LogNormal",
        "description": "Evaluates the cumulative distribution function (CDF) or probability density function (PDF) of a log-normal distribution based on the given parameters and variable value, with options for cumulative or non-cumulative calculations.",
        "examples": [
            {
                "description": "Evaluates the cumulative distribution function of a log-normal distribution at a variable value, calculating P(X ≤ v).",
                "command": "LogNormal( <Mean>, <Standard Deviation>, <Variable Value> )"
            },
            {
                "description": "Evaluates the CDF if Cumulative = true, otherwise evaluates the PDF of the distribution at the variable value.",
                "command": "LogNormal( <Mean>, <Standard Deviation>, <Variable Value>, <Boolean Cumulative> )"
            },
            {
                "description": "Creates the CDF if Cumulative = true, otherwise creates the PDF of the distribution.",
                "command": "LogNormal( <Mean>, <Standard Deviation>, x, <Boolean Cumulative> )"
            }
        ],
        "note": "This syntax returns the probability at a given value, that is the area under the log-normal distribution curve to the left of the given x-coordinate."
    },
    {
        "signature": "NSolveODE( <List of Derivatives>, <Initial x-coordinate>, <List of Initial y-coordinates>, <Final x-coordinate> )",
        "commandBase": "NSolveODE",
        "description": "Solves (numerically) the system of differential equations",
        "examples": [
            {
                "description": "Solve a system of three differential equations forward and backward in time",
                "command": "NSolveODE({f', g', h'}, 0, {1,2,-2}, 10)\nNSolveODE({f', g', h'}, 0, {1,2,-2}, -5) (solves the system backwards in time)."
            },
            {
                "description": "Solve a system of four differential equations with initial conditions",
                "command": "NSolveODE({x1', x2', x3', x4'}, 0, {x10, x20, x30, x40}, 20)"
            },
            {
                "description": "Solve a pendulum differential equation and create an animation",
                "command": "NSolveODE({y1', y2'}, 0, {a, b}, 20)"
            }
        ],
        "note": "See also SlopeField command, SolveODE command."
    },
    {
        "signature": "NSolve( <Equation> ), NSolve( <Equation>, <Variable> ), NSolve( <Equation>, <Variable = starting value> ), NSolve( <List of Equations>, <List of Variables> )",
        "commandBase": "NSolve",
        "description": "Attempts (numerically) to find a solution for the equation for the main variable. For non-polynomials you should always specify a starting value (see below).",
        "examples": [
            {
                "description": "Solve a polynomial equation",
                "command": "NSolve(x^6 - 2x + 1 = 0)"
            },
            {
                "description": "Solve an equation for a specific variable in CAS View",
                "command": "NSolve(a^4 + 34a^3 = 34, a)"
            },
            {
                "description": "Solve an equation with a starting value for the variable",
                "command": "NSolve(cos(x) = x, x = 0)"
            },
            {
                "description": "Solve a system of equations with starting values",
                "command": "NSolve({pi / x = cos(x - 2y), 2 y - pi = sin(x)}, {x = 3, y = 1.5})"
            }
        ],
        "note": "If you don't give a starting point like a=3 or {x = 3, y = 1.5} the numerical algorithm may find it hard to find a solution (and giving a starting point doesn't guarantee that a solution will be found). The number of decimals depends on the chosen global rounding. NSolve won't work for functions that are asymptotic to the x-axis or other extreme examples. They can often be reformulated though. NSolve will work only if the function is continuous! See also Solve Command and NSolutions Command."
    },
    {
        "signature": "IsInRegion( <Point>, <Region> )",
        "commandBase": "IsInRegion",
        "description": "Returns true if the point is in given region and false otherwise.",
        "examples": [
            {
                "description": "IsInRegion((1,2), Polygon((0,0), (2,0), (1,3))) returns true.",
                "command": "IsInRegion((1,2), Polygon((0,0), (2,0), (1,3)))"
            }
        ],
        "note": ""
    },
    {
        "signature": "Substitute( <Expression>, <from>, <to> ) or Substitute( <Expression>, <Substitution List> )",
        "commandBase": "Substitute",
        "description": "Replaces in expression all occurrences of from with to and evaluates the result when variables are substituted with values, or replaces in expression every occurrence of the variables in the substitution list with the corresponding terms or values, and evaluates numerical substitutions.",
        "examples": [
            {
                "description": "Substitute m with a in expression",
                "command": "Substitute((3 m - 3)2 - (m + 3)2, m, a)"
            },
            {
                "description": "Substitute m with 2 in expression",
                "command": "Substitute((3 m - 3)2 - (m + 3)2, m, 2)"
            },
            {
                "description": "Substitute multiple variables using list syntax",
                "command": "Substitute(2x + 3y - z, {x = a, y = 2, z = b})"
            },
            {
                "description": "Substitute multiple variables using parameter syntax",
                "command": "Substitute(2x + 3y - z, x = a, y = 2, z = b)"
            }
        ],
        "note": "CAS Syntax: The command can accept either three parameters (Expression, from, to) or two parameters (Expression, Substitution List). Numerical substitutions are evaluated automatically."
    },
    {
        "signature": "FrequencyTable( <List of Raw Data> ) | FrequencyTable( <Boolean Cumulative>, <List of Raw Data> ) | FrequencyTable( <List of Class Boundaries>, <List of Raw Data> ) | FrequencyTable( <Boolean Cumulative>, <List of Class Boundaries>, <List of Raw Data> ) | FrequencyTable( <List of Class Boundaries>, <List of Raw Data>, <Use Density> , <Density Scale Factor (optional)> ) | FrequencyTable( <Boolean Cumulative>, <List of Class Boundaries>, <List of Raw Data>, <Use Density> , <Density Scale Factor (optional)> ) | FrequencyTable( <List of Raw Data>,<Scale Factor (optional)> )",
        "commandBase": "FrequencyTable",
        "description": "Returns a table (as text) with frequency data. Multiple overloads handle different input combinations: basic frequency counts, cumulative frequencies, class intervals, density calculations, and scaling factors. Supports both numeric and text data.",
        "examples": [
            {
                "description": "Frequency table with scale factor for text data",
                "command": "FrequencyTable({\"red\", \"red\", \"green\", \"green\", \"blue\"}, 5)"
            },
            {
                "description": "Frequency table with scale factor for numeric data",
                "command": "FrequencyTable({1, 1, 1, 2, 2, 3, 3, 4, 5}, 2)"
            }
        ],
        "note": "This command is similar to Frequency Command and Histogram Command. Articles about these commands contain some related examples. In the list there appears 1 three-times, so the count of the occurences of 1 (=3) has to be multiplied by the scale factor 2 to get entry 6 in the second column."
    },
    {
        "signature": "SetPointSize( <Point>, <Number> )",
        "commandBase": "SetPointSize",
        "description": "Changes the size of the given point to the given number. Also applicable to lists of (unlabeled) points, e.g. if list={(1, 2), (3, 4)}, then SetPointSize(list,5) changes the size of the listed points.",
        "examples": [],
        "note": "The command is also applicable to lists of (unlabeled) points, e.g. if list={(1, 2), (3, 4)}, then SetPointSize(list,5) changes the size of the listed points."
    },
    {
        "signature": "SDY( <List of Points> )",
        "commandBase": "SDY",
        "description": "Returns the standard deviation of the _y_-coordinates of the points in the given list.",
        "examples": [
            {
                "description": "Calculate standard deviation of y-coordinates for a set of points",
                "command": "SDY({(1, 1), (2, 2), (3, 1), (3, 3), (4, 2), (3, -1)})"
            }
        ],
        "note": "The example yields a = 1.25."
    },
    {
        "signature": "SigmaXY( <List of Points> ) or SigmaXY( <List of x-coordinates>, <List of y-coordinates> )",
        "commandBase": "SigmaXY",
        "description": "Calculates the sum of the products of the x- and y-coordinates.",
        "examples": [
            {
                "description": "You can work out the covariance of a list of points using SigmaXY(list)/Length(list) - MeanX(list) * MeanY(list).",
                "command": "SigmaXY(list)"
            },
            {
                "description": "Let A = (-3, 4), B = (-1, 4), C = (-2, 3) and D = (1, 3) be points. {x(A), x(B), x(C), x(D)} yields the x-coordinates of the points in a list list1 = {-3, -1, -2, 1} and {y(A), y(B), y(C), y(D)} yields the y-coordinates of the points in a list list2 = {4, 4, 3, 3}. Command SigmaXY(list1, list2) yields a = -19.",
                "command": "SigmaXY(list1, list2)"
            }
        ],
        "note": "The command supports two signatures: one for a single list of points and another for separate lists of x- and y-coordinates."
    },
    {
        "signature": "Ray( <Start Point>, <Point> )",
        "commandBase": "Ray",
        "description": "Creates a ray starting at a point through a point.",
        "examples": [
            {
                "description": "Creates a ray starting at a point through a point.",
                "command": "Ray( <Start Point>, <Point> )"
            },
            {
                "description": "Creates a ray starting at the given point which has the direction vector.",
                "command": "Ray( <Start Point>, <Direction Vector> )"
            }
        ],
        "note": "When computing intersections with other objects, only intersections lying on the ray are considered. To change this, you can use Outlying Intersections option. See also [Image: Mode ray.svg,width=24,height=24] Ray tool."
    },
    {
        "signature": "Cylinder( <Circle>, <Height> )\nCylinder( <Point>, <Point>, <Radius> )",
        "commandBase": "Cylinder",
        "description": "Creates a cylinder with given base and given height. Creates a cylinder with given radius and with given points as the centers of the top and bottom.",
        "examples": [],
        "note": "See also the InfiniteCylinder command and the [Image: Mode cylinder.svg,width=24,height=24] Cylinder and [Image: Mode extrusion.svg,width=24,height=24] Extrude to Prism or Cylinder tools."
    },
    {
        "signature": "AreCongruent( <Object>, <Object> )",
        "commandBase": "AreCongruent",
        "description": "Decides if the objects are congruent. Normally this command computes the result numerically. This behavior can be changed by using the Prove command.",
        "examples": [
            {
                "description": "AreCongruent(Circle((0, 0),1),x2+y2=1) and AreCongruent(Circle((1, 1),1),x2+y2=1) yield true since the two circles have the same radius.",
                "command": "AreCongruent(Circle((0, 0),1),x2+y2=1)"
            }
        ],
        "note": "See also AreEqual, AreCollinear, AreConcyclic, AreConcurrent, ArePerpendicular, AreParallel, IsTangent commands."
    },
    {
        "signature": "Cell( <Column>, <Row> )",
        "commandBase": "Cell",
        "description": "Returns copy of spreadsheet cell in given column and row.",
        "examples": [
            {
                "description": "Cell(2, 1) returns copy of B1.",
                "command": "Cell(2, 1)"
            }
        ],
        "note": "By default the cells in spreadsheet cells are auxiliary and in such case this command returns auxiliary object as well. You must make sure that the cells you refer to are earlier in the Construction Protocol than this command."
    },
    {
        "signature": "AngleBisector( <Line>, <Line> ) or AngleBisector( <Point>, <Point>, <Point> )",
        "commandBase": "AngleBisector",
        "description": "Returns both angle bisectors of the lines or the angle bisector of the angle defined by the three points.",
        "examples": [
            {
                "description": "Angle bisectors of two lines",
                "command": "AngleBisector(x + y = 1, x - y = 2)"
            },
            {
                "description": "Angle bisector of an angle defined by three points",
                "command": "AngleBisector((1, 1), (4, 4), (7, 1))"
            }
        ],
        "note": "The second point is apex of this angle. See also [Image: Mode angularbisector.svg,width=20,height=20] Angle Bisector tool."
    },
    {
        "signature": "ToExponential( <Complex Number> )",
        "commandBase": "ToExponential",
        "description": "Transforms a complex number into its exponential form.",
        "examples": [
            {
                "description": "ToExponential(1 + ί) yields stem:[\\sqrt{2}e{\\frac{i\\pi}{4}}].",
                "command": "ToExponential(1 + ί)"
            }
        ],
        "note": "The complex ί is obtained by pressing [.kcode]ALT + [.kcode]i. See also ToPoint Command, ToComplex Command and ToPolar Command."
    },
    {
        "signature": "AxisStepY( )",
        "commandBase": "AxisStepY",
        "description": "Returns the current step width for the y-axis.",
        "examples": [],
        "note": "See also AxisStepX command. Together with the Corner and Sequence commands, the AxisStepX and AxisStepY commands allow you to create custom axes (also see section Customizing Coordinate Axes and Grid)."
    },
    {
        "signature": "Execute( <List of Texts> ) or Execute( <List of Texts>, <Parameter>, ... , <Parameter> )",
        "commandBase": "Execute",
        "description": "Executes a list of commands entered as texts, with optional parameters for placeholders.",
        "examples": [
            {
                "description": "Creates points A, B and their midpoint C",
                "command": "Execute({\"A=(1,1)\",\"B=(3,3)\",\"C = Midpoint(A, B)\"})"
            },
            {
                "description": "Creates the first 10 elements of the Fibonacci sequence",
                "command": "Execute(Join({\"f_{1} = 1\", \"f_{2} = 1\"}, Sequence(\"f_{\"+(i + 2) + \"} = f_{\" + (i+1) + \"} + f_{\"+ i +\"}\", i, 1, 10)))"
            },
            {
                "description": "Creates the segment AB and its midpoint using placeholders",
                "command": "Execute({\"Segment(%1,%2)\",\"Midpoint(%1,%2)\"}, A, B)"
            }
        ],
        "note": "The Execute command works only if the commands in the list are written in English (US), regardless of the language chosen for your GeoGebra interface. If the quote symbol (\") is not available on your keyboard, use the virtual keyboard of GeoGebra or the command UnicodeToLetter(34)."
    },
    {
        "signature": "TurtleUp( <Turtle> )",
        "commandBase": "TurtleUp",
        "description": "Instructs the named turtle not trace its movement from now.",
        "examples": [
            {
                "description": "TurtleUp( <Turtle> )",
                "command": "TurtleUp( <Turtle> )"
            }
        ],
        "note": "See also command TurtleDown"
    },
    {
        "signature": "Stretch( <Object>, <Vector> ) OR Stretch( <Object>, <Line>, <Ratio> )",
        "commandBase": "Stretch",
        "description": "The object is stretched parallel to the given vector by the ratio given by the magnitude of the vector (i.e. points on the line perpendicular to the vector (through its startpoint) stay on their place and distance of other points from the line is multiplied by given ratio.) OR The object is stretched perpendicular to the line by the given ratio (i.e. points on the line aren't moved and the distance of other points from the line is multiplied by given ratio.)",
        "examples": [
            {
                "description": "Stretch an object parallel to a vector",
                "command": "Stretch( <Object>, <Vector> )"
            },
            {
                "description": "Stretch an object perpendicular to a line with a specific ratio",
                "command": "Stretch( <Object>, <Line>, <Ratio> )"
            }
        ],
        "note": "In the first form, the stretching ratio is determined by the magnitude of the vector. In the second form, the stretching ratio is explicitly provided as the third parameter."
    },
    {
        "signature": "SlowPlot( <Function> )\nSlowPlot( <Function>, <Boolean Repeat> )",
        "commandBase": "SlowPlot",
        "description": "Creates an animated graph of the given function, plotted from left to right, with animation controlled by a slider created by this command. If Repeat is false, the graph is plotted only once; if true or omitted, it plots continuously.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "Payment( <Rate>, <Number of Periods>, <Present Value>, <Future Value (optional)>, <Type (optional)> )",
        "commandBase": "Payment",
        "description": "Calculates the payment for a loan based on constant payments and a constant interest rate.",
        "examples": [
            {
                "description": "Monthly payment for a loan",
                "command": "Payment(6%/12, 10, 10000, 0,1)"
            }
        ],
        "note": "Make sure that you are consistent about the units you use for <Rate> and <Number of Periods>. If you make monthly payments on a four-year loan at an annual interest rate of 6 percent, use 6%/12 for rate and 4*12 for number of payments. For all arguments, cash paid out is represented by negative numbers and cash received by positive numbers. See also Rate, Periods, Present Value and Future Value commands."
    },
    {
        "signature": "CellRange( <Start Cell>, <End Cell> )",
        "commandBase": "CellRange",
        "description": "Creates a list containing the cell values in this cell range.",
        "examples": [
            {
                "description": "Let A1 = 1, A2 = 4, A3 = 9 be spreadsheet cells values. Then CellRange(A1, A3) returns the list {1, 4, 9}.",
                "command": "CellRange(A1, A3)"
            }
        ],
        "note": "A1:A3 is a shorter syntax."
    },
    {
        "signature": "InteriorAngles( <Polygon> )",
        "commandBase": "InteriorAngles",
        "description": "Creates all the interior angles of the given polygon.",
        "examples": [
            {
                "description": "Creates all the interior angles of the given polygon.",
                "command": "InteriorAngles( <Polygon> )"
            }
        ],
        "note": "See also Angle command and [Image: Mode angle.svg,width=32,height=32] Angle tool."
    },
    {
        "signature": "QRDecomposition( <Matrix> )",
        "commandBase": "QRDecomposition",
        "description": "Calculates the QR decomposition (https://en.wikipedia.org/wiki/QR_decomposition) of the given matrix.",
        "examples": [
            {
                "description": "QRDecomposition({{1,2},{3,4}}) returns the matrices stem:[\\begin{pmatrix}\\frac{1}{\\sqrt{10}}&\\frac{3/5}{\\sqrt{10}/5}\\\\\\frac{3}{\\sqrt{10}}&-\\frac{1/5}{\\sqrt{10}/5}\\end{pmatrix}] and stem:[\\begin{pmatrix}\\sqrt{10}&7/5\\sqrt{10}\\\\0&\\sqrt{10}/5\\end{pmatrix}].",
                "command": "QRDecomposition({{1,2},{3,4}})"
            }
        ],
        "note": "See also LUDecomposition command."
    },
    {
        "signature": "FutureValue(<Rate>, <Number of Periods>, <Payment>, <Present Value (optional)>, <Type (optional)>)",
        "commandBase": "FutureValue",
        "description": "Returns the future value of an investment based on periodic, constant payments and a constant interest rate.",
        "examples": [
            {
                "description": "Example calculation with all parameters specified",
                "command": "FutureValue(10%/12, 15, -200, 0, 1)"
            }
        ],
        "note": "Make sure that you are consistent about the units you use for <Rate> and <Number of Periods>. If you make monthly payments on a four-year loan at an annual interest rate of 10 percent, use 10%/12 for rate and 4*12 for number of payments. For all arguments, cash paid out is represented by negative numbers and cash received by positive numbers. See also Payment, Rate, Present Value and Periods commands."
    },
    {
        "signature": "TurtleLeft( <Turtle>, <Angle> )",
        "commandBase": "TurtleLeft",
        "description": "The turtle turns to the left by a given angle.",
        "examples": [
            {
                "description": "TurtleLeft(turtle, 1) turns the turtle to the left by 1 rad, if Pause button is displayed. Otherwise you must press the Play button so that the rotation is effected.",
                "command": "TurtleLeft(turtle, 1)"
            },
            {
                "description": "If you enter TurtleLeft(turtle, 1°) the turtle turns to the left by 1 degree.",
                "command": "TurtleLeft(turtle, 1°)"
            }
        ],
        "note": "See also Turtle, TurtleBack, TurtleForward and TurtleRight commands."
    },
    {
        "signature": "Trilinear( <Point>, <Point>, <Point>, <Number>, <Number>, <Number> )",
        "commandBase": "Trilinear",
        "description": "creates a point whose trilinear coordinates (https://en.wikipedia.org/wiki/Trilinear_coordinates) are the given numbers with respect to triangle with given points.",
        "examples": [
            {
                "description": "Creates point A with trilinear coordinates (1, 0, 0)",
                "command": "Trilinear( A, B, C, 1, 0, 0 )"
            },
            {
                "description": "Creates point B with trilinear coordinates (0, 1, 0)",
                "command": "Trilinear( A, B, C, 0, 1, 0 )"
            },
            {
                "description": "Creates point C with trilinear coordinates (0, 0, 1)",
                "command": "Trilinear( A, B, C, 0, 0, 1 )"
            },
            {
                "description": "Creates the circumcenter with trilinear coordinates (cos(A), cos(B), cos(C))",
                "command": "Trilinear( A, B, C, cos(A), cos(B), cos(C) )"
            },
            {
                "description": "Creates the center of incircle with trilinear coordinates (1, 1, 1)",
                "command": "Trilinear( A, B, C, 1, 1, 1 )"
            },
            {
                "description": "Creates the center of excircle tangent to [BC] with trilinear coordinates (-1, 1, 1)",
                "command": "Trilinear( A, B, C, -1, 1, 1 )"
            },
            {
                "description": "Creates the center of excircle tangent to [AC] with trilinear coordinates (1, -1, 1)",
                "command": "Trilinear( A, B, C, 1, -1, 1 )"
            },
            {
                "description": "Creates the center of excircle tangent to [AB] with trilinear coordinates (1, 1, -1)",
                "command": "Trilinear( A, B, C, 1, 1, -1 )"
            },
            {
                "description": "Creates the centroid with trilinear coordinates (1/a, 1/b, 1/c)",
                "command": "Trilinear( A, B, C, 1/a, 1/b, 1/c )"
            },
            {
                "description": "Creates the orthocenter with trilinear coordinates (cos(B)cos(C), cos(A)cos(C), cos(A)cos(B))",
                "command": "Trilinear( A, B, C, cos(B)*cos(C), cos(A)*cos(C), cos(A)*cos(B) )"
            }
        ],
        "note": "The examples are based on a triangle defined by points A, B, and C, with specific trilinear coordinates for various triangle centers as listed in the table."
    },
    {
        "signature": "SolveCubic(<Cubic Polynomial>)",
        "commandBase": "SolveCubic",
        "description": "Solves a given cubic polynomial and returns a list of all solutions.",
        "examples": [
            {
                "description": "CAS Syntax example: SolveCubic(x³ - 1) yields solutions including complex roots",
                "command": "SolveCubic(x³ - 1)"
            },
            {
                "description": "For cumbersome answers, consider using Solve or CSolve instead",
                "command": "Solve(x³ + x² + x + 2) or CSolve(x³ + x² + x + 2)"
            }
        ],
        "note": "Often the answers are very cumbersome, in which case Solve(x³ + x² + x + 2) or CSolve(x³ + x² + x + 2) may work better for you."
    },
    {
        "signature": "Top( <Quadric> )",
        "commandBase": "Top",
        "description": "Creates the top of the limited quadric.",
        "examples": [
            {
                "description": "Top( cylinder ) yields a circle.",
                "command": "Top( cylinder )"
            },
            {
                "description": "Top( cone ) yields the cone end (point).",
                "command": "Top( cone )"
            }
        ],
        "note": "See also Bottom Command, Ends Command and Side Command."
    },
    {
        "signature": "PointIn( <Region> )",
        "commandBase": "PointIn",
        "description": "Returns a point restricted to given region.",
        "examples": [],
        "note": "See also [Image: Mode attachdetachpoint.svg,width=22,height=22] Attach / Detach Point Tool."
    },
    {
        "signature": "RSquare( <List of Points>, <Function> )",
        "commandBase": "RSquare",
        "description": "Calculates the coefficient of determination (https://en.wikipedia.org/wiki/Coefficient_of_determination) R² = 1 - SSE / Syy, between the _y_-values of the points in the list and the function values of the _x_-values in the list.",
        "examples": [
            {
                "description": "RSquare({(-3, 2), (-2, 1), (-1, 3), (0, 4), (1, 2), (2, 4), (3, 3), (4, 5), (6, 4)}, 0.5x + 2.5) yields 0.28.",
                "command": "RSquare({(-3, 2), (-2, 1), (-1, 3), (0, 4), (1, 2), (2, 4), (3, 3), (4, 5), (6, 4)}, 0.5x + 2.5)"
            }
        ],
        "note": ""
    },
    {
        "signature": "NextPrime( <Number> )",
        "commandBase": "NextPrime",
        "description": "Returns the smallest prime greater than the entered number.",
        "examples": [
            {
                "description": "NextPrime(10000) yields 10007.",
                "command": "NextPrime(10000)"
            }
        ],
        "note": "See also PreviousPrime Command."
    },
    {
        "signature": "ConjugateDiameter( <Line>, <Conic> ) or ConjugateDiameter( <Vector>, <Conic> )",
        "commandBase": "ConjugateDiameter",
        "description": "Returns the conjugate diameter of the diameter that is parallel to the given line or vector (relative to the conic section).",
        "examples": [
            {
                "description": "Get conjugate diameter for a line relative to a conic section",
                "command": "ConjugateDiameter(-4x + 5y = -2, x2 + 4 y2 + 2x - 8y + 1 = 0)"
            },
            {
                "description": "Get conjugate diameter for a vector relative to a conic section",
                "command": "ConjugateDiameter(u, x2 + 4 y2 + 2x - 8y + 1 = 0)"
            }
        ],
        "note": "The function accepts either a line or a vector as the first argument, along with a conic section as the second argument. The result is a line representing the conjugate diameter."
    },
    {
        "signature": "Polar( <Point>, <Conic> ): Creates the polar line of the given point relative to the conic section. Polar(<Line>, <Conic>): Creates the pole, given a polar line and a conic.",
        "commandBase": "Polar",
        "description": "Creates the polar line of the given point relative to the conic section, or creates the pole given a polar line and a conic.",
        "examples": [
            {
                "description": "Polar((0,2), y = x2 - 3x + 5) creates the line 1.5x + 0.5y = 4",
                "command": "Polar((0,2), y = x2 - 3x + 5)"
            },
            {
                "description": "Polar(1.5x+0.5y=4, y = x2 - 3x + 5) creates the point (0, 2)",
                "command": "Polar(1.5x+0.5y=4, y = x2 - 3x + 5)"
            }
        ],
        "note": "See also Polar or Diameter Line tool."
    },
    {
        "signature": "ZoomOut( <Scale Factor> )\nZoomOut( <Scale Factor>, <Center Point> )",
        "commandBase": "ZoomOut",
        "description": "Zooms the Graphics View out by given factor with respect to current zoom, center of the screen is used as center point for the zoom. Zooms the Graphics View out by given factor with respect to current zoom, second parameter specifies center point for the zoom.",
        "examples": [
            {
                "description": "ZoomOut(2) zooms the view out.",
                "command": "ZoomOut(2)"
            },
            {
                "description": "ZoomOut with scale factor and center point",
                "command": "ZoomOut(2, (0, 0))"
            }
        ],
        "note": "ZoomOut(t) and ZoomOut(t, A) are equivalent to ZoomIn(1/t) and ZoomIn(1/t, A) respectively. If multiple Graphics Views are present, the active one is used. See also ZoomIn, SetActiveView, Pan commands."
    },
    {
        "signature": "CSolutions( <Equation> ) | CSolutions( <Equation>, <Variable> ) | CSolutions( <List of Equations>, <List of Variables> )",
        "commandBase": "CSolutions",
        "description": "Solves a given equation for the main variable and returns a list of all solutions, allowing for complex solutions.",
        "examples": [
            {
                "description": "Solves x^2 = -1 for complex solutions",
                "command": "CSolutions(x^2 = -1)"
            },
            {
                "description": "Solves a^2 = -1 for variable a with complex solutions",
                "command": "CSolutions(a^2 = -1, a)"
            },
            {
                "description": "Solves a system of equations {y^2 = x - 1, x = 2 * y - 1} for variables {x, y} with complex solutions",
                "command": "CSolutions({y^2 = x - 1, x = 2 * y - 1}, {x, y})"
            }
        ],
        "note": "The complex ί is obtained by pressing ALT + i. See also CSolve Command and Solutions Command."
    },
    {
        "signature": "JordanDiagonalization [matrix] [options]",
        "commandBase": "JordanDiagonalization",
        "description": "Computes the Jordan canonical form (Jordan diagonalization) of a given matrix.",
        "examples": [],
        "note": "This command requires the input matrix to be square and may involve complex eigenvalues for some matrices."
    },
    {
        "signature": "SigmaXX( <List of Points> ), SigmaXX( <List of Raw Data> ), SigmaXX( <List of Numbers>, <List of Frequencies> )",
        "commandBase": "SigmaXX",
        "description": "Calculates the sum of squares of the x-coordinates of given points, the sum of squares of given numbers, or the weighted sum of squares of given numbers with frequencies.",
        "examples": [
            {
                "description": "Calculates the sum of squares of the x-coordinates of the given points.",
                "command": "SigmaXX(list1) where list1 = {(-3, 4), (-1, 4), (-2, 3), (1, 3), (2, 2), (1, 5)} yields 20."
            },
            {
                "description": "Calculates the sum of squares of the given numbers, useful for variance calculation.",
                "command": "SigmaXX(list) / Length(list) - Mean(list)^2."
            },
            {
                "description": "Calculates the weighted sum of squares of the given numbers using frequencies.",
                "command": "SigmaXX(list2, list3) where list2 = {1, 2, 3, 4, 5} and list3 = {4, 5, 7, 2, 1} yields 144."
            }
        ],
        "note": "The command has multiple overloads for different data types: points, raw numbers, and numbers with frequencies."
    },
    {
        "signature": "ImplicitCurve( <List of Points> ) or ImplicitCurve( <f(x,y)> )",
        "commandBase": "ImplicitCurve",
        "description": "Creates implicit curve through given set of points. The length of the list must be stem:[\\frac{n(n+3)}2] for implicit curve of degree stem:[n]. Creates the implicit curve f(x,y) = 0.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "InverseHyperGeometric( <Population Size>, <Number of Successes>, <Sample Size>, <Probability> )",
        "commandBase": "InverseHyperGeometric",
        "description": "Returns least integer n such that P(X ≤ n) ≥ p, where p is the probability and X is hypergeometric random variable given by Population Size, Number of Successes and Sample Size.",
        "examples": [],
        "note": "See also HyperGeometric Command."
    },
    {
        "signature": "RotateText( <Text>, <Angle> )",
        "commandBase": "RotateText",
        "description": "Creates a new LaTeX text, rotated by the given angle.",
        "examples": [
            {
                "description": "RotateText(\"a = 5\", 45°)",
                "command": "RotateText(\"a = 5\", 45°)"
            },
            {
                "description": "If you want to place the text \"GeoGebra\", rotated by 42°, at point (6,6), use the command Text(RotateText(\"GeoGebra\", 42°), (6, 6),true,true)",
                "command": "Text(RotateText(\"GeoGebra\", 42°), (6, 6),true,true)"
            }
        ],
        "note": "The text needs to be enclosed in double quotes \". The text is rotated around the top left corner (also known as Corner 4) of the box containing it, and placed at the origin of the coordinate system. The default setting for the angle is radians. Use the degree symbol ° for rotation angles measured in degrees."
    },
    {
        "signature": "SolveQuartic( <Quartic Polynomial> )",
        "commandBase": "SolveQuartic",
        "description": "Solves a given quartic polynomial and returns a list of all solutions.",
        "examples": [
            {
                "description": "Solve a quartic polynomial",
                "command": "SolveQuartic( x4 + x3 + x2 + x )"
            }
        ],
        "note": "This feature is supported only in GeoGebra beta (https://beta.geogebra.org/cas). CAS Syntax"
    },
    {
        "signature": "DataFunction( <List of Numbers>, <List of Numbers> )",
        "commandBase": "DataFunction",
        "description": "Yields a function that connects points (x1, y1), (x2, y2),...,(xn, yn) where {x1, ..., xn}, {y1, ..., yn} are the input lists. In between these points linear interpolation is used. This command is used by Sensors.",
        "examples": [
            {
                "description": "DataFunction({0, 1, 2, 4}, {0, 1, 4, 16}) yields a function that goes through points (0, 0), (1,1), (2, 4), (4, 16).",
                "command": "DataFunction({0, 1, 2, 4}, {0, 1, 4, 16})"
            }
        ],
        "note": ""
    },
    {
        "signature": "Normal( <Mean>, <Standard Deviation>, <Variable Value> ), Normal( <Mean>, <Standard Deviation>, <Variable Value>, <Boolean Cumulative> ), Normal( <Mean>, <Standard Deviation>, <Variable Value u>, <Variable Value v> ), Normal( <Mean>, <Standard Deviation>, x, <Boolean Cumulative> )",
        "commandBase": "Normal",
        "description": "Evaluates the cumulative distribution function (CDF) or probability density function (PDF) of a normal distribution, or computes probabilities over intervals, based on given mean, standard deviation, and variable values.",
        "examples": [
            {
                "description": "Evaluates the CDF at a given variable value, returning the probability to the left of that value.",
                "command": "Normal(2, 0.5, 1)"
            },
            {
                "description": "Evaluates the CDF if Cumulative = true, or the PDF if Cumulative = false, at a given variable value.",
                "command": "Normal( <Mean>, <Standard Deviation>, <Variable Value>, <Boolean Cumulative> )"
            },
            {
                "description": "Computes the probability of a normal random variable in the interval [u, v].",
                "command": "Normal( <Mean>, <Standard Deviation>, <Variable Value u>, <Variable Value v> )"
            },
            {
                "description": "Creates the CDF if Cumulative = true, or the PDF if Cumulative = false, as a function of x.",
                "command": "Normal( <Mean>, <Standard Deviation>, x, <Boolean Cumulative> )"
            }
        ],
        "note": "This syntax returns the probability at a given value, that is the area under the normal distribution curve to the left of the given x-coordinate. For interval probabilities, it is equivalent to the difference between two CDF evaluations."
    },
    {
        "signature": "JordanDiagonalization Command",
        "commandBase": "JordanDiagonalization",
        "description": "No description provided.",
        "examples": [],
        "note": "No note provided."
    },
    {
        "signature": "RandomElement(<List>)",
        "commandBase": "RandomElement",
        "description": "Returns randomly chosen element from the list (with uniform probability). All elements in the list must be of the same type.",
        "examples": [
            {
                "description": "Randomly select from a numeric list",
                "command": "RandomElement({3, 2, -4, 7})"
            },
            {
                "description": "Randomly select from a symbolic list",
                "command": "RandomElement({a,b,c,d})"
            }
        ],
        "note": "In the CAS View this command also works with symbolic input. See also Element Command, SetSeed Command, RandomBetween Command, RandomBinomial Command, RandomNormal Command, RandomPoisson Command and RandomUniform Command."
    },
    {
        "signature": "SVD( <Matrix> )",
        "commandBase": "SVD",
        "description": "Returns the Singular Value Decomposition (https://en.wikipedia.org/wiki/Singular_value_decomposition) of the matrix (as a list of 3 matrices).",
        "examples": [
            {
                "description": "SVD of a matrix yields a list containing three matrices.",
                "command": "SVD({{3, 1, 1}, {-1, 3, 1}})"
            }
        ],
        "note": "This command is also supported in the CAS View. The numbers in the answer may vary in order between the Algebra View and CAS View. See also Eigenvalues Command, Eigenvectors Command, Invert Command, Transpose Command."
    },
    {
        "signature": "Flatten( <List> )",
        "commandBase": "Flatten",
        "description": "Flattens lists to one list.",
        "examples": [
            {
                "description": "Flatten({2, 3, {5, 1}, {{2, 1, {3}}}}) yields list1 = {2, 3, 5, 1, 2, 1, 3}.",
                "command": "Flatten({2, 3, {5, 1}, {{2, 1, {3}}}})"
            }
        ],
        "note": ""
    },
    {
        "signature": "Prism( <Point>, <Point>, ... ) | Prism( <Polygon>, <Point> ) | Prism( <Polygon>, <Height value> )",
        "commandBase": "Prism",
        "description": "Returns a prism defined by the given points or parameters.",
        "examples": [
            {
                "description": "Creates the prism with base ABC and top DEF. The vectors AD, BE, CF are equal.",
                "command": "Prism(A, B, C, D)"
            },
            {
                "description": "Creates a prism with the given polygon as base and the point as first top point.",
                "command": "Prism(poly1, A)"
            },
            {
                "description": "Creates a right prism with the polygon as base and given height.",
                "command": "Prism(poly1, 3)"
            }
        ],
        "note": "See also Prism and Extrude to Prism tools."
    },
    {
        "signature": "ZMeanEstimate( <List of Sample Data>, <σ>, <Confidence Level> ) or ZMeanEstimate( <Sample Mean>, <σ>, <Sample Size>, <Confidence Level> )",
        "commandBase": "ZMeanEstimate",
        "description": "Calculates a Z confidence interval estimate of a population mean using either sample data or sample statistics, along with the population standard deviation and confidence level. Results are returned in list form as {lower confidence limit, upper confidence limit}.",
        "examples": [
            {
                "description": "Calculates a Z confidence interval estimate using a list of sample data, population standard deviation, and confidence level.",
                "command": "ZMeanEstimate( <List of Sample Data>, <σ>, <Confidence Level> )"
            },
            {
                "description": "Calculates a Z confidence interval estimate using sample mean, population standard deviation, sample size, and confidence level.",
                "command": "ZMeanEstimate( <Sample Mean>, <σ>, <Sample Size>, <Confidence Level> )"
            }
        ],
        "note": "This command supports two overloads: one for raw sample data and another for precomputed sample statistics. Ensure that the confidence level is expressed appropriately (e.g., as a decimal or percentage) based on the system's requirements."
    },
    {
        "signature": "InverseZipf( <Number of Elements>, <Exponent>, <Probability> )",
        "commandBase": "InverseZipf",
        "description": "Returns the least integer n such that P(X≤n) ≥ p, where X is a Zipf random variable defined by the given number of elements and exponent, and p is the probability.",
        "examples": [],
        "note": "See also Zipf Command."
    },
    {
        "signature": "ZProportion2Test( <Sample Proportion 1>, <Sample Size 1>, <Sample Proportion 2>, <Sample Size 2>, <Tail> )",
        "commandBase": "ZProportion2Test",
        "description": "Performs a test of the difference between two population proportions using the given sample statistics. Tail has possible values \"<\", \">\", \"≠\". These specify the alternative hypothesis as follows: \"<\" = difference in population proportions < 0, \">\" = difference in population proportions > 0, \"≠\" = difference in population proportions ≠ 0. Results are returned in list form as {Probability value, Z test statistic}.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "SampleSDX( <List of Points> )",
        "commandBase": "SampleSDX",
        "description": "Returns the sample standard deviation (https://en.wikipedia.org/wiki/Standard_deviationEstimation) of the _x_-coordinates of the points in the given list.",
        "examples": [
            {
                "description": "SampleSDX({(2, 3), (1, 5), (3, 6), (4, 2), (1, 1), (2, 5)}) yields a = 1.17.",
                "command": "SampleSDX({(2, 3), (1, 5), (3, 6), (4, 2), (1, 1), (2, 5)})"
            }
        ],
        "note": ""
    },
    {
        "signature": "Transpose( <Matrix> )",
        "commandBase": "Transpose",
        "description": "Transposes the matrix.",
        "examples": [
            {
                "description": "Transpose a 3x3 matrix",
                "command": "Transpose({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}})"
            },
            {
                "description": "Transpose a 2x2 matrix (CAS syntax)",
                "command": "Transpose({{a, b}, {c, d}})"
            }
        ],
        "note": "See also Eigenvalues Command, Eigenvectors Command, SVD Command, Invert Command."
    },
    {
        "signature": "Point( <Object> ), Point( <Object>, <Parameter> ), Point( <Point>, <Vector> ), Point( <List> )",
        "commandBase": "Point",
        "description": "Returns a point on the geometric object. The resulting point can be moved along the path. Returns a point on the geometric object with given path parameter. Creates a new point by adding the vector to the given point. Converts a list containing two numbers into a Point.",
        "examples": [
            {
                "description": "Converts a list containing two numbers into a Point",
                "command": "Point({1, 2})"
            }
        ],
        "note": "• See also [Image: Mode point.svg,width=24,height=24] Point tool. • See also Points and vectors"
    },
    {
        "signature": "MinimalPolynomial( <Matrix> )",
        "commandBase": "MinimalPolynomial",
        "description": "Returns the minimal polynomial (https://en.wikipedia.org/wiki/Minimal_polynomial_(linear_algebra)) of the given matrix.",
        "examples": [
            {
                "description": "CAS Syntax",
                "command": "MinimalPolynomial({{1,0},{0,1}}) yields stem:[x-1]."
            }
        ],
        "note": ""
    },
    {
        "signature": "TurtleForward( <Turtle>, <Distance> )",
        "commandBase": "TurtleForward",
        "description": "The turtle moves forward with given distance.",
        "examples": [
            {
                "description": "If the turtle is at the origin of the coordinates and the Pause button is displayed, the command TurtleForward(turtle, 2) moves the turtle to the point (2, 0). Otherwise you must press the Play button so that the displacement is effected.",
                "command": "TurtleForward(turtle, 2)"
            }
        ],
        "note": "See also Turtle, TurtleBack, TurtleLeft and TurtleRight commands."
    },
    {
        "signature": "LetterToUnicode(\"<Letter>\")",
        "commandBase": "LetterToUnicode",
        "description": "Converts a single letter into the corresponding Unicode number (https://en.wikipedia.org/wiki/Unicode).",
        "examples": [
            {
                "description": "Converts a single letter into the corresponding Unicode number",
                "command": "LetterToUnicode(\"a\") returns the number 97."
            }
        ],
        "note": "The letter needs to be enclosed in double quotes in order to be recognized as text. See also UnicodeToLetter Command and TextToUnicode Command."
    },
    {
        "signature": "Erlang( <Shape>, <Rate>, <Variable Value> ) or Erlang( <Shape>, <Rate>, <Variable Value>, <Boolean Cumulative> )",
        "commandBase": "Erlang",
        "description": "Calculates the value of cumulative distribution function of an Erlang distribution at variable value v, i.e. the probability P(X ≤ v) where X is a random variable with an Erlang distribution defined by the parameters shape and rate.",
        "examples": [
            {
                "description": "Returns the probability at a given value, that is the area under the Erlang distribution curve to the left of the given x-coordinate.",
                "command": "Erlang( <Shape>, <Rate>, <Variable Value> )"
            },
            {
                "description": "If Cumulative = true, calculates the value of the cumulative distribution function of an Erlang distribution with given shape and rate at the given variable value, otherwise it calculates the probability density function of the distribution at variable value.",
                "command": "Erlang( <Shape>, <Rate>, <Variable Value>, <Boolean Cumulative> )"
            },
            {
                "description": "If Cumulative = true, creates the cumulative density function (cdf) of an Erlang distribution with given shape and rate, otherwise it creates the probability density function (pdf) of the distribution.",
                "command": "Erlang( <Shape>, <Rate>, x, <Boolean Cumulative> )"
            }
        ],
        "note": "This syntax returns the probability at a given value, that is the area under the Erlang distribution curve to the left of the given x-coordinate."
    },
    {
        "signature": "Also see OrdinalRank Command",
        "commandBase": "Also see OrdinalRank Command",
        "description": "No description provided.",
        "examples": [],
        "note": "No note provided."
    },
    {
        "signature": "Uniform( <Lower Bound>, <Upper Bound>, <Variable Value> ) | Uniform( <Lower Bound>, <Upper Bound>, <Variable Value>, <Boolean Cumulative> ) | Uniform( <Lower Bound>, <Upper Bound>, x, <Boolean Cumulative> )",
        "commandBase": "Uniform",
        "description": "Evaluates or creates the cumulative distribution function (CDF) or probability density function (PDF) of a uniform distribution.",
        "examples": [
            {
                "description": "Evaluates the cumulative distribution function of a uniform distribution at variable value v",
                "command": "Uniform( <Lower Bound>, <Upper Bound>, <Variable Value> )"
            },
            {
                "description": "Evaluates the CDF if Cumulative = true, otherwise evaluates the PDF at variable value",
                "command": "Uniform( <Lower Bound>, <Upper Bound>, <Variable Value>, <Boolean Cumulative> )"
            },
            {
                "description": "Creates the CDF if Cumulative is true, otherwise creates the PDF of a uniform distribution",
                "command": "Uniform( <Lower Bound>, <Upper Bound>, x, <Boolean Cumulative> )"
            }
        ],
        "note": "The uniform distribution is defined in the interval [_lower bound_, _upper bound_]. For CDF, it calculates P(X ≤ v) where X is a random variable with uniform distribution."
    },
    {
        "signature": "Line( <Point>, <Point> ) | Line( <Point>, <Parallel Line> ) | Line( <Point>, <Direction Vector> )",
        "commandBase": "Line",
        "description": "Creates a line through two points A and B, through a given point parallel to a given line, or through a given point with a direction vector v.",
        "examples": [
            {
                "description": "See also Line and Parallel Line tools.",
                "command": "Line( <Point>, <Point> )"
            },
            {
                "description": "You can also use a parametric syntax to create a line.",
                "command": "X = (1, 2) + r (2, 3) or X = (1, 2, 3) + r (2, 3, 4)"
            }
        ],
        "note": "Line( <Point>, <Point> ): Creates a line through two points A and B. Line( <Point>, <Parallel Line> ): Creates a line through the given point parallel to the given line. Line( <Point>, <Direction Vector> ): Creates a line through the given point with direction vector v."
    },
    {
        "signature": "Dimension( <Object> )",
        "commandBase": "Dimension",
        "description": "Gives the dimension of a vector or a matrix.",
        "examples": [
            {
                "description": "Dimension of a vector",
                "command": "Dimension({1, 2, 0, -4, 3}) yields 5."
            },
            {
                "description": "Dimension of a matrix",
                "command": "Dimension({{1, 2}, {3, 4}, {5, 6}}) yields {3, 2}."
            },
            {
                "description": "Dimension of a matrix with symbolic entries",
                "command": "Dimension({{a, b}, {c, d}, {e, f}}) yields {3, 2}."
            }
        ],
        "note": "The command is available in both standard and CAS syntax, with the same functionality."
    },
    {
        "signature": "Quartile3( <List of Raw Data> ) or Quartile3( <List of Numbers>, <List of Frequencies> )",
        "commandBase": "Quartile3",
        "description": "Determines the upper quartile of the list elements. Optionally, it can consider frequencies for the calculation.",
        "examples": [
            {
                "description": "Calculate upper quartile for a simple list",
                "command": "Quartile3({1, 2, 3, 4})"
            },
            {
                "description": "Calculate upper quartile with frequencies",
                "command": "Quartile3({1, 2, 3, 4}, {3, 2, 4, 2})"
            }
        ],
        "note": "GeoGebra uses the Moore & McCabe (2002) method to calculate quartiles, see https://mathworld.wolfram.com/Quartile.html"
    },
    {
        "signature": "SetDynamicColor( <Object>, <Red>, <Green>, <Blue> ) or SetDynamicColor( <Object>, <Red>, <Green>, <Blue>, <Opacity> )",
        "commandBase": "SetDynamicColor",
        "description": "Sets the dynamic color of the object, with an optional opacity parameter.",
        "examples": [
            {
                "description": "This command differs among variants of English: SetDynamicColor (US), SetDynamicColour (UK + Aus)",
                "command": "SetDynamicColor( <Object>, <Red>, <Green>, <Blue> )"
            },
            {
                "description": "All numbers are on a scale from 0 (off/transparent) to 1 (on/opaque).",
                "command": "SetDynamicColor( <Object>, <Red>, <Green>, <Blue>, <Opacity> )"
            }
        ],
        "note": "Ensure to use the correct spelling based on your English variant (US: SetDynamicColor, UK/Aus: SetDynamicColour)."
    },
    {
        "signature": "FitPoly( <List of Points>, <Degree of Polynomial> )",
        "commandBase": "FitPoly",
        "description": "Calculates the polynomial regression model of given degree that fits the specified points.",
        "examples": [
            {
                "description": "Fit polynomial of degree 3 to points {(-1, -1), (0, 1), (1, 1), (2, 5)}",
                "command": "FitPoly({(-1, -1), (0, 1), (1, 1), (2, 5)}, 3)"
            }
        ],
        "note": "To obtain a polynomial of degree n the list must contain at least n + 1 points. See also FitExp Command, FitLog Command, FitPow Command and FitSin Command. When working with big/small numbers, consider normalizing them for a more accurate result. See Normalize Command."
    },
    {
        "signature": "CountIf( <Condition>, <List> )",
        "commandBase": "CountIf",
        "description": "Counts the number of elements in the list satisfying the condition.",
        "examples": [
            {
                "description": "Count numbers less than 3 in a list",
                "command": "CountIf(x < 3, {1, 2, 3, 4, 5})"
            },
            {
                "description": "Count cells with values less than 3 in a spreadsheet range",
                "command": "CountIf(x < 3, A1:A10)"
            },
            {
                "description": "Count points with x-coordinate less than 3 using variable syntax",
                "command": "CountIf(x(A) < 3, A, {(0, 1), (4, 2), (2, 2)})"
            }
        ],
        "note": "For list of numbers arbitrary condition may be used. For list of other objects one can use only conditions of the form x==constant or x!=constant."
    },
    {
        "signature": "Div( <Dividend Number>, <Divisor Number> ) / Div( <Dividend Polynomial>, <Divisor Polynomial> )",
        "commandBase": "Div",
        "description": "Returns the quotient (integer part of the result) of two numbers or the quotient of two polynomials.",
        "examples": [
            {
                "description": "Div(16, 3) yields 5.",
                "command": "Div(16, 3)"
            },
            {
                "description": "Div(x2 + 3 x + 1, x - 1) yields f(x) = x + 4.",
                "command": "Div(x2 + 3 x + 1, x - 1)"
            }
        ],
        "note": "The function handles both numeric division (returning integer quotient) and polynomial division."
    },
    {
        "signature": "SurdText(<Point>), SurdText(<Number>), SurdText(<Number>, <List>)",
        "commandBase": "SurdText",
        "description": "Creates a text representation of a point or number in the form stem:[\\frac{a+b\\sqrt{c}}{d}] or using specified constants.",
        "examples": [
            {
                "description": "Creates a text representation of the point, with coordinates in the form stem:[\\frac{a+b\\sqrt{c}}{d}].",
                "command": "SurdText((2.414213562373095, 1.414213562373095))"
            },
            {
                "description": "Creates a text representation of the number in the form stem:[\\frac{a+b\\sqrt{c}}{d}].",
                "command": "SurdText(2.414213562373095)"
            },
            {
                "description": "Creates a text representation of the number, rewritten as a multiple of the constants in the list. If the list is empty, the command uses a list of common constants.",
                "command": "SurdText(5.382332347441762, {sqrt(2), sqrt(3), sqrt(5)})"
            }
        ],
        "note": "In order to use this command in a Text object, the option LaTeX Formula needs to be enabled in the Text tab of the Properties Dialog of the text. Since this command works with a rounded decimal number as input, in some cases the result might be unexpected. If a suitable answer can't be found, the number will be returned. For example, the command SurdText(1.23456789012345) returns 1.23456789012345. See also the FractionText and ScientificText commands."
    },
    {
        "signature": "Reverse( <List> )",
        "commandBase": "Reverse",
        "description": "Reverses the order of a list.",
        "examples": [
            {
                "description": "Reverse(list1) reverses list1 = {(1, 2), (3, 4), (5, 6)} to create list2 = {(5, 6), (3, 4), (1, 2)}",
                "command": "Reverse({(1, 2), (3, 4), (5, 6)})"
            },
            {
                "description": "Reverse({1, 2, 3, 4}) reverses the list to create {4, 3, 2, 1}",
                "command": "Reverse({1, 2, 3, 4})"
            }
        ],
        "note": "CAS Syntax: Reverse( <List> ): Reverses the order of a list."
    },
    {
        "signature": "FitLogistic( <List of Points> )",
        "commandBase": "FitLogistic",
        "description": "Calculates the regression curve in the form stem:[\\frac{a}{1+b e{-kx}}].",
        "examples": [
            {
                "description": "Fit logistic regression to given points",
                "command": "FitLogistic({(-6, 2), (0, 2), (3, 4), (3.4, 8)})"
            }
        ],
        "note": "The first and last data points should be fairly close to the curve. The list should have at least 3 points, preferably more. All points should have positive y-coordinates. See also Fit, FitExp, FitGrowth, FitLine, FitLineX, FitLog, FitPoly, FitPow and FitSin. If you work with big/small numbers, you should consider normalizing them for a more accurate result, see Normalize Command."
    },
    {
        "signature": "UnicodeToLetter( <Integer> )",
        "commandBase": "UnicodeToLetter",
        "description": "Converts the integer Unicode number back into a letter which is displayed as a text object in the Graphics View.",
        "examples": [
            {
                "description": "UnicodeToLetter(97) yields the text \"a\".",
                "command": "UnicodeToLetter(97)"
            }
        ],
        "note": "See also LetterToUnicode Command and UnicodeToText Command."
    },
    {
        "signature": "Ellipse( <Focus>, <Focus>, <Semimajor Axis Length> ) | Ellipse( <Focus>, <Focus>, <Segment> ) | Ellipse( <Focus>, <Focus>, <Point> )",
        "commandBase": "Ellipse",
        "description": "Creates an ellipse with two focal points and semimajor axis length, or with two focal points where the length of the semimajor axis equals the length of a given segment, or with two focal points passing through a given point.",
        "examples": [
            {
                "description": "Creates an ellipse with two focal points and semimajor axis length",
                "command": "Ellipse((0, 1), (1, 1), 1)"
            },
            {
                "description": "Creates an ellipse with two focal points, where the length of the semimajor axis equals the length of the given segment",
                "command": "Ellipse((0, 1), (2, 1), s) where s = Segment((0,1), (2,1))"
            },
            {
                "description": "Creates an ellipse with two focal points passing through a given point",
                "command": "Ellipse((0, 1), (2, 1), (1,2))"
            }
        ],
        "note": "If the condition: 2*semimajor axis length > Distance between the focus points isn't met, you will get a hyperbola. See also Ellipse tool."
    },
    {
        "signature": "CenterView( <Center Point> )",
        "commandBase": "CenterView",
        "description": "Translates the Graphics View so that the specified point is in the center.",
        "examples": [
            {
                "description": "CenterView((0, 0)) moves the origin to the center of the Graphics View.",
                "command": "CenterView((0, 0))"
            }
        ],
        "note": "This command differs among variants of English: • CenterView (US) • CentreView (UK + Aus). If multiple Graphics Views are open, the command applies to the active View."
    },
    {
        "signature": "ColumnName( <Spreadsheet Cell> )",
        "commandBase": "ColumnName",
        "description": "Returns the column name of the cell as a text.",
        "examples": [
            {
                "description": "r = ColumnName(A1) creates r = A and shows such text - A - in the Graphics View.",
                "command": "ColumnName(A1)"
            }
        ],
        "note": ""
    },
    {
        "signature": "TrapezoidalSum( <Function>, <Start x-Value>, <End x-Value>, <Number of Trapezoids> )",
        "commandBase": "TrapezoidalSum",
        "description": "Calculates the trapezoidal sum of the function in the interval [Start x-Value, End x-Value] using n trapezoids.",
        "examples": [
            {
                "description": "Calculate trapezoidal sum for x^2 from -2 to 3 with 5 trapezoids",
                "command": "TrapezoidalSum(x2, -2, 3, 5)"
            }
        ],
        "note": "This command differs among variants of English: TrapezoidalSum (US), TrapeziumSum (UK + Aus). This command draws the trapezoids of the trapezoidal sum as well. It is designed as a visual aid so won't give accurate answers if the number of rectangles is too large. See also the commands: LowerSum, LeftSum, RectangleSum and UpperSum."
    },
    {
        "signature": "RootMeanSquare( <List of Numbers> )",
        "commandBase": "RootMeanSquare",
        "description": "Returns the root mean square (https://en.wikipedia.org/wiki/Root_mean_square) of given list of numbers.",
        "examples": [
            {
                "description": "RootMeanSquare({3, 4, 5, 3, 2, 3, 4}) yields 3.5456.",
                "command": "RootMeanSquare({3, 4, 5, 3, 2, 3, 4})"
            }
        ],
        "note": ""
    },
    {
        "signature": "FitSin(<List of Points>)",
        "commandBase": "FitSin",
        "description": "Calculates the regression curve in the form a + b sin (c x + d).",
        "examples": [
            {
                "description": "Fit a sine curve to a set of points",
                "command": "FitSin({(1, 1), (2, 2), (3, 1), (4, 0), (5, 1), (6, 2)})"
            }
        ],
        "note": "The list should have at least four points, preferably more. The list should cover at least two extremal points. The first two local extremal points should not be too different from the absolute extremal points of the curve. See also FitExp Command, FitLog Command, FitPoly Command and FitPow Command. If you work with big/small numbers, you should consider normalizing them for a more accurate result, see Normalize Command."
    },
    {
        "signature": "Split( <Text>, <List of Texts to split on>)",
        "commandBase": "Split",
        "description": "Creates the list of texts obtained by splitting the given text at the given separators (not included in the list).",
        "examples": [
            {
                "description": "Split a text at specified separators",
                "command": "Split(\"3cos(t)cos(2y)\", {\"cos\"}) returns {\"3\", \"(t)\", \"(2y)\"}."
            }
        ],
        "note": ""
    },
    {
        "signature": "PathParameter( <Point On Path> )",
        "commandBase": "PathParameter",
        "description": "Returns the parameter (i.e. a number ranging from 0 to 1) of the point that belongs to a path.",
        "examples": [
            {
                "description": "Let f(x) = x² + x - 1 and A is a point attached to this function with coordinates (1,1) (you can create such point using the point on object tool or A=Point(f), SetCoords(A,1,1) commands). Then PathParameter(A) yields a 0.47.",
                "command": "PathParameter(A)"
            },
            {
                "description": "Table showing path parameter formulas for different geometric objects",
                "command": "See table in documentation for specific formulas"
            }
        ],
        "note": "The command calculates normalized path parameters (0 to 1) for points on various geometric paths including lines, circles, ellipses, hyperbolas, parabolas, polylines, polygons, lists of paths/points, loci, and implicit polynomials (no formula available for implicit polynomials)."
    },
    {
        "signature": "Sxy( <List of Points> )",
        "commandBase": "Sxy",
        "description": "Calculates the statistic stem:[\\sum xy - \\frac{(\\sum x) (\\sum y)}{n}] using the coordinates of the given points.",
        "examples": [
            {
                "description": "Calculates the statistic stem:[\\sum xy - \\frac{(\\sum x) (\\sum y)}{n}], where x are the values in the first list, and y are the values in the second given list.",
                "command": "Sxy( <List of Numbers>, <List of Numbers> )"
            }
        ],
        "note": "This command has two signatures: one for a list of points and another for two separate lists of numbers representing x and y values."
    },
    {
        "signature": "SetSpinSpeed( <Number> )",
        "commandBase": "SetSpinSpeed",
        "description": "Sets the rotational speed of the 3D view about the axis currently displayed in vertical position. The sign and value of the entered Number define the rotation as follows: if Number is greater than 1, then the 3D view rotates counter clockwise; if Number is less than -1, then the 3D view rotates clockwise; if Number is between -1 and 1 then the rotation will be cancelled.",
        "examples": [],
        "note": ""
    },
    {
        "signature": "TiedRank( <List> )",
        "commandBase": "TiedRank",
        "description": "Returns a list, whose _i_-th element is the rank of _i_-th element of the given list L (rank of element is its position in Sort(L)). If there are more equal elements in L which occupy positions from k to l in Sort[L], the mean of the ranks from k to l are associated with these elements.",
        "examples": [
            {
                "description": "Example with list {4, 1, 2, 3, 4, 2}",
                "command": "TiedRank({4, 1, 2, 3, 4, 2}) returns {5.5, 1, 2.5, 4, 5.5, 2.5}."
            },
            {
                "description": "Example with list {3, 2, 2, 1}",
                "command": "TiedRank({3, 2, 2, 1}) returns {4, 2.5, 2.5, 1}."
            }
        ],
        "note": ""
    },
    {
        "signature": "Radius( <Conic> )",
        "commandBase": "Radius",
        "description": "Returns the radius of a conic.",
        "examples": [
            {
                "description": "Returns the radius of a circle c (e.g. c:(x - 1)² + (y - 1)² = 9)",
                "command": "Radius(c)"
            },
            {
                "description": "Returns the radius of a circle formula",
                "command": "Radius((x - 2)² + (y - 2)² = 16)"
            }
        ],
        "note": "Radius(c) yields a = 3, Radius((x - 2)² + (y - 2)² = 16) yields a = 4."
    },
    {
        "signature": "BoxPlot( yOffset, yScale, List of Raw Data )\nBoxPlot( yOffset, yScale, Start Value, Q1, Median, Q3, End Value )\nBoxPlot( <yOffset>, <yScale>, <List of Raw Data>, <Boolean Outliers> )\nBoxPlot( <yOffset>, <yScale>, <List of Data>, <List of Frequencies>, <Boolean Outliers> )",
        "commandBase": "BoxPlot",
        "description": "Creates a box plot using the given raw data and whose vertical position in the coordinate system is controlled by variable yOffset and whose height is influenced by factor yScale.",
        "examples": [
            {
                "description": "Create a box plot from raw data",
                "command": "BoxPlot(0, 1, {2, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 8, 9})"
            }
        ],
        "note": "This command has multiple signatures: (1) With raw data list; (2) With statistical data (Start Value, Q1, Median, Q3, End Value); (3) With raw data and outlier boolean; (4) With data and frequency lists and outlier boolean. Outliers are data below Q1 - 1.5 * IQR or above Q3 + 1.5 * IQR."
    },
    {
        "signature": "PerpendicularBisector( <Segment> ), PerpendicularBisector( <Point>, <Point> ), PerpendicularBisector( <Point>, <Point>, <Direction> )",
        "commandBase": "PerpendicularBisector",
        "description": "Yields the perpendicular bisector of a segment or line segment between points, with optional direction specification.",
        "examples": [
            {
                "description": "Yields the perpendicular bisector of a segment.",
                "command": "PerpendicularBisector( <Segment> )"
            },
            {
                "description": "Yields the perpendicular bisector of a line segment between two points.",
                "command": "PerpendicularBisector( <Point>, <Point> )"
            },
            {
                "description": "Yields the perpendicular bisector of a line segment between two points which is perpendicular to the direction.",
                "command": "PerpendicularBisector( <Point>, <Point>, <Direction> )"
            }
        ],
        "note": "See also [Image: Mode linebisector.svg,width=22,height=22] Perpendicular Bisector tool. <Direction> can either be a vector, an axis, a line or a segment."
    },
    {
        "signature": "IsVertexForm(<function>)",
        "commandBase": "IsVertexForm",
        "description": "Checks if a function is written in vertex form.",
        "examples": [
            {
                "description": "IsVertexForm((x+2/3)2-(2/3)2) yields true",
                "command": "IsVertexForm((x+2/3)2-(2/3)2)"
            },
            {
                "description": "IsVertexForm(2*(3 x-2)(2)+1) yields false",
                "command": "IsVertexForm(2*(3 x-2)(2)+1)"
            }
        ],
        "note": ""
    },
    {
        "signature": "PerpendicularLine( <Point>, <Line> ), PerpendicularLine( <Point>, <Segment> ), PerpendicularLine( <Point>, <Vector> ), PerpendicularLine( <Point>, <Plane> ), PerpendicularLine( <Line>, <Line> ), PerpendicularLine( <Point>, <Direction>, <Direction> ), PerpendicularLine( <Point>, <Line>, <Context> )",
        "commandBase": "PerpendicularLine",
        "description": "Creates a line through a point perpendicular to a given geometric object (line, segment, vector, plane) or creates perpendicular lines between lines or based on directions and context.",
        "examples": [
            {
                "description": "Creates a line through the point perpendicular to the given line.",
                "command": "PerpendicularLine(A, c)"
            },
            {
                "description": "Creates a line through the point perpendicular to the given segment.",
                "command": "PerpendicularLine(A, c)"
            },
            {
                "description": "Creates a line through the point perpendicular to the given vector.",
                "command": "PerpendicularLine(A, u)"
            },
            {
                "description": "Creates a perpendicular line to the plane through the given point.",
                "command": "PerpendicularLine( <Point>, <Plane> )"
            },
            {
                "description": "Creates a perpendicular line to the given lines through the intersection point of the two lines.",
                "command": "PerpendicularLine( <Line>, <Line> )"
            },
            {
                "description": "Creates a perpendicular line to the given directions (that can be lines or vectors) through the given point.",
                "command": "PerpendicularLine( <Point>, <Direction>, <Direction> )"
            },
            {
                "description": "Creates a perpendicular line to the line through the point and depending on the context.",
                "command": "PerpendicularLine( <Point>, <Line>, <Context> )"
            }
        ],
        "note": "For 3D objects, a third argument is added to specify behavior based on view context (2D uses plane z=0, 3D uses space). See PerpendicularLine( <Point>, <Line>, <Context> ) for details on variations like PerpendicularLine( <Point>, <Line>, <Plane> ) and PerpendicularLine( <Point>, <Line>, space ). Also, see the Perpendicular Line tool."
    },
    {
        "signature": "ShowLabel( <Object>, <Boolean> )",
        "commandBase": "ShowLabel",
        "description": "Shows or hides the label in the Graphics View for the given object.",
        "examples": [
            {
                "description": "Let f(x) = x2. ShowLabel(f, true) shows the label of the function.",
                "command": "ShowLabel(f, true)"
            }
        ],
        "note": "The label visibility is controlled by the Boolean parameter (true to show, false to hide)."
    },
    {
        "signature": "Sum( <List> ) | Sum( <List>, <Number of Elements> ) | Sum( <List>, <List of Frequencies> ) | Sum( <Expression>, <Variable>, <Start Value>, <End Value> )",
        "commandBase": "Sum",
        "description": "Calculates the sum of elements in a list or computes a summation expression.",
        "examples": [
            {
                "description": "Sum of numbers in a list",
                "command": "Sum({1, 2, 3})"
            },
            {
                "description": "Sum of functions",
                "command": "Sum({x^2, x^3})"
            },
            {
                "description": "Sum of a sequence",
                "command": "Sum(Sequence(i, i, 1, 100))"
            },
            {
                "description": "Sum of points",
                "command": "Sum({(1, 2), (2, 3)})"
            },
            {
                "description": "Sum of text elements",
                "command": "Sum({\"a\", \"b\", \"c\"})"
            },
            {
                "description": "Sum of first n elements",
                "command": "Sum({1, 2, 3, 4, 5, 6}, 4)"
            },
            {
                "description": "Sum with frequencies",
                "command": "Sum({1, 2, 3, 4, 5}, {3, 2, 4, 4, 1})"
            },
            {
                "description": "CAS summation with variable",
                "command": "Sum(n^2, n, 1, 3)"
            },
            {
                "description": "CAS summation with formula result",
                "command": "Sum(r^k, k, 0, n)"
            },
            {
                "description": "CAS summation to infinity",
                "command": "Sum((1/3)^n, n, 0, Infinity)"
            }
        ],
        "note": "This command works for numbers, points, vectors, text, and functions. Lists must contain objects of the same type. The CAS syntax (Sum( <Expression>, <Variable>, <Start Value>, <End Value> )) works only in the CAS View."
    },
    {
        "signature": "Zip( <Expression>, <Var1>, <List1>, <Var2>, <List2>, ...)",
        "commandBase": "Zip",
        "description": "Creates list of objects obtained by substitution of variables in the expression by elements of corresponding lists. If the number of variables matches the number of lists, each variable is taken from the following list. If the number of variables exceeds number of lists by one, the last variable takes values from 1, 2, 3, ..., k where k is the length of the shortest list. Length of the resulting list is minimum of lengths of input lists.",
        "examples": [
            {
                "description": "Let P, Q, R, S be some points. Zip(Midpoint(A, B), A, {P, Q}, B, {R, S}) returns a list containing midpoints of segments PR and QS.",
                "command": "Zip(Midpoint(A, B), A, {P, Q}, B, {R, S})"
            },
            {
                "description": "Let list1={x2, x3, x6} be a list of polynomials. Zip(Degree(a), a, list1) returns the list {2, 3, 6}.",
                "command": "Zip(Degree(a), a, list1)"
            },
            {
                "description": "Let list1={1, 2, 5} be a list of numbers. Zip(Simplify(a*x(b-1)), a, list1,b) returns the list {1, 2x, 5x²}.",
                "command": "Zip(Simplify(a*x(b-1)), a, list1,b)"
            },
            {
                "description": "Variables can also be functions: Zip(f(2), f, {x+1,x+3}) returns the list {3, 5}.",
                "command": "Zip(f(2), f, {x+1,x+3})"
            }
        ],
        "note": "In each list the elements must be of the same type."
    },
    {
        "signature": "TTestPaired( <List of Sample Data 1>, <List of Sample Data 2>, <Tail> )",
        "commandBase": "TTestPaired",
        "description": "Performs a paired t-test using the given lists of paired sample data. Tail has possible values \"<\", \">\", \"≠\" that determine the following alternative hypotheses: \"<\" = μ < 0, \">\" = μ > 0, \"≠\" = μ ≠ 0 ( μ is the mean paired difference of the population). Results are returned in list form as {Probability value, t-test statistic}.",
        "examples": [
            {
                "description": "TTestPaired with sample data and tail \"<\"",
                "command": "TTestPaired({1, 2, 3, 4, 5}, {1, 1, 3, 5, 5}, \"<\")"
            }
        ],
        "note": "The example yields {0.5, 0} as the result."
    },
    {
        "signature": "Column( <Spreadsheet Cell> )",
        "commandBase": "Column",
        "description": "Returns the column of the cell as a number (starting at 1).",
        "examples": [
            {
                "description": "q = Column(B3) returns q = 2 since column B is the second column of the spreadsheet.",
                "command": "Column(B3)"
            }
        ],
        "note": ""
    },
    {
        "signature": "Parameter( <Parabola> )",
        "commandBase": "Parameter",
        "description": "Returns the parameter of the parabola, which is the distance between the directrix and the focus.",
        "examples": [
            {
                "description": "Parameter(y = x2 - 3x + 5) returns 0.5.",
                "command": "Parameter(y = x2 - 3x + 5)"
            }
        ],
        "note": ""
    }
]